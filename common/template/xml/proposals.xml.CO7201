<projects>
<project label="ec18b4a5d20e3924736970bdc8da02fa">
  <title>A graphical programming language for the Android platform</title>
  <supervisor>
    <ab373 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>A good understanding of OO-programming. Interest for mobile devices and software development. </p></prerequisites>
  <profiles><SET/><SFS/><WAS/><ADS/><ASE/></profiles>
  <aims><p><a href="http://en.wikipedia.org/wiki/Android_%28operating_system%29">Android</a>is an operative system for mobile devices that competes with the iPhone OS. Currently the Android SDK provides a set of facilities for developing applications for the Android platform (including an emulator). The aim of this project is to develop a domain-specific language (DSL) for defining the GUI of Android applications so that fully-fledged GUIs can be generated and deployed automatically. </p><p>Depending on the interest of the student the DSL can be tuned to include persistence facilities, control structures, etc. </p></aims>
  <challenges><p>The challenges of this project can be found in the following areas:<ul><li>software specification</li><li>automatic prototyping</li><li>development of applications for mobile devices</li> </ul> </p></challenges>
  <learning-outcomes><p>Upon successful completion of the project, the student will learn:<ul><li>techniques for metamodelling and code generation</li><li>to develop basic applications on the Android platform</li><li>to specify the requirements of an application, to design a system, to develop an application and to test it</li> </ul> </p></learning-outcomes>
  <end-product><p>Modelling environment for graphical Android applications and a compiler. </p></end-product>
  <timetable><p><ul><li>Study of the Android platform and SDK</li><li>Study and choice of the metamodelling environment</li><li>Specification, design and development of an initial prototype for the modeling environment and compiler</li><li>Development and evaluation of the compiler</li> </ul> </p></timetable>
  <references></references>
</project>
<project label="95ab228482723efe72ef0ecf72173d47">
  <title>A model transformation compiler</title>
  <supervisor>
    <ab373 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>CO7207 and/or CO7217 </p></prerequisites>
  <profiles><SET/><ASE/></profiles>
  <aims><p>To develop a model compiler for the model transformation language MOMENT2 by using code generation techniques. </p><p>MOMENT2 model transformations are models that conform to the MOMENT2 metamodel. This project will consist in a compiler of MOMENT2 transformation to code so that they can be simulated. </p></aims>
  <challenges><p><ul><li>Defining the semantics of model transformations.</li><li>Using code generation techniques</li><li>Development of an Eclipse plugin for compiling model transformations</li> </ul> </p></challenges>
  <learning-outcomes><p>At the end of the project, the student should be able to: </p><ul><li>analyse existing software to extend it,</li><li>analyse, design and implement a computational problem,</li><li>define interoperability bridges between different technologies: Eclipse and a programming language,</li><li>define model transformations between EMF-metamodels,</li><li>and develop Eclipse plug-ins.</li> </ul></learning-outcomes>
  <end-product><p>Model compiler plug-in as described above. </p></end-product>
  <timetable><ul><li>Experiment with technology for code generation</li><li>Understand the MOMENT2 metamodel</li><li>Decide data structures to be used in the compiler</li><li>Define a strategy for compiling MOMENT2 models</li><li>Develop the compiler</li><li>Integrate the compiler into the MOMENT2 front-end</li> </ul></timetable>
  <references></references>
</project>
<project label="8115b4f9ab2471bc78cd189c22f751b8">
  <title>A tool for mapping software artifacts</title>
  <supervisor>
    <ab373 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>A good understanding of OO-programming. </p></prerequisites>
  <profiles><SET/><SFS/><ASE/></profiles>
  <aims><p>Software applications are evolving constantly and mechanisms to perform changes and to track them help in maintaining applications. For instance, when a relational schema is defined from a class diagram the correspondences between the elements in both the class diagram and the relational schema could be tracked by means of mappings so that if a class is modified we can easily find out which table needs to be updated. The aim of this project is to provide a graphical mapping tool to enhance software evolution. </p></aims>
  <challenges><p>The challenges of this project can be found in the following areas:<ul><li>software evolution and change propagation</li><li>model-driven development techniques for defining software artifacts</li><li>graphical visualization of mappings</li> </ul> </p></challenges>
  <learning-outcomes><p>The student will learn:<ul><li>to specify the requirements of an application, to design a system, to develop an application and to test it</li><li>techniques for software evolution and change propagation</li><li>use graphical libraries for implementing user-friendly tools</li><li>model-driven development techniques for representing software artifacts</li> </ul> </p></learning-outcomes>
  <end-product><p>Graphical tool for mapping software artifacts. </p></end-product>
  <timetable><ul><li>Study model-driven development techniques for representing software artifacts: metamodeling techniques, XML, Eclipse Modeling Framework/Microsoft DSL tools/Microsoft Oslo</li><li>Specification, design and development of an initial prototype for mapping software artifacts</li><li>Development of a language for defining mappings to keep track of changes.</li><li>Specification, design, development and testing of a complete graphical environment for mapping software artifacts and to traverse mappings.</li> </ul></timetable>
  <references></references>
</project>
<project label="755944c8fd4d63faf72a3c29064add7e">
  <title>An application for verifying requirements over software artifacts with OCL</title>
  <supervisor>
    <ab373 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>A good understanding of OO-programming. </p></prerequisites>
  <profiles><SET/><SFS/><ASE/></profiles>
  <aims><p><a href="http://en.wikipedia.org/wiki/Model-driven_engineering">Model-driven engineering</a>is a successor paradigm of object-oriented programming, where models are collections of objects that represent software artifacts, such as java programs, relational schemas in databases, UML models (class diagrams, activity diagrams...), etc. Models play a crucial role in a software development process since they are used to design the requirements of an application enhancing automatic code generation, increasing productivity and reducing costs. Therefore, providing mechanisms to guarantee that models are correct with regard application requirements are important. In this project, the student will learn model-driven development techniques based on the<a href="http://www.eclipse.org/modeling/emf/">Eclipse Modeling Framework</a>to define models and to verify the correctness of requirements with the Object Constraint Language (OCL). The aim of the project is to build an application in Eclipse that reuses libraries for defining EMF models and for evaluating OCL queries. </p></aims>
  <challenges><p>The challenges of this project can be found in the following areas:
  <ul>
    <li>metamodelling techniques for defining modelling languages (metamodels) and models</li>
    <li>use of EMF and OCL</li>
    <li>develop an application that enables the validation of requirements over EMF models</li>
  </ul> 
  </p></challenges>
  <learning-outcomes><p>The student will learn:
  <ul>
    <li>to specify the requirements of an application, to design a system, to develop an application and to test it</li>
    <li>model-driven development techniques and tools: EMF, OCL</li>
    <li>development of Eclipse plug-ins</li>
    <li>techniques for checking the correctness of software artifacts</li>
  </ul> 
  </p></learning-outcomes>
  <end-product><p>Eclipse plugin that provides an interface for checking OCL constraints and for querying EMF models.</p>
  </end-product>
  <timetable><ul>
    <li>Study of model-driven development techniques: EMF and OCL</li>
    <li>Specification, design and development of an initial prototype for checking OCL invariants over EMF models in a generic way</li>
    <li>Development of an application for verifying models with OCL constraints and for reporting errors</li>
    <li>Development of a user-friendly interface for evaluating OCL constraints over EMF models</li>
    <li>Development of a user-friendly interface for querying OCL constraints over EMF models</li>
    <li>Specification, design and development of a complete prototype for checking OCL invariants over EMF models</li>
  </ul> </timetable>
  <references></references>
</project>
<project label="dfb4b64ea777e3da350b3ed7159f704e">
  <title>Book order system</title>
  <supervisor>
    <ab373 />
  </supervisor>
  <hidden>N/A</hidden>
  <prerequisites><p>A good understanding of OO-programming. </p></prerequisites>
  <profiles><SET/><SFS/><WAS/><ASE/></profiles>
  <aims><p>Design, develop and test an application for ordering books. The system will consist of two main subsystems: administration system and user system. The administration system provides: budget administration, email management to send notifications to people involved in a purchase, log of purchased books and support for statistics. The user system is a web application system that permits the creation of book orders. Every time a book is ordered, the order appears in the administration system so that the administrator confirms the order. When a book is ordered, budget information should be kept updated. Statistic information will report figures about types of books that have been purchased. </p></aims>
  <challenges><p>The challenges of this project can be found in the following areas:<ul><li>development of distributed systems</li><li>specification, design and development of an application with several subsystems</li><li>datamining techniques for showing statistics</li> </ul> </p></challenges>
  <learning-outcomes><p>The student will learn:<ul><li>specify the requirements of an application, design a system, develop an application and test it</li><li>produce an object-oriented design of a software system to implement</li><li>development of distributed systems</li><li>produce informative reports and statistics</li> </ul> </p></learning-outcomes>
  <end-product><p>Software as described above. </p></end-product>
  <timetable><ul><li>Specification, design and development of an initial prototype for ordering books</li><li>Email management</li><li>Report generation</li><li>Budget administration</li> </ul></timetable>
  <references></references>
</project>
<project label="3a37531e9ce1b6b56a56f4375ad90528">
  <title>Bridging Microsoft Oslo to EMF for defining DSLs</title>
  <supervisor>
    <ab373 />
  </supervisor>
  <hidden>not proposed</hidden>
  <prerequisites><p>A good understanding of OO-programming. </p></prerequisites>
  <profiles><SET/><ASE/></profiles>
  <aims><p>Modeling has always been a tool for engineers (see<b><a href="http://wm.microsoft.com/ms/msdn/oslo/ModelingThroughtheAges.wmv">Microsoft's vision</a></b>). In software engineering, modeling techniques and tools have been developed to enhance software design and production. The<b><a href="http://www.eclipse.org/modeling/emf/">Eclipse Modeling Framework</a></b>is one of the leading initiatives in this field. Microsoft's response is based on the new<b><a href="http://msdn.microsoft.com/en-gb/oslo/default.aspx">Oslo application development platform</a></b>. The aims of this project are: (1) understand fundamental notions of model-driven development (metamodel, model, DSL), (2) understand MSchema (Oslo) and Ecore (EMF) modeling languages, (3) design and implement a mapping between both. This bridge will enhance the reuse of mature tools based on EMF and technology based on the .NET framework. </p></aims>
  <challenges><p>The challenges of this project can be found in the following areas:<ul><li>model-driven development techniques: including parsers and code generation techniques</li><li>metamodelling techniques for defining modelling languages (metamodels) and models</li><li>develop an application that enables the representation of models</li><li>learn Eclipse Modeling Framework and Oslo</li><li>interoperability of different technology platforms through XML or textual DSLs</li> </ul> </p></challenges>
  <learning-outcomes><p>The student will:<ul><li>carry out a detailed requirements analysis and specification of the problem.</li><li>produce an object-oriented design of a software system to implement</li><li>learn about model-driven development and metamodeling techniques</li><li>learn about Eclipse Modeling Framework, Microsoft's Oslo and their application for model-driven software development</li> </ul> </p></learning-outcomes>
  <end-product><p>Prototype as described above </p></end-product>
  <timetable></timetable>
  <references></references>
</project>
<project label="e8aa167f7d1aab5242373f7737562392">
  <title>Defining graphical modeling languages in GEMS</title>
  <supervisor>
    <ab373 />
  </supervisor>
  <hidden>available Spring 09</hidden>
  <prerequisites><p>Notions in model-driven development. </p></prerequisites>
  <profiles><SET/><ASE/></profiles>
  <aims><p>"The goal of the Generic Eclipse Modeling System (GEMS) is to bridge the gap between the communities experienced with visual metamodeling tools, such as the Generic Modeling Environment (GME), and those built around the Eclipse modeling technologies, such as the Eclipse Modeling Framework (EMF) and Graphical Modeling Framework (GMF)." </p><p>The aim of this project consists in the study of GEMS for defining domain-specific languages with graphical facilities and in the development of a non-trivial case study. In addition, a thorough study of related work has to be presented. </p></aims>
  <challenges><ul><li>Understanding how software engineering modeling languages are defined.</li><li>Understanding and applying GEMS, an experimental tool for defining graphical modeling languages.</li><li>Methodological study of GEMS comparing it to other tools with similar capabilities: GMF, DSL tools, MetaEdit+.</li> </ul></challenges>
  <learning-outcomes><p>At the end of the project, the student should be able to: </p><ul><li>analyse and discuss existing software for defining modeling languages,</li><li>define modeling languages with GEMS and understand how they could be implemented with other tools,</li><li>and develop Eclipse plug-ins.</li> </ul></learning-outcomes>
  <end-product><p>Comparative study of GEMS and a non-trivial case study. The main outcome should rely on the discussion of the GEMS approach for defining modeling languages. </p></end-product>
  <timetable><ul><li>Preliminary study of GEMS and related tools.</li><li>Definition of a case study.</li><li>Complete study of GEMS by developing the case study.</li><li>Comparison with other approaches.</li> </ul></timetable>
  <references><reference>
  <author>GEMS home page</author>
  <note><a href="http://www.eclipse.org/gmt/gems/">http://www.eclipse.org/gmt/gems/</a></note>
  </reference></references>
</project>
<project label="84fc3a22d552d2635fd1db9ae5e33e16">
  <title>Development of a model transformation engine for the QVT Relations language</title>
  <supervisor>
    <ab373 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Notions in model-driven development. </p></prerequisites>
  <profiles><SET/><ASE/></profiles>
  <aims><p>Model transformations are essential in model-driven development processes because they constitute the mechanism to manipulate data (models). Model transformation languages have been proposed and studied, such as the Relations language in the Query/Views/Transformations standard. The aim of this project consists in the definition of a model transformation engine for the Relations language by using Maude. </p></aims>
  <challenges><ul><li>Definition of the relational semantics of QVT with Maude.</li> </ul></challenges>
  <learning-outcomes><ul><li>Model transformations and applications.</li><li>Compilation techniques.</li><li>Development of plugins in Eclipse.</li> </ul></learning-outcomes>
  <end-product><p>Prototype for the QVT Relations language and Eclipse plugin to interact with it. </p></end-product>
  <timetable><ul><li>Detailed list of requirements.</li><li>Prototyping of needed components.</li><li>Implementing the system.</li><li>Testing and case studies.</li><li>Documentation.</li> </ul></timetable>
  <references><reference>
  <author>OMG</author>
  <published year="2007">MOF QVT final adopted specification. Chapters 6 and 7.</published>
  <note><a href="http://www.omg.org/docs/ptc/07-07-07.pdf">http://www.omg.org/docs/ptc/07-07-07.pdf</a></note>
  </reference><reference>
  <author>MOMENT2</author>
  <published year="2008">MOMENT2: model transformations with EMF and Maude</published>
  <note><a href="http://www.cs.le.ac.uk/people/aboronat/tools/moment2/">http://www.cs.le.ac.uk/~aboronat/tools/moment2/</a></note>
  </reference></references>
</project>
<project label="d2ed5c46fff0f850755f5fa7dd255a11">
  <title>Eclipse front-end for a model checker</title>
  <supervisor>
    <ab373 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Programming skills in Java. </p></prerequisites>
  <profiles><SET/><ADS/><ASE/></profiles>
  <aims><p>Model transformations can be used for defining the dynamics of model-based software systems so that certain critical properties can be proved. Model checking is a technique that is used verifying properties of this kind. MOMENT2 is a model transformation engine that reuses Maude model checker for verifying properties of model transformations. This project consists in the development of a user-friendly front-end for this model checker for verifying properties in MOMENT2 model transformations. </p></aims>
  <challenges><ul><li>Discussing how software engineering modelling languages are defined.</li><li>Critically explaining and applying model transformation and model checking techniques in the Eclipse platform.</li><li>Combination of novel technologies and development of software in a methodological way.</li> </ul></challenges>
  <learning-outcomes><p>At the end of the project, the student should be able to: </p><ul><li>analyse existing software to extend it,</li><li>analyse, design and implement a computational problem,</li><li>define interoperability bridges between different technologies: Eclipse and Maude,</li><li>define model transformations between EMF-metamodels,</li><li>and develop Eclipse plug-ins.</li> </ul></learning-outcomes>
  <end-product><p>Eclipse plugin for defining properties that have to be defined and for processing the output of the model checker. The prototype will consist of a small front-end for sending commands to the model checker and a parser for presenting the output of the model checker in a user-friendly way. </p></end-product>
  <timetable><ul><li>Detailed list of requirements.</li><li>Prototyping of needed components.</li><li>Implementing the system.</li><li>Testing and case studies.</li><li>Documentation.</li> </ul></timetable>
  <references><reference>
  <author>Boronat, A</author>
  <published year="2008">MOMENT2: model transformations with EMF and Maude</published>
  <note><a href="http://www.cs.le.ac.uk/people/aboronat/tools/moment2/">http://www.cs.le.ac.uk/~aboronat/tools/moment2/</a></note>
  </reference><reference>
  <author>Clavel, M., Duran, F., Eker, S., Meseguer, J., Lincoln, P., Marti-Oliet, N., Talcott, C.</author>
  <published year="2007">All About Maude. Springer LNCS Vol. 4350</published>
  </reference></references>
</project>
<project label="214bb22c9a111a16f1a40954652ead15">
  <title>Enterprise information integration</title>
  <supervisor>
    <ab373 />
  </supervisor>
  <hidden>n/a</hidden>
  <prerequisites><p>A good understanding of OO-programming. </p></prerequisites>
  <profiles><SET/><SFS/><ASE/></profiles>
  <aims><p>Software applications are evolving constantly and mechanisms to perform changes and to track them help in maintaining applications. For instance, when a relational schema is defined from a class diagram the correspondences between the elements in both the class diagram and the relational schema could be tracked by means of mappings so that if a class is modified we can easily find out which table needs to be updated. The aim of this project is to provide a graphical mapping tool to enhance software evolution. </p></aims>
  <challenges><p>The challenges of this project can be found in the following areas:<ul><li>software evolution and change propagation</li><li>model-driven development techniques for defining software artifacts</li><li>graphical visualization of mappings</li> </ul> </p></challenges>
  <learning-outcomes><p>The student will learn:<ul><li>to specify the requirements of an application, to design a system, to develop an application and to test it</li><li>techniques for software evolution and change propagation</li><li>use graphical libraries for implementing user-friendly tools</li><li>model-driven development techniques for representing software artifacts</li> </ul> </p></learning-outcomes>
  <end-product><p>Graphical tool for mapping software artifacts. </p></end-product>
  <timetable><ul><li>Study model-driven development techniques for representing software artifacts: metamodeling techniques, XML, Eclipse Modeling Framework/Microsoft DSL tools/Microsoft Oslo</li><li>Specification, design and development of an initial prototype for mapping software artifacts</li><li>Development of a language for defining mappings to keep track of changes.</li><li>Specification, design, development and testing of a complete graphical environment for mapping software artifacts and to traverse mappings.</li> </ul></timetable>
  <references></references>
</project>
<project label="96ab92a01eaf820902b6bd2c8e4c602b">
  <title>Executable UML</title>
  <supervisor>
    <ab373 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>A good understanding of OO-programming. </p></prerequisites>
  <profiles><SET/><SFS/><ASE/></profiles>
  <aims><p>UML is widely used for designing systems. Traditionally, UML modelling tools have supported the generation of the code that corresponds to the structure of the application, ignoring the specification of the system behaviour. </p><p>The project consists in: identifying sublanguages of UML that can be used for defining a complete executable system, including the structural view and the behaviour specification; defining the transformational semantics of the language in terms of a code compiler; developing a compiler from UML models to programs in a target language; and validating the compiler by generating executable prototypes from UML "formal" models. </p><p>Several strategies can be used to develop the front-end: the Eclipse UML tools can be extended with the compiler or a subset of UML can be defined as a DSL. </p><p>Several strategies can be used to provide the semantics of the language depending on the target platform of the compiler: a functional approach using Haskell (or OCaml), an algebraic approach using Maude, a compiler to a conventional imperative language (Java, C#, Python, …). </p></aims>
  <challenges><p>The challenges of this project can be found in the following areas:<ul><li>software specification</li><li>automatic prototyping</li><li>tool integration</li> </ul> </p></challenges>
  <learning-outcomes><p>Upon successful completion of the project, the student will learn:<ul><li>techniques for code generation</li><li>the semantics of UML for specifying complete systems</li><li>model-driven development techniques for representing software artifacts</li><li>to specify the requirements of an application, to design a system, to develop an application and to test it</li> </ul> </p></learning-outcomes>
  <end-product><p>Compiler from UML to executable prototypes. </p></end-product>
  <timetable><p><ul><li>Study of the semantics of UML, the target language of choice and UML modelling environments</li><li>Specification, design and development of an initial prototype for the compiler</li><li>Development and evaluation of the compiler</li> </ul> </p></timetable>
  <references><reference>
  <author>Raistrick, Chris; Francis, Paul; Wright, John; Carter, Colin; Wilkie, Ian</author>
  <volume>Model driven architecture with Executable UML. Cambridge University Press</volume>
  <published year="2004"></published>
  </reference><reference>
  <author>Mellor, Stephen J.; Balcer, Marc</author>
  <volume>Executable UML: A foundation for model-driven architecture. Addison Wesley</volume>
  <published year="2002"></published>
  <note></note>
  </reference></references>
</project>
<project label="b0ce64009dadb97b053e19b422a8ae3d">
  <title>Friendly user interface for evaluating OCL expressions</title>
  <supervisor>
    <ab373 />
  </supervisor>
  <hidden>offered in spring 08/09</hidden>
  <prerequisites><p>Programming skills in Java. </p></prerequisites>
  <profiles><SET/><ASE/></profiles>
  <aims><p>"The Object Constraint Language (OCL) is a textual sublanguage of the Unified Modelling Language (UML). It can be used to express additional constraints on UML models that cannot be expressed, or are very difficult to express, with the graphical means provided by UML. OCL is based on first-order predicate logic but it uses a syntax similar to programming languages and closely related to the syntax of UML. It is, thus, more adequate for every-day modelling than pure first-order predicate logic." </p><p>In addition OCL can be used to express queries that may be used in model transformations. MOMENT2 provides support for executing OCL constraints and queries. The aim of this project consists in developing a user-friendly front-end for defining OCL expressions, for testing them and for visualising OCL expression evaluation results. </p></aims>
  <challenges><ul><li>Understanding how software engineering modelling languages are defined.</li><li>Understanding and applying the OCL language for defining model-based systems in the Eclipse platform.</li><li>Combination of novel technologies and development of software in a methodological way.</li><li>Extensible design of the tool to reuse different OCL engines.</li> </ul></challenges>
  <learning-outcomes><p>At the end of the project, the student should be able to: </p><ul><li>analyse existing software to extend it,</li><li>analyse, design and implement a computational problem,</li><li>define modular and extensible software,</li><li>and develop Eclipse plug-ins.</li> </ul></learning-outcomes>
  <end-product><p>Eclipse plugin for defining OCL expressions and for executing them. </p></end-product>
  <timetable><ul><li>Study of tools that provide support for OCL and detailed list of requirements.</li><li>Prototyping of needed components.</li><li>Implementing the system.</li><li>Testing and case studies.</li><li>Documentation.</li> </ul></timetable>
  <references><reference>
  <author>Boronat, A</author>
  <published year="2008">MOMENT2: OCL and Maude</published>
  <note><a href="http://www.cs.le.ac.uk/people/aboronat/tools/moment2/">http://www.cs.le.ac.uk/~aboronat/tools/moment2/</a></note>
  </reference><reference>
  <author>OCL Portal</author>
  <note><a href=" http://www-st.inf.tu-dresden.de/ocl/ ">http://www-st.inf.tu-dresden.de/ocl/</a></note>
  </reference></references>
</project>
<project label="e06479bad3ededa73284f538bbcdaaf4">
  <title>Graphical model transformations</title>
  <supervisor>
    <ab373 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Java programming skills </p></prerequisites>
  <profiles><SET/><ASE/></profiles>
  <aims><p>MOMENT2 provides an environment for defining model transformations textually. However a graphical representation of a model transformation is useful for presentations and for better understanding. The purpose of this project is to develop a graphical front-end for the MOMENT2 model transformation language. Several options can be analysed: reuse of existing technology (The Tiger EMF Transformation Project) or definition of the tool by reusing graphical libraries (GraphViz, Zest). </p></aims>
  <challenges><ul><li>Critical analysis of the advantages of graphical modelling languages.</li><li>Analysis of different approaches for the graphical representation of software artifacts.</li><li>Combination of novel technologies and development of software in a methodological way.</li> </ul></challenges>
  <learning-outcomes><p>At the end of the project, the student should be able to: </p><ul><li>analyse several approaches for graphically representing model transformations,</li><li>analyse, design and implement a computational problem,</li><li>propose new features related to the prototype,</li><li>synthesize information and present it in the form of a dissertation,</li><li>and develop Eclipse plug-ins.</li> </ul></learning-outcomes>
  <end-product><p>Eclipse plugin for graphically depicting MOMENT2 model transformations. </p></end-product>
  <timetable><ul><li>Detailed list of requirements.</li><li>Prototyping of needed components.</li><li>Implementing the system.</li><li>Testing and case studies.</li><li>Documentation.</li> </ul></timetable>
  <references><reference>
  <author>EMF</author>
  <published year="2009">Eclipse Modeling Framework</published>
  <note><a href="http://www.eclipse.org/emf">http://www.eclipse.org/emf</a></note>
  </reference><reference>
  <author>EMF Transformation Development Team</author>
  <published year="2009">Tiger EMF Transformation Project</published>
  <note><a href="http://tfs.cs.tu-berlin.de/emftrans/">http://tfs.cs.tu-berlin.de/emftrans/</a></note>
  </reference><reference>
  <author>Clay, M. and Voelter, M.</author>
  <published year="2009">Visualizing EMF models with Graphviz</published>
  <note><a href="http://voelterblog.blogspot.com/2008/06/visualizing-emf-models-with-graphviz.html">http://voelterblog.blogspot.com/2008/06/visualizing-emf-models-with-graphviz.html</a></note>
  </reference><reference>
  <author>Zest</author>
  <published year="2009"></published>
  <note><a href="http://www.eclipse.org/gef/zest/">http://www.eclipse.org/gef/zest/</a></note>
  </reference><reference>
  <author>Boronat, A</author>
  <published year="2008">MOMENT2: model transformations with EMF and Maude</published>
  <note><a href="http://www.cs.le.ac.uk/people/aboronat/tools/moment2/">http://www.cs.le.ac.uk/~aboronat/tools/moment2/</a></note>
  </reference></references>
</project>
<project label="2b6cafca73bc859e29a3fca4d9252544">
  <title>Graphical representation of models as object diagrams</title>
  <supervisor>
    <ab373 />
  </supervisor>
  <hidden>done</hidden>
  <prerequisites><p>Programming skills in Java </p></prerequisites>
  <profiles><SET/><ASE/></profiles>
  <aims><p>Models are collections of objects that can be displayed as object diagrams. A graphical environment for defining models and for depicting them is useful for debugging model-based systems and model transformations. The main aim of this project is the study of several approaches for defining graphs within the Eclipse platform: GraphViz in EMF, Zest and Generic GMF editor; and the development of a generic graphical editor for models on top of the Eclipse Modeling Framework. </p></aims>
  <challenges><ul><li>Understanding the advantages of graphical modelling languages.</li><li>Analysis of different approaches for the graphical representation of models.</li><li>Combination of novel technologies and development of software in a methodological way.</li> </ul></challenges>
  <learning-outcomes><p>At the end of the project, the student should be able to: </p><ul><li>analyse several approaches for graphically representing models,</li><li>analyse, design and implement a computational problem,</li><li>propose new features related to the prototype,</li><li>synthesize information and present it in the form of a dissertation,</li><li>and develop Eclipse plug-ins.</li> </ul></learning-outcomes>
  <end-product><p>Eclipse plugin for graphically depicting models as object diagrams in a generic way, that is, independently of the metamodel that is used for defining the corresponding model. </p></end-product>
  <timetable><ul><li>Detailed list of requirements.</li><li>Prototyping of needed components.</li><li>Implementing the system.</li><li>Testing and case studies.</li><li>Documentation.</li> </ul></timetable>
  <references><reference>
  <author>EMF</author>
  <published year="2009">Eclipse Modeling Framework</published>
  <note><a href=" Eclipse Modeling Framework">Eclipse Modeling Framework</a></note>
  </reference><reference>
  <author>Clay, M. and Voelter, M.</author>
  <published year="2009">Visualizing EMF models with Graphviz</published>
  <note><a href="http://voelterblog.blogspot.com/2008/06/visualizing-emf-models-with-graphviz.html">http://voelterblog.blogspot.com/2008/06/visualizing-emf-models-with-graphviz.html</a></note>
  </reference><reference>
  <author>Zest</author>
  <published year="2009"></published>
  <note><a href="http://www.eclipse.org/gef/zest/">http://www.eclipse.org/gef/zest/</a></note>
  </reference><reference>
  <author>Dynamic GMF</author>
  <published year="2009"></published>
  <note><a href="http://dynamicgmf.sourceforge.net/">http://dynamicgmf.sourceforge.net/</a></note>
  </reference></references>
</project>
<project label="f2f55b300769ba655a17d3b63ea2d269">
  <title>How to improve recruitment and to suggest original applications by using Facebook and Google Gadgets</title>
  <supervisor>
    <ab373 />
  </supervisor>
  <hidden>Taken by Thomas Klein - individual proposal</hidden>
  <prerequisites><p> </p></prerequisites>
  <profiles><SET/><WAS/><ASE/></profiles>
  <aims><p> </p></aims>
  <challenges><p> </p></challenges>
  <learning-outcomes><p> </p></learning-outcomes>
  <end-product><p> </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="524683a35825c47ea7e5d3f2d6d34397">
  <title>Integration of MOMENT2 within the NAOMI Framework</title>
  <supervisor>
    <ab373 />
  </supervisor>
  <hidden>available Spring 09</hidden>
  <prerequisites><p>Programming skills in Java. </p></prerequisites>
  <profiles><SET/><ASE/></profiles>
  <aims><p>Lockheed Martin Advanced Technology Laboratories' (ATL) NAOMI project is part of the Lockheed Martin's Corporate Software Technology Initiative (STI) and is developed in collaboration with the University of California at Berkeley, the University of Illinois at Urbana Champaign, the University of Leicester, and the Vanderbilt University. </p><p>The objective of the NAOMI project is to explore how the precision of multiple domain specific modelling languages can be leveraged, leading to more accurate and complete models. Through the use of models that describe both the structure and the behavior of the system under design, NAOMI will enable enhanced model precision that is not possible with any one individual modelling language. </p><p>The aim of this project consists in the integration of the MOMENT2 tool within the NAOMI Framework for multi-modelling purposes. </p></aims>
  <challenges><ul><li>Analysis of different approaches/technologies for integrating model-based technologies.</li><li>Combination of novel technologies and development of software in a methodological way.</li> </ul></challenges>
  <learning-outcomes><p>At the end of the project, the student should be able to: </p><ul><li>analyse several approaches for developing heterogeneous model-based systems,</li><li>analyse, design and implement a computational problem,</li><li>propose new features related to the prototype,</li><li>synthesize information and present it in the form of a dissertation,</li><li>and develop a web page that uses an Eclipse plugin.</li> </ul></learning-outcomes>
  <end-product><p>A version of the MOMENT2 plugin that can be used within the NAOMI Framework and small case study showing its functionality. </p></end-product>
  <timetable><ul><li>Detailed list of requirements.</li><li>Prototyping of needed components.</li><li>Implementing the system.</li><li>Testing and case studies.</li><li>Documentation.</li> </ul></timetable>
  <references><reference>
  <author>Denton, T., Jones, E., Srinivasan, S., Owens, K., and Buskens, R.W</author>
  <published year="2008">NAOMI - An Experimental Platform for Multi-modelling. MODELS 08. LNCS. Volume 5301/2008</published>
  <note><a href=" http://www.springerlink.com/content/p8445ru583351304/">http://www.springerlink.com/content/p8445ru583351304/</a></note>
  </reference><reference>
  <author>Boronat, A</author>
  <published year="2008">MOMENT2: model transformations with EMF and Maude</published>
  <note><a href="http://www.cs.le.ac.uk/people/aboronat/tools/moment2/">http://www.cs.le.ac.uk/~aboronat/tools/moment2/</a></note>
  </reference></references>
</project>
<project label="7011808b30327d63c82c784960d0cc91">
  <title>Integration of MOMENT2 within the Sensoria Development Environment</title>
  <supervisor>
    <ab373 />
  </supervisor>
  <hidden>taken in CA7201 08/09</hidden>
  <prerequisites><p>Background in web technologies and Java. </p></prerequisites>
  <profiles><SET/><WAS/><ADS/><ASE/></profiles>
  <aims><p>The Sensoria Development Environment is intended to support the development of Service-Oriented Software by integrating the various tools developed as part of the Sensoria project as well as external tools to support the development, analysis, and deployment of service-oriented software systems. </p><p>The aim of this project is the integration of the MOMENT2 tool within the Sensoria Development Environment and develop a small case study. </p></aims>
  <challenges><ul><li>Analysis of different approaches/technologies for integrating model-based technologies.</li><li>Combination of novel technologies and development of software in a methodological way.</li> </ul></challenges>
  <learning-outcomes><p>At the end of the project, the student should be able to: </p><ul><li>analyse several approaches for developing heterogeneous model-based systems,</li><li>analyse, design and implement a computational problem,</li><li>propose new features related to the prototype,</li><li>synthesize information and present it in the form of a dissertation,</li><li>and develop a web page that uses an Eclipse plugin.</li> </ul></learning-outcomes>
  <end-product><p>A version of the MOMENT2 plugin that can be used within the Sensoria Modeling Environment and small case study showing its functionality. </p></end-product>
  <timetable><ul><li>Detailed list of requirements.</li><li>Prototyping of needed components.</li><li>Implementing the system.</li><li>Testing and case studies.</li><li>Documentation.</li> </ul></timetable>
  <references><reference>
  <author>EMF</author>
  <published year="2009">Eclipse Modeling Framework</published>
  <note><a href="http://www.eclipse.org/emf">http://www.eclipse.org/emf</a></note>
  </reference><reference>
  <author>Sensoria</author>
  <published year="2009">Sensoria Development Environment</published>
  <note><a href="http://svn.pst.ifi.lmu.de/trac/sct">http://svn.pst.ifi.lmu.de/trac/sct</a></note>
  </reference><reference>
  <author>Boronat, A</author>
  <published year="2008">MOMENT2: model transformations with EMF and Maude</published>
  <note><a href="http://www.cs.le.ac.uk/people/aboronat/tools/moment2/">http://www.cs.le.ac.uk/~aboronat/tools/moment2/</a></note>
  </reference></references>
</project>
<project label="62e94de6d4d884da652f17d4d9ccc9d4">
  <title>Interactive execution of Maude programs</title>
  <supervisor>
    <ab373 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Programming skills in Java. </p></prerequisites>
  <profiles><SET/><ASE/></profiles>
  <aims><p>Maude is a powerful programming language for specifying and verifying software. For instance, it is used as the back-end of the MOMENT2 model transformation tool. </p><p>This projects consists in the development of a Eclipse front-end for interacting with Maude programs: step-wise execution of programs and for using Maude commands. </p></aims>
  <challenges><ul><li>Learning how Maude and its commands are used to develop and verify programs.</li><li>Definition of a DSL for interacting with Maude.</li><li>Combination of novel tecnologies and development of software in a methodological way.</li> </ul></challenges>
  <learning-outcomes><p>At the end of the project, the student should be able to: </p><ul><li>analyse existing software to extend it,</li><li>analyse, design and implement a computational problem,</li><li>define interoperability bridges between different technologies: Eclipse and Maude,</li><li>define model transformations between EMF-metamodels,</li><li>and develop Eclipse plug-ins.</li> </ul></learning-outcomes>
  <end-product><p>Eclipse plugin with a front-end to interact with Maude. The development of this plugin involves: development of a GUI in Eclipse, use of Java for implementing functionality and use of certain Maude commands for providing user interaction with model transformations. </p></end-product>
  <timetable><ul><li>Detailed list of requirements.</li><li>Prototyping of needed components.</li><li>Implementing the system.</li><li>Testing and case studies.</li><li>Documentation.</li> </ul></timetable>
  <references><reference>
  <author>Boronat, A</author>
  <published year="2008">MOMENT2: model transformations with EMF and Maude</published>
  <note><a href="http://www.cs.le.ac.uk/people/aboronat/tools/moment2/">http://www.cs.le.ac.uk/~aboronat/tools/moment2/</a></note>
  </reference><reference>
  <author>Clavel, M., Duran, F., Eker, S., Meseguer, J., Lincoln, P., Marti-Oliet, N., Talcott, C.</author>
  <published year="2007">All About Maude. Springer LNCS Vol. 4350</published>
  </reference></references>
</project>
<project label="c6a7078b92b8ee512a9b1ec20f3a7b8d">
  <title>Interactive execution of model transformations</title>
  <supervisor>
    <ab373 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Programming skills in Java. Notions in model-driven development. </p></prerequisites>
  <profiles><SET/><ASE/></profiles>
  <aims><p>Model transformations are essential in model-driven development processes because they constitute the mechanism to manipulate data (models). Several model transformation engines already provide support for manipulating models but there are not so many tools that permit applying transformation rules in an interactive way, that is, the user chooses which rule to apply each time. Interactive model transformations are useful for debugging and for applying non-deterministic model transformations. </p><p>Development of a front-end for the model transformation engine MOMENT2 so that model transformations can be executed in an interactive way. </p></aims>
  <challenges><ul><li>Assessment of how software engineering modelling languages are defined.</li><li>Critical analysis of the application of model transformation techniques in the Eclipse platform.</li><li>Combination of novel tecnologies and development of software in a methodological way.</li> </ul></challenges>
  <learning-outcomes><p>At the end of the project, the student should be able to: </p><ul><li>analyse existing software to extend it,</li><li>analyse, design and implement a computational problem,</li><li>define interoperability bridges between different technologies: Eclipse and Maude,</li><li>define model transformations between EMF-metamodels,</li><li>and develop Eclipse plug-ins.</li> </ul></learning-outcomes>
  <end-product><p>Eclipse plugin with a front-end to interact with a model transformation engine. MOMENT2 is an Eclipse plugin that is run on top of Maude, a term rewriting system. The development of this plugin involves: development of a GUI in Eclipse, use of Java for implementing functionality and use of certain Maude commands for providing user interaction with model transformations. </p></end-product>
  <timetable><ul><li>Detailed list of requirements.</li><li>Prototyping of needed components.</li><li>Implementing the system.</li><li>Testing and case studies.</li><li>Documentation.</li> </ul></timetable>
  <references><reference>
  <author>Boronat, A</author>
  <published year="2008">MOMENT2: model transformations with EMF and Maude</published>
  <note><a href="http://www.cs.le.ac.uk/people/aboronat/tools/moment2/">http://www.cs.le.ac.uk/~aboronat/tools/moment2/</a></note>
  </reference><reference>
  <author>Clavel, M., Duran, F., Eker, S., Meseguer, J., Lincoln, P., Marti-Oliet, N., Talcott, C.</author>
  <published year="2007">All About Maude. Springer LNCS Vol. 4350</published>
  </reference></references>
</project>
<project label="42e638523183bd795a9fae997d17ffee">
  <title>Interoperability between GXL and EMF</title>
  <supervisor>
    <ab373 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>XML and Java skills, and Eclipse Modeling Framework. </p></prerequisites>
  <profiles><SET/><ASE/></profiles>
  <aims><p>Graph transformation tools permit transforming information that is represented by means of graphs. These tools provide a novel approach to deal with model transformations. However, they are not normally connected to mainstream modelling environments such as the Eclipse Modeling Framework (EMF). The Graph eXchange Language (GXL) is used to represent graphs in XML format in these tools. The goal of this project consists in defining a bridge between GXL and EMF so that type graphs can be represented as metamodels, and graphs can be defined as well-formed models. </p></aims>
  <challenges><p>Assessment of how software engineering modelling languages are defined. </p><p>Critical analysis of the application of model transformation techniques in the Eclipse platform. </p><p>Combination of novel tecnologies and development of software in a methodological way. </p></challenges>
  <learning-outcomes><p>At the end of the project, the student should be able to: </p><ul><li>analyse computational problems related to model transformations/data migration/reverse engineering,</li><li>discriminate between different approaches for data migration,</li><li>define model transformations between EMF-metamodels,</li><li>and develop Eclipse plug-ins.</li> </ul></learning-outcomes>
  <end-product><p>Eclipse plug-in for transforming GXL type graphs and graphs into EMF metamodels and models, respectively. The corresponding reverse model transformations are also desirable. </p></end-product>
  <timetable><p>Reading of background material. </p><p>Getting familiar with GXL, EMF and model transformations. </p><p>Selection of software tools to be used in the project, and getting familiar with them. </p><p>Iterations: EMF support for GXL and encapsulation into a plugin, model transformation GXL-&gt;EMF (metamodels and models), encapsulation of the transformations into a plugin, reverse transformations. </p><p>Documentation and testing. </p><p>Evaluation of results. </p><p>Deployment of the plugins. </p></timetable>
  <references><reference>
  <author>EMF</author>
  <published year="2008">Eclipse Modeling Framework</published>
  <note><a href="http://www.eclipse.org/modeling/emf/">http://www.eclipse.org/modeling/emf/</a></note>
  </reference><reference>
  <author>GXL</author>
  <published year="2008">Ric Holt , Andy Schuerr, Susan Elliott Sim, Andreas Winter: Graph eXchange Language</published>
  <note><a href="http://www.gupro.de/GXL/">http://www.gupro.de/GXL/</a></note>
  </reference><reference>
  <author>MOMENT2</author>
  <published year="2008">MOMENT2: model transformations with EMF and Maude</published>
  <note><a href="http://www.cs.le.ac.uk/people/aboronat/tools/moment2/">http://www.cs.le.ac.uk/~aboronat/tools/moment2/</a></note>
  </reference></references>
</project>
<project label="1f27fe4667aae2fae040bb006d40144d">
  <title>Model-driven development of a CV organiser</title>
  <supervisor>
    <ab373 />
  </supervisor>
  <hidden>not proposed</hidden>
  <prerequisites><p>A good understanding of OO-programming. </p></prerequisites>
  <profiles><SET/><ASE/></profiles>
  <aims><p>Maintaining a up-to-date CV is crucial for any professional but it can become a nightmare as well: different companies may ask for different formats, information can be spread among several files, etc. </p><p>The aim of this project is to develop a tool for managing the information that is added to an academic CV: personal information, degrees, publications (papers, journals), presentations and talks, participation in committees. The application has to provide: (1) user-friendly interface for introducing data, (2) centralized storage for data, (3) different mechanisms for exporting data as HTML, Latex, PDF through<b><a href="http://en.wikipedia.org/wiki/DocBook">DocBook</a></b>, (4) mechanisms for customizing the output information (for instance, by grouping publications by topic). </p><p>An important aspect of this project is to study and to use model-driven development techniques for developing the application: 1) Definition of the model of the problem domain with EMF, 2) definition of a metamodel for DocBook and support for parsing XML documents as EMF models, 3) definition of model transformations from 1) to 2). </p></aims>
  <challenges><p>The challenges of this project can be found in the following areas:<ul><li>model-driven development techniques: including parsers and code generation techniques</li><li>metamodelling techniques for defining modelling languages (metamodels) and models</li><li>use of the Eclipse Modeling Framework for developing software</li><li>use of model transformations</li><li>use of DocBook and XML parsing within EMF</li> </ul> </p></challenges>
  <learning-outcomes><p>The student will:<ul><li>carry out a detailed requirements analysis and specification of the problem.</li><li>produce an object-oriented design of a software system to implement</li><li>learn about model-driven development and metamodeling techniques</li><li>learn about Eclipse Modeling Framework and its application for model-driven software development</li> </ul> </p></learning-outcomes>
  <end-product><p>Prototype as described above. </p></end-product>
  <timetable></timetable>
  <references></references>
</project>
<project label="ea0b815c7f644f98199c5bb23ff6cbcf">
  <title>Model management - software integration</title>
  <supervisor>
    <ab373 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>A good understanding of OO-programming. </p></prerequisites>
  <profiles><SET/><SFS/><ASE/></profiles>
  <aims><p>Large software applications are usually specified in an incremental way by different independent teams. For instance, each team is in charge of analysing a different subset of use cases and designing the corresponding class diagram. To complete the specification of the system, the partial design specifications have to be merged. This task can be tedious due to the high number of details that are involved in a specification. However, there are many tasks that can be automated by exploiting the structure of the models (references, multiplicities, names, properties, ...). The aim of this project is to design and develop a tool to enhance software integration. </p></aims>
  <challenges><p>The challenges of this project can be found in the following areas:<ul><li>software evolution and change propagation</li><li>model-driven development techniques for defining software artifacts</li><li>model management techniques</li> </ul> </p></challenges>
  <learning-outcomes><p>Upon successful completion of the project, the student will be able to:<ul><li>use techniques for software evolution</li><li>manipulate the abstract structure of many software artifacts</li><li>differentiate between concrete syntax and abstract syntax of software artifacts</li><li>use model-driven development techniques for representing software artifacts</li><li>specify the requirements of an application, to design a system, to develop an application and to test it</li> </ul> </p></learning-outcomes>
  <end-product><p>Tool for discovering equivalences between software artifacts and for integrating them. </p></end-product>
  <timetable><ul><li>Study model-driven development techniques for representing software artifacts: metamodeling techniques, XML, Eclipse Modeling Framework/Microsoft DSL tools/Microsoft Oslo</li><li>Study techniques for model management</li><li>Specification, design and development of an initial prototype for integrating software artifacts</li><li>Development of a language for defining software integration.</li><li>Specification, design, development and testing of a complete (possibly graphical) environment for integrating software artifacts and to track manipulations.</li> </ul></timetable>
  <references><reference>
  <author>Artur Boronat, José A. Carsí, Isidro Ramos, Patricio Letelier</author>
  <volume>Formal Model Merging Applied to Class Diagram Integration. Electr. Notes Theor. Comput. Sci. 166</volume>
  <published year="2007"></published>
  </reference></references>
</project>
<project label="3d38720bee7dd2a1e4a3b901f53896d8">
  <title>Model patterns</title>
  <supervisor>
    <ab373 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>CO7207 and/or CO7217 </p></prerequisites>
  <profiles><SET/><ASE/></profiles>
  <aims><p>Model patterns are used to define graphical constraints over models that represent software artifacts. </p><p>The purpose of this project is to provide tool support for visualizing model patterns and for checking their satisfaction over models. </p></aims>
  <challenges><p>Assessment of how to define model constraints with models patterns. Develop an EMF plugin with support for model patterns. </p></challenges>
  <learning-outcomes><p>At the end of the project, the student should be able to: </p><ul><li>analyse existing software to extend it,</li><li>analyse, design and implement a computational problem,</li><li>define interoperability bridges between different technologies: Eclipse and other programming languages,</li><li>define model patterns for EMF-metamodels,</li><li>and develop Eclipse plug-ins.</li> </ul></learning-outcomes>
  <end-product><p>Eclipse plug-in with graphical support for defining model patterns, for compiling them into code and for checking their satisfaction. </p></end-product>
  <timetable><ul><li>Detailed list of requirements.</li><li>Prototyping of needed components.</li><li>Implementing the system.</li><li>Testing and case studies.</li><li>Documentation.</li> </ul></timetable>
  <references></references>
</project>
<project label="427844c84bc67d05bf73b039f64f0165">
  <title>OCL tool tester</title>
  <supervisor>
    <ab373 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Programming skills in Java. </p></prerequisites>
  <profiles><SET/><ASE/></profiles>
  <aims><p>"The Object Constraint Language (OCL) is a textual sublanguage of the Unified Modelling Language (UML). It can be used to express additional constraints on UML models that cannot be expressed, or are very difficult to express, with the graphical means provided by UML. OCL is based on first-order predicate logic but it uses a syntax similar to programming languages and closely related to the syntax of UML. It is, thus, more adequate for every-day modelling than pure first-order predicate logic." </p><p>The aim of this project consists in developing a tool for testing OCL expressions using different OCL interpreters, e.g., the OCL library for OCL in the Modeling project or MOMENT2 (see others in the OCL Portal). Therefore, the prototype should be flexible so that any other OCL engine can be plugged to it. The tool should be used for testing the relative correctness of different OCL interpreters, by executing the same expression in different interpreters at the same time. </p></aims>
  <challenges><ul><li>Assessment of how software engineering modelling languages are defined.</li><li>Application of the OCL language for defining model-based systems.</li><li>Combination of novel technologies and development of software in a methodological way.</li><li>Extensible design of the tool to reuse different OCL engines.</li> </ul></challenges>
  <learning-outcomes><p>At the end of the project, the student should be able to: </p><ul><li>analyse existing software to extend it,</li><li>analyse, design and implement a computational problem,</li><li>define modular and extensible software,</li><li>and develop Eclipse plug-ins.</li> </ul></learning-outcomes>
  <end-product><p>Eclipse plugin for testing OCL interpreters and for displaying results. </p></end-product>
  <timetable><ul><li>Study of tools that provide support for OCL and detailed list of requirements.</li><li>Prototyping of needed components.</li><li>Implementing the system.</li><li>Testing and case studies.</li><li>Documentation.</li> </ul></timetable>
  <references><reference>
  <author>Boronat, A</author>
  <published year="2008">MOMENT2: OCL and Maude</published>
  <note><a href="http://www.cs.le.ac.uk/people/aboronat/tools/moment2/">http://www.cs.le.ac.uk/~aboronat/tools/moment2/</a></note>
  </reference><reference>
  <author>OCL in Model Development Tools (MDT)</author>
  <note><a href="http://www.eclipse.org/modeling/mdt/?project=ocl">http://www.eclipse.org/modeling/mdt/?project=ocl</a></note>
  </reference><reference>
  <author>OCL Portal</author>
  <note><a href=" http://www-st.inf.tu-dresden.de/ocl/ ">http://www-st.inf.tu-dresden.de/ocl/</a></note>
  </reference></references>
</project>
<project label="fd574f6c357e5593fa55a223665032f8">
  <title>Visual Zoom over Software Application Code</title>
  <supervisor>
    <ab373 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>A good understanding of OO-programming. </p></prerequisites>
  <profiles><SET/><SFS/><ASE/></profiles>
  <aims><p>Software artifacts in industrial applications can consist of thousands of code files. To enhance software maintenance of such applications techniques to abstract essential information from code are crucial. The aim of the project is to define a graphical visualizer for representing java or c# code files (classes) and their relationships (references between classes). Zoom facilities should be provided in order to hide/add information: encapsulate clusters of highly cohesive classes (classes with many references among them), isolated nodes, etc. </p><p>Either .NET or java technology can be used. </p></aims>
  <challenges><p>The challenges of this project can be found in the following areas:<ul><li>graphical representation techniques</li><li>program parsers</li><li>program representation</li><li>algorithm for zooming</li> </ul> </p></challenges>
  <learning-outcomes><p>The student will:<ul><li>carry out a detailed requirements analysis and specification of the problem.</li><li>produce an objected-oriented design of a software system to implement</li><li>learn about human computer interaction</li><li>learn about visual representation techniques</li> </ul> </p></learning-outcomes>
  <end-product><p>A graphical editor for representing programs with zoom facilities </p></end-product>
  <timetable><ul><li>Explore graphical techniques based on .NET or java</li><li>Explore techniques for representing programs: parsers, regular expressions</li><li>Specification, design, implementation and testing of a first prototype</li><li>Explore techniques for zooming</li><li>Define algorithm for zooming: decide which information to show/hide</li><li>Complete specification, design, implementation and testing of the prototype</li> </ul></timetable>
  <references></references>
</project>
<project label="8e1b773fd48cbf5162f134d6d4770c47">
  <title>Visual Zoom over Software Models</title>
  <supervisor>
    <ab373 />
  </supervisor>
  <hidden>proposed 08/09</hidden>
  <prerequisites><p>A good understanding of OO-programming. </p></prerequisites>
  <profiles><SET/><SFS/><ASE/></profiles>
  <aims><p>Software artifacts in industrial applications can consist of thousands of code files. To enhance software maintenance of such applications techniques to abstract essential information from code are crucial. Model-driven development techniques enable the representation of code as models (collections of objects) from which code is generated. The aim of the project is to define a graphical visualizer for representing models as object diagrams (objects and links) that provides techniques for hiding/adding information at different levels of granularity: to show clusters of objects with similar properties (instances of the same class), clusters of highly cohesive objects (with many links among them), etc. </p></aims>
  <challenges><p>The challenges of this project can be found in the following areas:<ul><li>graphical representation techniques</li><li>model-driven development techniques: including parsers and code generation techniques</li><li>metamodelling techniques for defining modelling languages (metamodels) and models</li><li>develop an application that enables the representation of models (either for a specific modeling language, such as class diagrams, or generically)</li><li>learn Eclipse Modeling Framework</li> </ul> </p></challenges>
  <learning-outcomes><p>The student will:<ul><li>carry out a detailed requirements analysis and specification of the problem.</li><li>produce an object-oriented design of a software system to implement</li><li>learn about model-driven development and metamodeling techniques</li><li>learn about visual representation techniques</li><li>learn about Eclipse Modeling Framework and its application for model-driven software development</li> </ul> </p></learning-outcomes>
  <end-product><p>A graphical editor for representing models with zoom facilities </p></end-product>
  <timetable><ul><li>Learn the basic notion of model-driven development: model, metamodel, Eclipse Modeling Framework</li><li>Explore techniques for graphical representation of graphs</li><li>Specification, design, implementation and testing of a first prototype</li><li>Explore clustering techniques based on graphs</li><li>Define algorithm for zooming: decide which information to show/hide</li><li>Complete specification, design, implementation and testing of the prototype</li> </ul></timetable>
  <references></references>
</project>
<project label="e9147bb5184eb5c05cf34c487cf8ee07">
  <title>Visual representation of software bugs</title>
  <supervisor>
    <ab373 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>A good understanding of OO-programming. Background in model checking is required. </p></prerequisites>
  <profiles><SET/><ADS/><ASE/></profiles>
  <aims><p>Software artifacts in industrial applications can consist of thousands of code files. To enhance software maintenance of such applications techniques to abstract essential information from code are crucial. Model-driven development techniques enable the representation of code as models (collections of objects) from which code is generated. </p><p><b><a href="http://www.cs.le.ac.uk/people/aboronat/tools/moment2-gt/">MOMENT2</a></b>is a model transformation tool that enhances the behavioral specification of model-based systems with in-place model transformations. In this case, a model based system is consists of a metamodel (structural view of the system), an in-place model transformation (dynamic view of the system) and an input model (initial state). MOMENT2 provides a model checker to verify such specifications by defining properties to be verified with model patterns. The model checker indicates whether the system satisfies a property or not. When a property is not satisfied, the model checker provides a counterexample indicating where the problem is. However, this counterexample is usually produced in a non-user-friendly way, using the concrete syntax of the model checker, which is usually textual. </p><p>The aim of this project is to build a graphical visualizer for model checker counterexamples that helps in verifying model transformations. The steps to be followed are: (1) understand what is model checking and how it works in MOMENT2, (2) study technology for parsing counterexamples  and for building models that represent those counterexamples (EMF), (3) define a user-friendly interface to explore counterexamples. </p></aims>
  <challenges><p>The challenges of this project can be found in the following areas:<ul><li>graphical representation techniques</li><li>model-driven development techniques: including parsers and code generation techniques</li><li>metamodelling techniques for defining modelling languages (metamodels) and models</li><li>application of model checking techniques</li> </ul> </p></challenges>
  <learning-outcomes><p>The student will:<ul><li>carry out a detailed requirements analysis and specification of the problem.</li><li>produce an object-oriented design of a software system to implement</li><li>learn about model-driven development with the Eclipse Modeling Framework</li><li>learn about visual representation techniques</li><li>learn about the application of model checking techniques</li> </ul> </p></learning-outcomes>
  <end-product><p>A prototype as described above. </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="c05da67771bceedad2e505c81d7f76e7">
  <title>Web interface for a model transformation engine</title>
  <supervisor>
    <ab373 />
  </supervisor>
  <hidden>proposed 08/09</hidden>
  <prerequisites><p>Background in web technologies and Java. </p></prerequisites>
  <profiles><SET/><WAS/><ADS/><ASE/></profiles>
  <aims><p>Develop a web interface for the MOMENT2 model transformation engine so that OCL queries and demo transformations can be executed online. </p></aims>
  <challenges><ul><li>Analysis of different approaches/technologies for developing web based systems.</li><li>Understanding model transformations and providing new mechanisms to enhance their presentation through a web page.</li><li>Combination of novel technologies and development of software in a methodological way.</li> </ul></challenges>
  <learning-outcomes><p>At the end of the project, the student should be able to: </p><ul><li>analyse several approaches for graphically representing model transformations,</li><li>analyse, design and implement a computational problem,</li><li>propose new features related to the prototype,</li><li>synthesize information and present it in the form of a dissertation,</li><li>and develop a web page that uses an Eclipse plugin.</li> </ul></learning-outcomes>
  <end-product><p>Web page for interacting with MOMENT2. </p></end-product>
  <timetable><ul><li>Detailed list of requirements.</li><li>Prototyping of needed components.</li><li>Implementing the system.</li><li>Testing and case studies.</li><li>Documentation.</li> </ul></timetable>
  <references><reference>
  <author>EMF</author>
  <published year="2009">Eclipse Modeling Framework</published>
  <note><a href="http://www.eclipse.org/emf">http://www.eclipse.org/emf</a></note>
  </reference><reference>
  <author>Boronat, A</author>
  <published year="2008">MOMENT2: model transformations with EMF and Maude</published>
  <note><a href="http://www.cs.le.ac.uk/people/aboronat/tools/moment2/">http://www.cs.le.ac.uk/~aboronat/tools/moment2/</a></note>
  </reference></references>
</project>
<project label="919e24f7cec4b6f48fd8ff51e3bcd4ad">
  <title>iModels</title>
  <supervisor>
    <ab373 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>CO7207 and or CO7217 </p></prerequisites>
  <profiles><SET/><WAS/><ADS/><ASE/></profiles>
  <aims><p>Model-driven engineeringis a successor paradigm of object-oriented programming, where models are collections of objects that represent software artifacts, such as java programs, relational schemas in databases, UML models (class diagrams, activity diagrams...), etc. Models play a crucial role in a software development process since they are used to design the requirements of an application enhancing automatic code generation, increasing productivity and reducing costs. </p><p>The aim of this project is to develop an iTunes-like repository of models with facilities for persistency and distributed queries. </p></aims>
  <challenges><p>Critical assessment of the use of EMF and CDO, and development of an Eclipse plugin.</p></challenges>
  <learning-outcomes><p>At the end of the project, the student should be able to: </p><ul><li>analyse existing software to extend it,</li><li>analyse, design and implement a computational problem,</li><li>apply distributed computing notions</li><li>and develop Eclipse plug-ins.</li> </ul></learning-outcomes>
  <end-product><p>Eclipse plugin as described above. </p></end-product>
  <timetable><p><ul><li>Experiment with CDO and EMF.</li><li>Requirements specification: storage and queries</li><li>Design of the repository and of the software architecture and support for distributed queries</li><li>Implementation and testing</li> </ul> </p></timetable>
  <references></references>
</project>
<project label="2084863fe30a3c9cd85a8cb5a5a204cc">
  <title>Advanced Model Checking</title>
  <supervisor>
    <ak155 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>a very good understanding of CO7209 </p></prerequisites>
  <profiles><ACM/><ADS/><ASE/></profiles>
  <aims><p>Various projects are possible here, extending what was taught in CO7209: mu-calculus, omega-automata, alternating automata, coalgebra-automata, etc </p></aims>
  <challenges><p>read and understand research level papers; implement sophisticated algorithms </p></challenges>
  <learning-outcomes><p>understanding of a state of the art research topic </p></learning-outcomes>
  <end-product><p>a model checker </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references></references>
</project>
<project label="e8db1d6789446a4326998444fa3fa500">
  <title>Comparing tableaux and automata based model checking</title>
  <supervisor>
    <ak155 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>a very good understanding of co7209 </p></prerequisites>
  <profiles><ACM/><ADS/><ASE/></profiles>
  <aims><p>both tableau based and automata based model checking build on the same ideas. In this theoretical project, the task is to compare the two approaches. </p></aims>
  <challenges><p>To understand advanced concepts of model checking. </p></challenges>
  <learning-outcomes><p>To explain the differences and similarities between tableau based and automata based model checking </p></learning-outcomes>
  <end-product><p>report (theoretical project) </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="abc9d31b6b84bf586ecc94ebf526311b">
  <title>Computer Chess Player</title>
  <supervisor>
    <ak155 />
  </supervisor>
  <hidden>hide</hidden>
  <prerequisites><p>The student needs to be able to write a recursive depth-first search in a tree, as taught in most computer science BSc degrees. </p></prerequisites>
  <profiles><ACM/><ADS/><ASE/></profiles>
  <aims><p>In the first stage, a simple gui plus a standard alpha/beta depth first search, plus a simple heuristic. Let the program play on an internet chess server (Fischer Random to be independent of opening libraries) to acquire a rating and measure its strength. If time permits, implement various improvements of this basic program, eg better heurstics, optimised implementations, etc. </p></aims>
  <challenges><p>Good programming skill are required, but the basic program should be reasonably standard. The challenges are then in measuring its strength and improving it. </p></challenges>
  <learning-outcomes><p>Improving programming skills; learning some advanced AI techniques. </p></learning-outcomes>
  <end-product><p>Computer Chess Player </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="e00d8f4351a4603f7ea32cd117e39af8">
  <title>Computer Go Player</title>
  <supervisor>
    <ak155 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p> The student needs to be able to write a recursive depth-first search in a tree, as taught in most computer science BSc degrees. </p></prerequisites>
  <profiles><ACM/><ADS/><ASE/></profiles>
  <aims><p> Go is one of the most fascinating board games. It has very simple rules, but no strong computer player on the standard 19x19 board exists. On the other hand, computers are now fast enough to play well on 9x9 board. The aim is to implement a computer go player on a 9x9 board.</p></aims>
  <challenges><p> Good programming skill are required, but the basic program should be reasonably standard. The challenges are then in measuring its strength and improving it.</p></challenges>
  <learning-outcomes><p>Improving programming skills; learning some advanced AI techniques.  </p></learning-outcomes>
  <end-product><p> Computer Go Player </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="80a44bcdcb874fc7b3a24d0dfe3e2373">
  <title>Depth First Search Algorithms and Model Checking</title>
  <supervisor>
    <ak155 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p> a very good understanding of CO7209 </p></prerequisites>
  <profiles><ACM/><ADS/><ASE/></profiles>
  <aims><p>In a famous 1972 paper (Siam Journal on Computing, 1:146-160), Robert Tarjan described several algorithms based on a simple depth first traversal of a graph. For example, he gives a linear time algorithm to discover all strongly connected components of a graph. This algorithm is crucial, for example, to some state-of-the-art model checking techniques. The aims of the project include </p><p><ol><li>Understand and explain (some of) the algorithms of the original paper.</li><li>Implement (some or one of) the algorithms.</li><li>Apply (some or one of) the algorithms to model checking.</li></ol> </p></aims>
  <challenges><p>Understanding and implementing sophisticated algorithms and applying them to model checking. </p></challenges>
  <learning-outcomes><p>Understanding of an important class of advanced algorithms. Understanding of an application area. Improved programming skills. </p></learning-outcomes>
  <end-product><p>LTL Model Checker based on Tarjans algorithm </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author>R. Tarjan</author>
  <volume>Siam Journal on Computing, 1:146-160, 1972</volume>
  <published year="1972"></published>
  <note></note>
  </reference></references>
</project>
<project label="f3d9e3829a9ec9b43045cf532361e494">
  <title>Didactic Model Checker</title>
  <supervisor>
    <ak155 />
  </supervisor>
  <hidden>hide</hidden>
  <prerequisites><p>a very good understanding of CO7209 </p></prerequisites>
  <profiles><ACM/><ADS/><ASE/></profiles>
  <aims><p>To write a little LTL model checker not optimised towards efficiency but for teaching purposes, essentially implementing the algorithm from the lecture </p></aims>
  <challenges><p>To implement an LTL model checker; moreover, the user should be able to follow the computation of little examples in order to learn how the model checking algorithm works. </p></challenges>
  <learning-outcomes><p>a model checker with a user interface that allows to trace computations and to see how a formula is evaluated wrt a model; user-friendlyness is important </p></learning-outcomes>
  <end-product><p>a model checker with a user interface that allows to trace computations and to see how a formula is evaluated wrt a model; user-friendlyness is important </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references></references>
</project>
<project label="9e28fa3793f7c3bcc3302e482ee3eb60">
  <title>Linear graded temporal logic</title>
  <supervisor>
    <ak155 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>CO7209 </p></prerequisites>
  <profiles><ACM/><ADS/><ASE/></profiles>
  <aims><p>Weighted transition systems have transitions which have a weight associated. The weight can encode information such as costs, time, probability. Logics for such systems are often called graded modal logics. The aim of the project is to extend (some of) the model checking techniques learned in CO7209 to this setting. </p></aims>
  <challenges><p>This project is not following well-established lines and requires a student who has the energy and ability to research level work. </p></challenges>
  <learning-outcomes><p>Deeper understanding of model checking and weighted transition systems. </p></learning-outcomes>
  <end-product><p>This can be a theoretical project, but some implementation would be expected as well. </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="d37ca3894af90a5296655f6e00dc6749">
  <title>OpenStreetMap</title>
  <supervisor>
    <ak155 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Good programming skills, own initiative in defining the particular objectives</p></prerequisites>
  <profiles><ACM/><ADS/><ASE/></profiles>
  <aims><p> OpenStreetMap is an open source project mapping the world, much like GoogleMaps, but open for everybody to modify and add features. So there is a wide range of possible projects.  </p></aims>
  <challenges><p> One of the challenges is to get to grips with the huge data sets provided by OpenStreetMap, to understand the format, and to extract useful information. Other challenges will depend on the particular objectives.</p></challenges>
  <learning-outcomes><p> This project could be an entry point into the interesting world of geographical information systems. Specific learning outcomes will depend on the specific objectives chosen by the student after consultation with the supervisor.</p></learning-outcomes>
  <end-product><p> </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <note>http://www.openstreetmap.org/
  </note>
  </reference>
  
  <reference>
  <note>http://en.wikipedia.org/wiki/Geographic_information_system</note>
  </reference>
  
  </references>
</project>
<project label="0be8a7e96068b7085414cde3c3174122">
  <title>Planning as model checking</title>
  <supervisor>
    <ak155 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>a very good understanding CO7209; this project requires to study some research literature and to develop own ideas </p></prerequisites>
  <profiles><ACM/><ADS/><ASE/></profiles>
  <aims><p>Planning as model checking is a very exciting and active research area. The basic idea is that finding a plan is the same kind of problem as finding a counterexample to a temporal property. Thus existing techniques from model checking can be harnessed to solve state of the art problems concerning planning. The aim of the project can be either more theoretical or more towards implementing a prototype. </p></aims>
  <challenges><p>To understand reserach level literature. </p></challenges>
  <learning-outcomes><p>Being able to explain plannnig as model checking. </p></learning-outcomes>
  <end-product><p>report (theoretical project) or prototype (technical project) </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author>Piergiorgio Bertoli, Marco Pistore and Marco Roveri</author>
  <volume></volume>
  <published year="2002"></published>
  <note>http://sra.itc.it/tools/mbp/AIPS02-tutorial.html</note>
  </reference></references>
</project>
<project label="221f698f1dbdd0a84194f096333e12af">
  <title>Probability Latent Semantic Analysis and Internet Content Filter</title>
  <supervisor>
    <ak155 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>some mathematical ability </p></prerequisites>
  <profiles><SET/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>There are two main aims in the project: 1. To understand the Probability Latent Semantic Analysis algorithm and implement it. 2. To implement this algorithm so that it can be run on personal computer, and could be used to apply in information filtering software for children protection. </p></aims>
  <challenges><p>understand research level papers, implement cutting edge algorithm </p></challenges>
  <learning-outcomes><p>understand important issues about information filtering in general and latent semantic analysis in particular </p></learning-outcomes>
  <end-product><p>program performing information filtering </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author>Brants, T. 2005: Test Data Likelihood for PLSA Model. Information Retrieval, Volume 8, Springer Science + Business Media, Inc. Manufactured in The Netherlands, PP. 181–196. http://www.springerlink.com/content/g712172841664640</author>
  </reference><reference>
  <author>Hofmann, T.: Latent Semantic Variable Models, Fraunhofer Institute for Integrated Publication &amp;amp; Information Systems (IPSI) Intelligent Systems Group, Technical University of Darmstadt, Germany http://videolectures.net/slsfs05_hofmann_lsvm/</author>
  </reference></references>
</project>
<project label="d4a0c2d0acdf66d3dc5611c7b6574ef0">
  <title>automata theory and model checking</title>
  <supervisor>
    <ak155 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>a very good understanding of CO7209 </p></prerequisites>
  <profiles><SET/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>Buechi automata are finite automata that accept infinite words. Hence such an automata can be understood as formula in LTL. The aims of the project are to understand the relation ship between Buechi automata and LTL formulas and to write a program that translates formulas into automata. </p></aims>
  <challenges><p>Understand the relation ship between Buechi automata and LTL formulas and to write a program that translates formulas into automata. </p></challenges>
  <learning-outcomes><p>Understand the relation ship between Buechi automata and LTL formulas and to write a program that translates formulas into automata. </p></learning-outcomes>
  <end-product><p>A report explaining the relationship between Buechi automata and LTL formulas and a program that translates formulas into automata. </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="ce833e8953ac638ba235b6aa2f596cb3">
  <title>A Graphical Application to Test Distributed Transactions</title>
  <supervisor>
    <et52 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p><ul><li>Good Programming skills</li><li>CO7090 or equivalent</li><li>Good analytical skills</li> </ul> </p></prerequisites>
  <profiles><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>The aim of the project is to develop a graphical tool for the representation of the transactional mechanisms of Enterprise Java Beans. A simplified language will be provided to the student that captures the basic aspects of processes which include transactions. The developed tool will allow to graphically edit transactions and to visualise the execution steps. </p></aims>
  <challenges><p>The challenges of this project can be found in the following areas:<ul><li>understanding the transaction mechanism to be modelled (a simple graphical notation will be provided to the student to represent transactional processes),</li><li>development of the tool,</li><li>design of a suitable graphical notation.</li> </ul> </p></challenges>
  <learning-outcomes><p>The student will:<ul><li>understand the mechanisms of transaction management of EJB</li><li>familiarise with the key issues of concurrency / distribution / transactions</li><li>practice in programming graphical interfaces</li> </ul> </p></learning-outcomes>
  <end-product><p>A graphical tool that allows editing and the representation of computation steps. </p></end-product>
  <timetable><p>Study of the language to model </p><p>Development of a graphical representation for transactions </p><p>Tool development </p></timetable>
  <references></references>
</project>
<project label="016afe159905cb52cab0a99bc4bd2619">
  <title>A Graphical Editor for Architectural Analysis Design</title>
  <supervisor>
    <et52 />
  </supervisor>
  <hidden>taken by Kyriakos Poyias</hidden>
  <prerequisites><p><ul><li>Good Programmin/analytical skills</li><li>CO7090 and/or CO7099 or equivalent</li></ul> </p></prerequisites>
  <profiles><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p> </p></aims>
  <challenges><p> </p></challenges>
  <learning-outcomes><p> </p></learning-outcomes>
  <end-product><p> </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="dd717360d5808cfddb6cff2a4df5eead">
  <title>A Graphical Notation and Editor for Service Choreographies</title>
  <supervisor>
    <et52 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p><ul><li>Good Programmin/analytical skills</li><li>CO7090 and/or CO7099 or equivalent</li><li>Familiarity UML modelling.</li></ul> </p>
  </prerequisites>
  <profiles><SET/><WAS/><ADS/><ASE/></profiles>
  <aims><p>The aim of the project is to develop a simple graphical notation, which possibly extends UML sequence diagrams, for editing and designing protocols involving multiple participants, where each interaction is annotated with a constraints. </p></aims>
  <challenges><p>This project presents challenging design aspects and the issue of implementing the graphical editor. </p></challenges>
  <learning-outcomes><p>The student will learn how to design multiparty distributed protocols (e.g., choreographies of web services) and make practice in interface programming </p></learning-outcomes>
  <end-product><p>A graphical notation and a tool for editing protocols. </p></end-product>
  <timetable><p>Documentation on Choreographies. Design. Prototyping. Selection of test cases. Implementation. </p></timetable>
  <references></references>
</project>
<project label="2d42ebcb6512f801d4b6aad142c9cba6">
  <title>A tool for animating security protocols</title>
  <supervisor>
    <et52 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>CO7099. Good programming skills. </p></prerequisites>
  <profiles><SET/><SFS/><WAS/><ADS/><ASE/></profiles>
  <aims><p>The aim of this project is to provide a java application that allows to represent protocol narration and animate the behaviour of security protocols according to the Dolev-Yao model. </p></aims>
  <challenges><p>This project presents challenging design aspects and the issue of implementing the abstract Dolev-Yao model. </p></challenges>
  <learning-outcomes><p>The student will learn how theoretical models help in the effective analysis of security protocols. </p></learning-outcomes>
  <end-product><p>A tool that can represent security protocols and 'execute' them. </p></end-product>
  <timetable><p>Requirements. Design. Prototyping. Selection of test cases. Implementation. </p></timetable>
  <references><reference>
  <author>E. Tuosto</author>
  <volume>CO7099 handouts</volume>
  <note>Available on request</note>
  </reference></references>
</project>
<project label="e86794e163f654eb7c09d7335b0302f8">
  <title>Channel based communication in MOMs</title>
  <supervisor>
    <et52 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>CO7090 or familiarity with concurrent and distributed programming; good programming/designing skills. </p></prerequisites>
  <profiles><SFS/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>This project is an experiment for comparing two different coordination mechanisms both used in distributed programming, namely channel-based and message-oriented communications. </p></aims>
  <challenges><p>This is a rather challenging project aiming at selecting a few channel-based communication primitives and implementing them using a message oriented middleware (eg a JMS implementation). </p></challenges>
  <learning-outcomes><p>Insights in principles of distributed middlewares. Acquisition of a critical understanding of channel-based communications and message oriented middlewares. </p></learning-outcomes>
  <end-product><p>The final product will be a library of primitives featuring channel-based communication. </p></end-product>
  <timetable><p>Selection of channel-based primitives. Precise specification of their semantics. Selection of a suitable MoM. Implementation of the library. </p></timetable>
  <references><reference>
  <author>E. Tuosto</author>
  <volume>CO7090 handouts</volume>
  <note>Available on request</note>
  </reference></references>
</project>
<project label="3099f4fbbdafd8275ec68f8366f389e4">
  <title>Comparing Transaction Managers</title>
  <supervisor>
    <et52 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>CO7090. Good analytical skills. Good programming skills are also desirable though not mandatory. </p></prerequisites>
  <profiles><SET/><SFS/><WAS/><ADS/><ASE/></profiles>
  <aims><p>This project aims at studying middlewares supporting distributed transactions. In particular, the project consists in evaluating how the X/Open DTP Model has been interpreted in the JTA. Depending on the students interests the project may consider other transaction managers and / or experimenting in suitable scenarios. </p></aims>
  <challenges><p>The challenges of this project are to understand, critically compare, and experiment a number of transactional managers currently available. </p></challenges>
  <learning-outcomes><p>A deep understanding of distributed transactions, their implementation issues, their adequacy with respect to transaction managers. </p></learning-outcomes>
  <end-product><p>This project will produce a thorough analysis of some transactional managers. The main contribution would be the definition of some assessment criteria (and possibly experiments) that support the analysis. </p></end-product>
  <timetable><p>Study of the X/open model. Selection of transactional managers to study. Definition of the assessment criteria. Comparison of the managers supported by experiments. </p></timetable>
  <references><reference>
  <author>E. Tuosto</author>
  <volume>CO7090 handouts</volume>
  <note>Available on request</note>
  </reference><reference>
  <author>.</author>
  <volume>http://docs.openlinksw.com/mt/xamt.html</volume>
  </reference></references>
</project>
<project label="6689021e6bb8046e767d19bf17502a92">
  <title>Gossip protocols</title>
  <supervisor>
    <et52 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Familiarity with concurrent and communicating systems; good programming/designing skills. </p></prerequisites>
  <profiles><SET/><ACM/><ADS/><ASE/></profiles>
  <aims><p><i>Gossip</i>(or<i>epidemic</i>) protocols are rather interesting communication protocols that are recently gaining momentum for their importance in distributed systems using point-to-point communication in general (and in P2P systems in particular). A gossip protocol:<ul><li>is based on periodic, pairwise, inter-process interactions</li><li>requires that each interaction between two processes triggers a state-change in at least one of them</li><li>does not consider "pings" as interactions</li><li>does not assume reliable communication</li><li>usesinteractions rarely compared to typical message latencies</li><li>relies on some randomness in peer selection</li> </ul> </p><p>Depending on your course and interests, the project may aim to<ul><li>compare/analyse gossip protocols</li><li>implement a framework for simulating gossip protocols</li><li>analyse the computational cost of gossip protocols</li><li>modelling gossip protocols</li> </ul> </p></aims>
  <challenges>Challenges vary on the following set<p><ul><li>understand the principles of gossip protocols</li><li>adapt existing designing/implementation/analysis techiques to gossip protocols</li> </ul> </p></challenges>
  <learning-outcomes><p>You'll acquire knowledge on distributed system in general and P2P networks in particular. Also, you'll learn basics of distributed algorithms (like gossip protocols). </p></learning-outcomes>
  <end-product><p>This project can be given different flavor and will be tuned to the interests of the students. The end-product may be either a simulation framework, a theoretical study on the efficiency of a (class of) gossip protocols, or an analytical study conducted by using existing tools. </p></end-product>
  <timetable><p>Not applicable </p></timetable>
  <references><reference>
  <author>Patrick T. Eugster</author>
  <author>Rachid Guerraoui</author>
  <author>Anne-Marie Kermarrec</author>
  <author>Laurent Massoulieacute</author>
  <volume>37(5)</volume>
  <published year="2004">IEEE Computer</published>
  <note>pp. 60-67</note>
  </reference><reference>
  <author>Andrew S. Tanenbaum</author>
  <author>Maarten Van Steen</author>
  <published year="2nd edition">Distributed Systems: Principles and Paradigms</published>
  <note>pp. 170-174</note>
  </reference></references>
</project>
<project label="035de9d01e9286b3c2ed2846a8999173">
  <title>Graphical Manipulation of Data</title>
  <supervisor>
    <et52 />
  </supervisor>
  <hidden>hidden</hidden>
  <prerequisites><p>The project will use the following technologies and skills: Microsoft Windows operating systems (XP / Vista / 2003); Microsoft SQL Server; Microsoft Visual Studio (ASP.Net and VB.Net); Microsoft Internet Information Services (IIS); HTML. </p></prerequisites>
  <profiles><ACM/><ADS/><ASE/></profiles>
  <aims><p>This project is done in collaboration with<a href="http://www.carneyjones.co.uk/">Carney Jones Ltd.</a>, a recruitment agency that supplies staff across a variety of business disciplines and work with a wide range of market sectors for companies ranging from major PLC's to small firms.The project consists in the definition and development of a software system that automatically extract data from the a set of databases distributed in multiple offices and locations. The main functionality that the software has to provide is to collect and graphically present various sources of data. The purpose is to extract (relevant) information for monitoring the performance of staff at the agency in a way that helps consultant from Carney Jones Ltd. to take decisions and improve the overall efficiency of the company.Two important requirements of the system are usability and simplicity as the users will not necessarily be highly I.T. literate (also, the activity of gathering statistics is typically perceived as a tiresome task).More preciesely,<ol><li>data must be represented in very easy to understand graphical interfaces</li><li>data must be very flexible and adaptable</li></ol>The overall goal is to highlight possible needs of training and/or re-structure by comparing information of activity data among consultants, offices and departments.The importance of gathering data from any company is vital for analyzing information to facilitate ways to improve business processes and pinpoint which individuals and departments require training. Approaches such as<a href="http://en.wikipedia.org/wiki/Business_process_reengineering">Business Process Re-Engineering</a>(BPR) and<a href="http://en.wikipedia.org/wiki/Training_needs_analysis">Training Needs Analysis</a>(TNA) are used to identify and disentangle business processes and identify areas for skill improvement. These can be time consuming and costly processes for any organisation, especially if using external consultants, both BPR and TNA use large amounts of data drawn from organisations. An example may help to have an idea of the type of scenario in which the software to be developed in this project may help.There are 3 offices of a recruitment company, each supplying aerospace personnel to their clients from 3 separate locations. Each office has 4 consultants working within it. Office A Places individuals into 10 vacant positions per month, additionally finding new business through sales activity of 10 positions. The profit from this office is 50,000 GBP per annum. Office B Places 5 individuals per month, additionally finding new business through sales activity of 5 positions. The profit from this office is 150,000 GBP per annum. Office C Places 25 individuals per month, additionally finding new business through sales activity of 25 positions. The profit from this office is 5,000 GBP per annum.The decisions to be taken correspond to answer typical questions like:<ol><li>Why does office B make 3 times as much profit when filling half the positions and doing half the sales of office A?</li><li>Why is the profit of office C so much lower than A and B when they have far more filled vacancies and higher sales activity?</li><li>Is there a reason to keep office C open?</li></ol> </p></aims>
  <challenges><p>This project requires a rather high inventiveness. The student will liaise with real stakeholders and has to find good graphical representations for data as well as resolve many technical challenges (as dealing with many different data formats, distributed DBs / filesystems, etc.). </p></challenges>
  <learning-outcomes><p>At the end of the project, the student should be able to analyse, design and implement a computational problem; moreover, the student will acquire the ability of developing an application for a real user. </p></learning-outcomes>
  <end-product><p>A software to support decision making </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author>Carney Jones Ltd.</author>
  <volume>CV and Document Management Software (2008). Preliminary requirements document</volume>
  <published year="1901"></published>
  <note>https://campus.cs.le.ac.uk/teaching/resources/CO7201/uploads/carney-jones.pdf</note>
  </reference></references>
</project>
<project label="b685ef6b78f0225f0b535e3a7ccf755d">
  <title>Implementing a simple graph rewriting mechanism</title>
  <supervisor>
    <et52 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Good programming skills and good mathematical skills. Knowledge of topics dealt with in CO7007 and CO7090 are desirable. </p></prerequisites>
  <profiles><SET/><ADS/><ASE/></profiles>
  <aims><p>The goal of the project is to develop a prototype environment for programming and executing a graph rewriting based language called Synchronised Hyperedge Replacement (SHR) </p></aims>
  <challenges><p>The flavour of this project is mainly theoretical. Implement a mathematical formalism: the main challenge is not on the complexity of the software architecture, rather on the ability in understanding (SHR) and implementing it efficiently. </p></challenges>
  <learning-outcomes><p>Learn a formal language, efficient implementation of an execution engine, refine research skills.You'll depeen your knowledge on distributed system. </p></learning-outcomes>
  <end-product><p>A software prototype. </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author>I. Lanese, E. Tuosto. "Synchronized Hyperedge Replacement for Heterogeneous Systems"</author>
  <volume>3454</volume>
  <published year="2005">LNCS</published>
  <note>COORDINATION 2005</note>
  </reference></references>
</project>
<project label="4604a0599b10ab4a3b2cecc47d44549c">
  <title>Implementing a small language for SOC</title>
  <supervisor>
    <et52 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Good programming skills and good mathematical skills. Knowledge of topics dealt with in CO7007 and CO7090 are desirable. </p></prerequisites>
  <profiles><SET/><ADS/><ASE/></profiles>
  <aims><p>The goal of the project is to develop a prototype environment for programming and executing a small programming language called Muse tailored for expressing service oriented computations. </p></aims>
  <challenges><p>The flavour of this project is mainly theoretical but also involves practical aspects of SOC. Implement a mathematical formalism: the main challenge is not on the complexity of the software architecture, rather on the ability in understanding Muse and implementing. </p></challenges>
  <learning-outcomes><p>Basics of operational semantics of languages, implementation of research-driven languages, refine research skills.You'll deepen your knowledge on distributed system in general and, depending on your interests, on P2P networks in particular. Basics of language implementation. </p></learning-outcomes>
  <end-product><p>The nature of the end-product is a piece of software that, though not expected to be vast, is challenging to design and implement. </p></end-product>
  <timetable><p>Understanding the SOC concepts featured by Muse. Study of Muse syntax. Study of Muse semantics. Choice of the implementation language. Implement an interpreter for Muse. </p></timetable>
  <references><reference>
  <author>R. Bruni, I. Lanese, H. Melgratti and E. Tuosto. "Multiparty Sessions in SOC"</author>
  <volume>5052</volume>
  <published year="2008">LNCS</published>
  <note>COORDINATION 2008</note>
  </reference></references>
</project>
<project label="f73cfef4593150909973711c027ecd22">
  <title>Matching of applicants against Vacancies</title>
  <supervisor>
    <et52 />
  </supervisor>
  <hidden>hidden</hidden>
  <prerequisites><p> </p></prerequisites>
  <profiles><SET/><ACM/><ADS/><ASE/></profiles>
  <aims><p>A recruitment agency like Carney Jones Ltd receives circa 100 applications per job vacancy, of which only one individual may be successful in obtaining the position. This leaves 99 applicants, and therefore CV's, who although not suitable for the original positions are in general highly skilled individual's actively seeking work. Our database currently contains thousands of company / client details but little information on the technical capability of our clients. </p><p>A new system designed and developed recently by another MSc project, requires modifications to contain a client information page which can be populated by text directly input by a user, copied and pasted from a company's website or downloaded from a company brochure. This page needs to be 'Organic' and will develop over time as more information is input by consultants to cover the technical abilities of a company and its subsidiary companies. Once this page has been populated it will contain lists of words that need to be cross referenced against CV's of individuals that have applied to. The aim is to find the most suitable client to which an applicant can apply. </p><p>A simple example: </p><p>An applicant applies for a telecommunications position with BT who has asked Carney Jones Ltd to look for a suitably qualified Network Design Engineer. An applicant applies but is not successful as his/her skills are primarily in the marine and subsea / oil and gas telecommunications field. We would ideally like to choose / highlight key skills from the CV which would then search our database of clients and provide a top 10 list of suitable clients such as BP, Shell, Tyco Marine Networks etc. the applicant can apply to as information matching key words on the company is also on the applicants CV. </p><p>For example,the applicant CV mentions Design and Plan the fibre connectivity between UK and Isle of Man via Submarine cable using Alcatel DWDM, SDH products. Design and Plan the national networks for Isle of Man, use of Alcatel and Marconi DWDM, SDH products. </p><p>Another client, Tyco Telecom Undersea System Supply has the following on their web page: As a vertically-integrated supplier of undersea communications systems and services, we are able to leverage our ... Tyco Telecommunications Laboratories continues to make great strides in providing our customers with new products which form the underpinning of the system equipment. Coupled with terrestrial network equipment such as Network Protection Equipment, Routers, ATM, SDH Multiplexers, terrestrial transceivers, etc. from a variety of suppliers, our engineers ... SDH &amp; PDH Networks ... Sub-Marine cabling to multiple off shore projects . . . </p><p>This would ideally highlight to a consultant the possible match in skill to company requirements and lead to calling the company asking if thet have a vacancy, the matching words obviously being Sub-Marine cable and SDH. The software needs to be very flexible and have the ability to screen multiple CV's, groups of CV's, selected keywords or sections of CV's. Additionally the CV's need to be cross referenced with past vacancies that Carney Jones Clients has tried to fill as this historical data is a good bank of clients skill requirements. </p><p>Optional extra - vacancy pages from companies not on the Carney Jones Database can be highlighted to the software. These pages can be used to populate a 'skill' database of companies that are potential clients of Carney Jones Ltd but have requirements within a similar field. This would need to have specific web pages highlighted by a consultant and placed on the database, scanned and updated / added to when changed. </p><p>The software needs to be web based to function across multiple sites. A full brief and data to be used will be provided. </p></aims>
  <challenges><p>The student will liaise with real stakeholders. Development of a web application in an industrial context. Efficient algorithms for querying data that might be in different formats. </p></challenges>
  <learning-outcomes><p>At the end of the project, the student should be able to analyse, design and implement a computational problem; moreover, the student will acquire the ability of developing an application for a real user. </p></learning-outcomes>
  <end-product><p>Prototype as described above </p></end-product>
  <timetable></timetable>
  <references></references>
</project>
<project label="144d0e3b8db004fc47d057f855a39476">
  <title>Sequence diagram for distributed computations</title>
  <supervisor>
    <et52 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>CO7090. Good basic knowledge of UML. Good programming skills</p></prerequisites>
  <profiles><SET/><WAS/><ADS/><ASE/></profiles>
  <aims><p>
  The aims of this project is to develop a graphical representation of sequence diagrams that fits more suitably than the standard UML ones for distributed communication protocols.
  </p></aims>
  <challenges><p>
  
  The challenging aspects of this project are the definition and development of a graphical notation for distributed protocols. 
  
  </p></challenges>
  <learning-outcomes><p>
  
  The student will learn how to individuate the important elements when defining a (graphical) language. Also, the student will acquire a deep knowledge of some of the main issues in the specification of distributed protocols.
  
  </p></learning-outcomes>
  <end-product><p>
  
  The end-product will consists of a precise graphical notation tailored on the semantics of models for distributed protocols and a visual tool to edit and possibly check properties of protocols.
  
  </p></end-product>
  <timetable><p> Study of the computational model. Definition of the drawbacks of the existing UML notation. Definition of a suitable graphical notation. Prototype of a graphical editor.
   </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="59383dc5fc75ec97cfaac32deb347179">
  <title>A Futoshiki Solver</title>
  <supervisor>
    <fdv1 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Enthusiasm and interest to get involved in the topic. Previous students found this type of project attractive. </p><p>Futoshiki (http://en.wikipedia.org/wiki/Futoshiki) is a puzzle that is played on a square grid, such as 5 x 5. The objective is to place the numbers 1 to 5 (or whatever the dimensions are) such that each row, and column contains each of the digits 1 to 5. Some digits may be given at the start. In addition, inequality constraints are also initially specifed between some of the squares, such that one must be higher or lower than its neighbour. These constraints must be honoured as the grid is filled out.
  You may know the puzzle from the Guardian.</p></prerequisites>
  <profiles><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>Make a tool that allows to solve such puzzles online using mouse and keyboard as well as automatically. Such a tool can then be used to make a program that produces such puzzles. 
  Futoshiki seems ideally suited to be solved using SAT-solving techniques.
  </p></aims>
  <challenges><p>Such puzzles can be tackled in a generic way with help of SAT solvers. </p><p>The rough idea is to translate the formula into a propositional formula; the SAT solver ties to calculate an assigment that makes the formula true; the assignment then translates back to a solution of the puzzle. As SAT solvers ahve become very powerful tools recently (they are used in modelchecking), this is can be remarkable efficient way of solving puzzles like Sudoku and Futoshiki...</p></challenges>
  <learning-outcomes><p>Experience using SATsolvers </p></learning-outcomes>
  <end-product><p>An elegant tool that (1) lets people solve puzzles by hand, (2) is able to solve puzzle automatically, (3) can assist in the creation of new puzzles </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references></references>
</project>
<project label="b5893f289ec9050ba6775de23cf7888e">
  <title>A Light Up Solver</title>
  <supervisor>
    <fdv1 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Enthusiasm and interest to get involved in the topic. Previous students found this type of project attractive. </p><p>Light up (http://en.wikipedia.org/wiki/Light_Up) is another nice, brain teasing puzzle from Nikoli. Light Up is played on a rectangular grid of white and black cells. The player places light bulbs in white cells such that no two bulbs shine on each other, until the entire grid is lit up. A bulb sends rays of light horizontally and vertically, illuminating its entire row and column unless its light is blocked by a black cell. A black cell may have a number on it from 0 to 4, indicating how many bulbs must be placed adjacent to its four sides; for example, a cell with a 4 must have four bulbs around it, one on each side, and a cell with a 0 cannot have a bulb next to any of its sides. An unnumbered black cell may have any number of light bulbs adjacent to it, or none. Bulbs placed diagonally adjacent to a numbered cell do not contribute to the bulb count. </p></prerequisites>
  <profiles><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>Make a tool that allows to solve such puzzles online using mouse and keyboard as well as automatically. Such a tool can then be used to make a program that produces such puzzles. Futoshiki seems to lend itself well to be solved using SAT-solving techniques. </p></aims>
  <challenges><p>Such puzzles can be tackled in a generic way with help of SAT solvers. </p><p>The rough idea is to translate the formula into a propositional formula; the SAT solver ties to calculate an assigment that makes the formula true; the assignment then translates back to a solution of the puzzle. As SAT solvers ahve become very powerful tools recently (they are used in modelchecking), this is can be remarkable efficient way of solving puzzles like Sudoku and Futoshiki... </p></challenges>
  <learning-outcomes><p>Experience using SATsolvers </p></learning-outcomes>
  <end-product><p>An elegant tool that (1) lets people solve puzzles by hand, (2) is able to solve puzzle automatically, (3) can assist in the creation of new puzzles </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references></references>
</project>
<project label="134f746bf52411a9e9185ec73ab73490">
  <title>A Slitherlink Solver</title>
  <supervisor>
    <fdv1 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Enthusiasm and interest to get involved in the addictive topic. Previous students found it very attractive. </p><p>Slitherlink (http://en.wikipedia.org/wiki/Slitherlink) is played on a rectangular lattice of dots. Some of the squares formed by the dots have numbers inside them. The objective is to connect horizontally and vertically adjacent dots so that the lines form a single loop with no loose ends. In addition, the number inside a square represents how many of its four sides are segments in the loop. </p></prerequisites>
  <profiles><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>Make a tool that allows to solve such puzzles online using mouse and keyboard as well as automatically. Such a tool can then be used to make a program that produces such puzzles. </p></aims>
  <challenges><p>It is a challenge to write a program that can solve such puzzles fast. It is an even bigger challenge to write a tool that produces such puzzles. </p></challenges>
  <learning-outcomes><p>Experience using SATsolvers </p></learning-outcomes>
  <end-product><p>An elegant tool that (1) lets people solve puzzles by hand, (2) is able to solve puzzle automatically, (3) can assist in the creation of new puzzles </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references></references>
</project>
<project label="3c6a3ac9faac8691688450c6950ab8fb">
  <title>Birding with Google Maps</title>
  <supervisor>
    <fdv1 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Enthusiasm and interest to get involved in the topic. </p></prerequisites>
  <profiles><WAS/><ACM/><ADS/></profiles>
  <aims><p>The aim of this project will be to design and implement a database (perhaps XML driven) that would allow a group of birdwatchers (say the Leicestershire and Rutland Ornithological Society) to input their bird observations in the club computer via an intelligent home page over the internet. </p><p>The page should allow for a simple and quick way of inputting of data using Google Maps to enter location data. </p><p>The page should provide an easy interface to query the database and provide tools for analysing and displaying the data using Google Maps. </p></aims>
  <challenges><p>There are all kind of minor challenges: one has to come to grips with and combine all the various technologies involved. The design and implementation of a tool that is simple in use and allows the birdwatchers to query their data and display the resulting data in various ways. </p><p>The main challenge is to link the Google maps in a clever and useful way to the database. </p></challenges>
  <learning-outcomes><p>Experience in representing complex data in XML, and writing tools to input and analyse the data via a website. Experience with Google Maps. </p></learning-outcomes>
  <end-product><p>An analysis what kind of data birdwatchers like to collect and store in a database, an analysis how inputting such data can be facilitated and checked for correctness/reasonability. An analysis of the kind of statistics that birdwatchers may perform on their data. A design and an implementation of an actual piece of birding software that is ready for use and that helpful for bookkeeping of bird observations. </p></end-product>
  <timetable><p>Experimentation with prototypes and maps. Perhaps experimentation with GPS. Design of final product. Implementation of final product. </p><p> </p></timetable>
  <references></references>
</project>
<project label="118fa854f6902c9e944e046cf48ec7b0">
  <title>Free Project 1</title>
  <supervisor>
    <fdv1 />
  </supervisor>
  <hidden>hidden by Artur</hidden>
  <prerequisites><p>Enthusiasm and an original project </p></prerequisites>
  <profiles><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>I am open to supervise other projects besides the other projects that I propose: please come to me and discuss your proposal for your own project. </p></aims>
  <challenges><p>Up to you! </p></challenges>
  <learning-outcomes><p> </p></learning-outcomes>
  <end-product><p>design and prototype followed by design and implementation of final product </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references></references>
</project>
<project label="9cc061282c2f2a21ac3eddf9eb940fb7">
  <title>Rewriting</title>
  <supervisor>
    <fdv1 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Enthusiasm and creativity and a substantial amount of programming preferably in a functional or object oriented style. </p></prerequisites>
  <profiles><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>In many situations it is important to know for sure that your programs complete their tasks and don't run forever. The aim of this exciting project will be to design and implement a system that given program tries to decide whether or not it will terminate on any given input. To make life simple we will not study real programs in a full-grown programming language, but we will study rewriting systems. These are very simple, but very expressive formalisms, and therefore very useful for rapid prototyping. </p></aims>
  <challenges><p>It is a challenge to understand enough of rewriting to implement the termination algorithms. </p></challenges>
  <learning-outcomes><p>You will become familiar with some ideas and concepts from the Theory of Rewriting, you will study some termination algorithms, And you will get the experience of converting theoretical algorithms into concrete programs. </p></learning-outcomes>
  <end-product><p>An implementation of a system which is able to test whether a rewriting system terminates. </p></end-product>
  <timetable><p>Some study of rewriting and termination algorithms. Make some prototype software that can handle rewrite systems and make a plan for the remaining software you will write. Implementation of one or two termination deciding algorithms. </p></timetable>
  <references><reference>
  <volume>Google "Rewriting Homepage" for more info</volume>
  </reference></references>
</project>
<project label="900bfa6436428c5655239c14f4fbf42d">
  <title>The Game of Hex</title>
  <supervisor>
    <fdv1 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Programming skills of course, and enthusiasm and interest to get involved in the topic. </p></prerequisites>
  <profiles><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>The aim of this project will be to design and implement a system for that allows you to play the famous Game of Hex either with two human players or with one human against the system or between two systems. </p></aims>
  <challenges><p>It is a challenge is to make a reasonably strong computer player on NxN boards for arbitrary n. </p></challenges>
  <learning-outcomes><p>You will gain knowledge of AI and game theory (game trees, minimax, alpha-beta pruning). You will design and implement algorithms for a computer player. You may wish to explore the Anshelevich' analogy of HEX with electrical resistor circuits. Or alternatively you may wish to experiment with Monte Carlo techniques that have recently been applied fruitfully for games like Go. </p></learning-outcomes>
  <end-product><p>Understanding of some AI and game theory. A package for playing the game with a computer: either between two humans or a human and a computer player. </p></end-product>
  <timetable><p>Learn to play the game. Learn about game theory applicable to this particular game. Build some interface allowing two humans to play the game. Experiment with algorithms/strategies for a computer player. Design and implement one or more computer players and test them against each other and or a human player </p></timetable>
  <references><reference>
  <note>Check wikipedia for information and links to "Hex (board game)"</note>
  </reference></references>
</project>
<project label="59d5c8328fc0a7e7f8ec41f89f90bbcb">
  <title>The Game of Sheep and Wolf</title>
  <supervisor>
    <fdv1 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Programming skills of course, and enthusiasm and interest to get involved in the topic. </p></prerequisites>
  <profiles><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>The aim of this project will be to design and implement a system for that allows you to play the old Game of Sheep and Wolf either with two human players or with one human against the system or between two systems. </p>Description of the Game of Sheep and Wolf<p>Sheep and Wolf is a deceivingly simple child game. There are two players in the game: one handles the white sheep and the second handles the wolf. The game is played on a board of checkers (10 x 10, neighbouring squares have opposite colours). Initially the 5 sheep and the wolf are positioned on the black squares. The 5 sheep are all positioned on the bottom row. The wolf can start at any field that her/his player likes. All pieces can make only diagonal moves to an adjacent square. The sheep can march only forward, the wolf can walk backwards and forwards. Alternating one sheep moves and then the wolf makes a step. The sheep win when the wolf can not make a legal move anymore, for instance, when they have encircled the wolf completely. The wolf wins when he manages to break through the line of sheep and reaches the bottom row. The wolf must make the first move. </p>The Sheep can always win<p>If you play the game with friends, you will note that the sheep can always win. The book "Winning ways" explains this for an 8x8 board. Does this technique extends to other board sizes as well? Can general AI techniques lead to an unbeatable Sheep player? </p>Variant<p>It is an open problem whether the sheep have a winning strategy if the wolf is allowed to pass one time. Can you write a strong sheep computer player for this game </p></aims>
  <challenges><p>It is a challenge is to make a sensible computer player for the sheep on 2nx2n boards for arbitrary n. What if the wolf is allowed to pass one move? </p></challenges>
  <learning-outcomes><p>You will gain knowledge of AI and game theory (game trees, minimax and alpha-beta pruning algorithms). You will design and implement algorithms for computer players handling then sheep or the wolf. </p><p>Programming skills of course, and enthusiasm and interest to get involved in the topic. </p></learning-outcomes>
  <end-product><p>Understanding of the game. A package for playing the game with a computer: either between two humans or a human and reasonably strong computer player that either plays the sheep or the wolf. </p></end-product>
  <timetable><p>Learn to play the game. Learn game theory applicable to this particular game. Build some interface allowing two humans to play the game. Experiment with algorithms/strategies for a computer player. Design and implement one or more computer players. </p></timetable>
  <references><reference>
  <author>Berlekamp, Conway and Guy.</author>
  <volume>Winning Ways. (volume II)</volume>
  <published year="1982-3"></published>
  <note>There is also Matt Ginsberg. Essentials of Artificial Intelligence. (1993).</note>
  </reference></references>
</project>
<project label="6f73d357fb82cd6c93960c30685bcb5a">
  <title>Ant Colony Optimisation for the Optimal Multicast Problem</title>
  <supervisor>
    <hc118 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Knowledge on algorithms and data structures. Programming skills in Java or C++ </p></prerequisites>
  <profiles><SET/><SFS/><ACM/><ADS/></profiles>
  <aims><p>The Optimal Multicast problem (OMP) can be stated as follows: given a weighted network G in which each edge has a weight representing the cost of the edge, the objective of OMP is to find a multicast tree from some node s, called the source to a set of receiver nodes in G. The optimal multicast tree should have the least cost. The OMP problem is the basic ingredient problem in network optimization problems. It also has numerous applications in other areas. </p><p>Many tranditional algorithms have been proposed for the OMP problem. However, in nature the ant colony can also solve the OMP problem when they are searching for food. From this researchers developed Ant Colony Optimisation (ACO) algorithms. The aim of this project is to design, implement, and demonstrate ACO algorithms and some tranditional optimization algorithms for OMPs with comparison of their performance in either C++ or Java </p></aims>
  <challenges><p>Understanding the key concepts of Ant Colony Optimisation </p><p>Implementing an Ant Colony Optimisation algorithm to solve the Optimal Multicast Problem in C++ or Java </p></challenges>
  <learning-outcomes><p>Learn about algorithm engineering </p><p>Learn about Ant Colony Optimisation </p><p>Implement an Ant Colony Optimisation algorithm for solving the Optimal Multicast Problem </p><p>Build a simple software package </p></learning-outcomes>
  <end-product><p>A practical software package for animating Ant Colony Optimisation for the Optimal Multicast Problem </p></end-product>
  <timetable><p>Month 1: Learning about Ant Colony Optimisation, the requirements and design of the tool, design of algorithms, start of prototype </p><p>Month 2: Prototype </p><p>Month 3: Final software tool, evaluation of algorithms </p></timetable>
  <references><reference>
  <author>Marco Dorigo and Thoms Stutzle</author>
  <volume>Ant Colony Optimisation</volume>
  <published year="2004">The MIT Press</published>
  <note>Available as<a href="http://www.cs.le.ac.uk/people/syang/ACO-Book.pdf">pdf</a></note>
  </reference></references>
</project>
<project label="a243075e6aff010e494ccbc680e90526">
  <title>Evolutionary Algorithms for the Dynamic Clustering Problem in Wireless Networks</title>
  <supervisor>
    <hc118 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Knowledge on algorithms and data structures. Programming skills in Java or C++</p></prerequisites>
  <profiles><SET/><SFS/><ACM/><ADS/></profiles>
  <aims><p>Evolutionary algorithms (EAs) are a class of problem solving algorithms based on principles drawn from natural evolution, such as nature selection and heredity. EAs maintain a population of candidate solutions to a given problem which are evaluated according to a problem-specific fitness function that defines the environment for the evolution. New population is created by selecting relatively fit members of the present population and recombining them through genetic operations using various genetic operators. Due to EA's characteristics of easy-to-use, great robustness and good parallel processing capacity, it has been used in a great number of scientific and engineering problems and models, such as numerical function optimization, combinatorial optimization (e.g., the knapsack problem, the job-shop scheduling problem, and the traveling salesman problem), automatic programming, machine learning, economics, and finance analysis.</p>
  
  <p>The aim of this project is to design and implement a simple software package to demostrate and animate the process of using Evolutionary Algorithms for solving the dynamic clustering problem (DCP) in wireless networks, which is to find the optimal set of clusterheads. The network situation will change from time to time. Therefore, a new optimal set of clusterheads needs to be re-elected once the network is changed. The program is written in either C++ or Java.</p></aims>
  <challenges><p>Understanding the key concepts of evolutionary algorithms</p> 
  
  <p>Implementing evolutionary algorithms to solve the DCP in C++ or Java</p></challenges>
  <learning-outcomes><p>Learn about algorithm engineering</p>
  <p>Learn about Evolutionary Algorithms</p>
  <p>Implement Evolutionary Algorithms for solving the DCP</p>
  <p>Build a simple software package</p></learning-outcomes>
  <end-product><p>A practical software package for animating Evolutionary Algorithms for the DCP</p></end-product>
  <timetable><p>Month 1: Learning about Evolutionary Algorithms, the requirements and design of the tool, design of algorithms, start of prototype</p>
  <p>Month 2: Prototype</p> 
  <p>Month 3: Final software tool, evaluation of algorithms </p></timetable>
  <references><reference>
  <author>Zbigniew Michalewicz</author>
  <volume>Genetic Algorithms + Data Structures = Evolution Programs</volume>
  <published year="1999">Springer-Verlag</published>
  <note>3rd edition</note>
  </reference></references>
</project>
<project label="2f580d5acfc25e82d6146006e275633f">
  <title>Evolutionary Algorithms for the Travelling Salesman Problem</title>
  <supervisor>
    <hc118 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Knowledge on algorithms and data structures. Programming skills in Java or C++ </p></prerequisites>
  <profiles><SET/><SFS/><ACM/><ADS/></profiles>
  <aims><p>Evolutionary algorithms (EAs) are a class of problem solving algorithms based on principles drawn from natural evolution, such as nature selection and heredity. EAs maintain a population of candidate solutions to a given problem which are evaluated according to a problem-specific fitness function that defines the environment for the evolution. New population is created by selecting relatively fit members of the present population and recombining them through genetic operations using various genetic operators. Due to EA's characteristics of easy-to-use, great robustness and good parallel processing capacity, it has been used in a great number of scientific and engineering problems and models, such as numerical function optimization, combinatorial optimization (e.g., the knapsack problem, the job-shop scheduling problem, and the traveling salesman problem), automatic programming, machine learning, economics, and finance analysis. </p><p>The aim of this project is to design and implement a simple software package to demostrate and animate the process of using Evolutionary Algorithms for solving the Traveling Salesman Problem (TSP), which is to find the shortest cyclic route that passes each of a set of cities once and only once, in either C++ or Java. </p></aims>
  <challenges><p>Understanding the key concepts of evolutionary algorithms </p><p>Implementing evolutionary algorithms to solve the TSP in C++ or Java </p></challenges>
  <learning-outcomes><p>Learn about algorithm engineering </p><p>Learn about Evolutionary Algorithms </p><p>Implement Evolutionary Algorithms for solving the TSP </p><p>Build a simple software package </p></learning-outcomes>
  <end-product><p>A practical software package for animating Evolutionary Algorithms for the TSP </p></end-product>
  <timetable><p>Month 1: Learning about Evolutionary Algorithms, the requirements and design of the tool, design of algorithms, start of prototype </p><p>Month 2: Prototype </p><p>Month 3: Final software tool, evaluation of algorithms </p></timetable>
  <references><reference>
  <author>Zbigniew Michalewicz</author>
  <volume>Genetic Algorithms + Data Structures = Evolution Programs</volume>
  <published year="1999">Springer-Verlag</published>
  <note>3rd edition</note>
  </reference></references>
</project>
<project label="44a8cfa2f2ea94da7d30047798375f56">
  <title>An Editor Assistant</title>
  <supervisor>
    <iu3 />
  </supervisor>
  <hidden>taken in CA7201 08/09</hidden>
  <prerequisites><p>Knowledge of databases, Web technologies is required. </p></prerequisites>
  <profiles><SET/><SFS/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>To design and develop a Web-based management system to assist in the editorial process of an online publication house. It publishes proceedings of workshops. </p><p>The system should manage the whole process from the time that a workshop requests publication of its proceedings to the time when finally the proceedings are published. </p><p>To learn MVC (Model-view-controller) methodology and use of the free MVC software (eg Ruby on rails) on the project. </p></aims>
  <challenges><p>Design a good way to manage and schedule the work of editors who typically live in different countries (distributivity, concurrency issues). </p><p>Automatic spelling checker, formatting of papers checker, size of paper checker. </p></challenges>
  <learning-outcomes><p> </p></learning-outcomes>
  <end-product><p> </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references></references>
</project>
<project label="8927ea16eefbb7c874c938a34f2625bd">
  <title>Bi-lingual Content Management System</title>
  <supervisor>
    <iu3 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Interest in distributed databases, web content management systems. </p></prerequisites>
  <profiles><SET/><SFS/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>Web content management systems (CMS) aim to help general public to create and manage websites. The project aims to develop a CSM for a simple web application that offers multi-lingual content. One of the problems is how to ensure the consistency of content of multi-lingual pages. The answer might be provided by setting up a hierarchical management structure of the document life cycle. </p></aims>
  <challenges><p>Design and implement a simple CMS. </p><p>Provide support for bi-lingual editing, maintenance and archiving of documents. </p><p>Design and implement a system for guaranteeing consistency and correctness of bi-lingual content. For example, a set of many pages with content written in English is translated into Polish language by several different translators, possibly simultaneously. Someone needs to check the correctness and ensure consistency. Then, the editor needs to approve the publication. </p></challenges>
  <learning-outcomes><p> </p></learning-outcomes>
  <end-product><p>CMS for bi-lingual web pages. </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="4597a6b9fac49d1907e3d7228b238731">
  <title>Cellular Automata</title>
  <supervisor>
    <iu3 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>This project requires interest in cellular automata, programming and in computer graphics.</p></prerequisites>
  <profiles><SET/><SFS/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p> According to Wikipedia, a cellular automaton is a discrete model studied in computability theory, mathematics, physics, complexity science, theoretical biology and microstructure modeling. </p><p>The aim of the project is to study cellular automata, experiment with existing software tools for one- and two-dimensional cellular automata, and
  finally, use the knowledge and experience gained to develop your own software tool for "reversible" cellular automata.</p></aims>
  <challenges><p>1. Learn the basics of cellular automata and software tools for cellular automata; </p><p>2. Study reversible cellular automata; </p><p>3. Develop a simple software tool for reversible cellular automata. </p><p>Also, see http://www-course.cs.york.ac.uk/nsc/applets/CellularAutomata/index1d.html </p></challenges>
  <learning-outcomes><p> </p></learning-outcomes>
  <end-product><p>Extensive report on challenges 1 and 2, software tool for challenge 3, descriptions of several reversible cellular automata. </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="3ba8f6ecdf3c7608883fd99f00fe6365">
  <title>Exam management system</title>
  <supervisor>
    <iu3 />
  </supervisor>
  <hidden>taken in CA7201 08/09</hidden>
  <prerequisites><p>Good knowledge of databases and web technologies. </p></prerequisites>
  <profiles><SET/><WAS/><ADS/><ASE/></profiles>
  <aims><p>To design and implement a system to store, manage and retrieve BSc exam marks and decisions of the Exam Board. </p><p>To learn MVC and how to use Ruby on rails. </p></aims>
  <challenges><p>Develop a good method for dealing with resit marks, resit without residence marks, temporary withdrawals of students, students repeating years, students carrying modules, modules changing semesters, new modules. </p><p>Keeping track of different versions of the exam marks database. </p><p>Production of semi-automatic minutes of exam meetings. </p></challenges>
  <learning-outcomes><p> </p></learning-outcomes>
  <end-product><p>A working prototype and a set of test data (tables of the exam database) that demonstrates correct implementation of the main features. </p></end-product>
  <timetable></timetable>
  <references></references>
</project>
<project label="edb678bafd515ac7e62b945ea1500227">
  <title>Modelling of ubiquitous computing</title>
  <supervisor>
    <iu3 />
  </supervisor>
  <hidden> Gul, Nosheen (ng90)</hidden>
  <prerequisites><p> </p></prerequisites>
  <profiles><SET/><SFS/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p> </p></aims>
  <challenges><p> </p></challenges>
  <learning-outcomes><p> </p></learning-outcomes>
  <end-product><p> </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references></references>
</project>
<project label="3fd6ba452419471a72d6420d2d4c5030">
  <title>Process algebra simulator</title>
  <supervisor>
    <iu3 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>This project suggests interest in process algebras such as CCS or CSP. </p></prerequisites>
  <profiles><ACM/><ADS/><ASE/></profiles>
  <aims><p>A communication protocol is a scheme for exchanging messages between two parties over a computer network. Protocols have to deal with messages being lost or corrupted by the network, and with issues of flow control. There are a number of well known protocols, such as the alternating bit protocol and the sliding window protocol. Unfortunately, they are a bit difficult to understand, model and analyse. </p><p>Process algebras are formal languages for describing parallel and distributed systems. Well known process algebras include CCS and CSP which are taught in CO7094 and CO7007. </p><p>The aim of this project is to build a process algebra simulator. The user will prepare a file containing a description of a concurrent system, for example a communication protocol, and load this file into the simulator. The simulator will then allow the user to "walk through" the system, i.e. to investigate what possible different runs the system can produce when it executes. </p></aims>
  <challenges><p>Design and implementation of a system that will simulate the execution of CSP/CCS agents based on their operational semantics. Also, the development of GUI that will allow users to execute agents in step-by-step fashion, where steps are chosen be the users, is important. </p><p>A feature that will allow the user to "reverse" steps taken in order to recover from deadlocks will be quite useful: for this a student taking this project will need to study the basics of reversible CCS.</p></challenges>
  <learning-outcomes><p> </p></learning-outcomes>
  <end-product><p>A simulator for process algebra together with several input files containing CCS agents. </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author>Robin Milner</author>
  <volume>Communication and Concurrency</volume>
  <published year="1989">Prentice Hall</published>
  <note></note>
  </reference></references>
</project>
<project label="778b94607e593631cb8950ceb33ce3e3">
  <title>Simulation of computation under weak memory model</title>
  <supervisor>
    <iu3 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Good Java or C++ programming skills and interest in weak memory models for multi-threaded programming. </p></prerequisites>
  <profiles><SET/><SFS/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>The project aims to develop a web based system to simulate execution of simple multi-threaded-like programs under weak memory model assumption. The system will then be used to illustrate how the same program may produce different results when executed according different memory models assumptions. </p></aims>
  <challenges><p>Study the basics of weak memory models. </p><p>Design and implement a simple simulator. </p><p>Implement optimizations for two different weak memory models. </p><p>Write a suite of experiment programs to test the simulator under two different memory models. </p></challenges>
  <learning-outcomes><p>Learn the basics of weak memory models. Gain experience in multi-threaded programming. Analyze and evaluate experimental data. </p></learning-outcomes>
  <end-product><p>A simulator, a suite of experiment programs. </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references>See supervisor.</references>
</project>
<project label="6b31eaae5ca736d0aa62433154c252df">
  <title>Study of revesible algorithms</title>
  <supervisor>
    <iu3 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Interest in Reversible Computation. </p></prerequisites>
  <profiles><SET/><SFS/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>Learn the basics of reversible computing: reversible logic gates, reversible computer architecture, reversible Turing machines, reversible algorithms, reversible programming languages. </p></aims>
  <challenges><p>Most challenges can be read out from the Aims. Additionally, implement a reversible algorithm so that it can run in the forward and reverse direction. </p></challenges>
  <learning-outcomes><p> </p></learning-outcomes>
  <end-product><p>A written report presenting the basics of reversible computing; a reversible algorithm implementation. </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references>See supervisor.</references>
</project>
<project label="e9ac4f452c0dc096a8683113dfb3b118">
  <title>Study of revesible computing</title>
  <supervisor>
    <iu3 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Interest in Reversible Computation. </p></prerequisites>
  <profiles><SET/><SFS/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>Learn the basics of reversible computing: reversible logic gates, reversible computer architecture, reversible Turing machines, reversible algorithms, reversible programming languages. </p></aims>
  <challenges><p>Most challenges can be read out from the Aims. Additionally, implement a reversible algorithm so that it can run in the forward and reverse direction. </p></challenges>
  <learning-outcomes><p> </p></learning-outcomes>
  <end-product><p>A written report presenting the basics of reversible computing; a reversible algorithm implementation. </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references>See supervisor.</references>
</project>
<project label="75525c963b61eac2191de8152d4d50ea">
  <title>Creating a Service-Oriented Model for a Healthcare Case Study</title>
  <supervisor>
    <jwf4 />
  </supervisor>
  <hidden>taken</hidden>
  <prerequisites><p>Knowledge of SRML </p><p>Knowledge of web services </p><p>This project requires an active approach to problems and a degree of independence in collecting requirements and providing feedback on the usability of SRML in the healthcare context </p></prerequisites>
  <profiles><WAS/><ASE/></profiles>
  <aims><p>The aim of this MSc project is to model a service-oriented application for healthcare. The process will include both defining requirements and modelling using UML 2 (especially use case and sequence diagrams) and SRML. The aim of the project is to provide feedback on the usability of SRML in the health-care scenario and possibly suggest improvements or underline critical issues </p></aims>
  <challenges><p><ul><li>Understand SRML, SRML Editor environment and UML 2.</li><li>Methodological study of relationship between UML 2 and SRML.</li><li>Choice of the UML2 diagrams to be used (e.g., statecharts, sequence...).</li><li>Study of a use case and representation of the requirements into models.</li><li>Critical evaluation of the suitability of the used modelling languages for the health care scenario.</li> </ul> </p></challenges>
  <learning-outcomes><p>At the end of the project, the student should be able to:<ul><li>create and relate models in SRML and UML2,</li><li>collect and express requirements with UML2 and model a real-world scenario.</li> </ul> </p></learning-outcomes>
  <end-product><p>Description of the requirements (natural language and UML2), behavioural models (UML 2 sequence/statechart diagrams) and SRML model, possibly developed using the SRML Editor Environment. </p></end-product>
  <timetable><p>Preliminary study of SRML (ant its editor environment) and UML2. </p><p>Definition of requirements. </p><p>Model requirements with UML 2 use case diagrams. </p><p>Model behavioural aspects with UML 2 diagrams. </p><p>Develop the final SRML model, possibly using the SRML editor. </p></timetable>
  <references><reference>
  <author>L. Bocchi</author>
  <author>J. Fiadeiro</author>
  <author>A. Lopes</author>
  <volume>A Use-Case Driven Approach to Formal Service-Oriented Modelling</volume>
  <published year="2008">http://www.cs.le.ac.uk/people/jfiadeiro/Papers/SRML_useCases2.0.pdf</published>
  </reference></references>
</project>
<project label="e098519039d6e2992a4bdde6e5619cbc">
  <title>Modelling Service Level Agreement in Service Oriented Systems</title>
  <supervisor>
    <jwf4 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Knowledge of SRML </p><p>Knowledge of web services </p></prerequisites>
  <profiles><ACM/><ADS/><ASE/></profiles>
  <aims><p>The aim of the project is to explore an approach (i.e., monoids) for the definition of Service Level Agreement (SLA) constraints in Service Oriented Systems. The investigated approach is different from the one currently used in SRML (c-semirings). </p></aims>
  <challenges><p><ul><li>Addressing the key challenges of the definition of Quality of Service constraints</li><li>Familiarizing with an abstract framework for the definition of constraints and the related tool</li><li>Providing a critical evaluation of the modelling exercise with the new framework.</li> </ul> </p></challenges>
  <learning-outcomes><p>At the end of the project the student will be familiar with the key issues that concern the definition of Quality of Service constraints, which is a crucial issue in Service-Oriented Engineering. This will allow straightforward familiarization with the specific technologies used, for example, in the Web services scenario. The student will also be familiar with a tool for the definition of constraints. </p></learning-outcomes>
  <end-product><p>The end product consists a constraint system (SLA) for a given SRML module expressed with monoids and an account on the usage of the tool. Also the student will provide an brief report on that comments on the modelling experience. </p></end-product>
  <timetable><p>Develop a minimal background on monoids. </p><p>Understand the SLA of a given SRML module and express the SLA with the new framework (monoids). </p><p>Use the provided tool to analyze the produced SRML module. </p></timetable>
  <references><reference>
  <author>J. Abreu</author>
  <author>L. Bocchi</author>
  <author>J. Fiadeiro</author>
  <author>A. Lopes</author>
  <volume>The SENSORIA Reference Modelling Language</volume>
  <published year="2008">https://campus.cs.le.ac.uk/teaching/resources/CO7205/SRML(notes).pdf</published>
  </reference></references>
</project>
<project label="9fd94ddc843c1919e79d2e2453972a40">
  <title>Modelling Virtual Organisations for Communities of Archeologists</title>
  <supervisor>
    <jwf4 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p><ul><li>Knowledge of SRML</li><li>Knowledge of web services</li> </ul> </p></prerequisites>
  <profiles><WAS/><ADS/><ASE/></profiles>
  <aims><p>The aim of the project is to model interactions and information sharing between archeologists and the communities they belong to by using a framework for modelling Virtual Organisations (VO)s. As the integration of data deriving from different archeological sites and projects is a new challenge of interdisciplinary research, one aim of the project is also to evaluate the suitability of the used framework to address the issues of the archeological case study. </p></aims>
  <challenges><p>The challenges of this project can be found in the following areas:<ul><li>understanding the framework for modelling VO (which is in many aspects similar to SRML)</li><li>understanding case study in the archeological domain</li><li>critical evaluation of the framework and of the modelling exercise done during the project</li> </ul> </p></challenges>
  <learning-outcomes><p>The student will understand and handle non trivial models for VO and make experience in applying results of computer science in an inter-disciplinary domain. </p></learning-outcomes>
  <end-product><p>From a set of requirements in the archeological domain, we expect the student to distil a simple case study. Also, we expect as a result a model for VO in a provided language and an evaluation of the suitability of the language for the given case study. </p></end-product>
  <timetable><p>Month 1 : learning the framework or VOs and collecting requirements </p><p>Month 2 : defining case study from requirements and modelling case study </p><p>Month 3 : evaluation </p></timetable>
  <references><reference>
  <author>Laura Bocchi, José Luiz Fiadeiro, Noor Rajper and Stephan Reiff-Marganiec</author>
  <published year="2009">Structure and Behaviour of Virtual Organisation Breeding Environments (FAVO'09)</published>
  </reference></references>
</project>
<project label="1b3d35104722a04a7b36931b6d74152a">
  <title>Modelling the role of humans in Service-Orented Systems</title>
  <supervisor>
    <jwf4 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Knowledge of SRML. </p><p>Knowledge of web services and BPEL</p><p>The project requires the ability to easily relate to new topics and a critical constructive approach to the state of the art </p></prerequisites>
  <profiles><WAS/><ADS/><ASE/></profiles>
  <aims><p>The aim of this MSc project is to study the state of art of protocols or the involvement of humans in business protocols (e.g., BPEL4Pepole). The main challenge is to create a simple prototypical model in BPEL4People and define a similar model in SRML. The aim is to compare expressiveness and usability of BPEL4People and SRML and to possibly identify important issues that, at the moment, are not captured by one or the other language. </p></aims>
  <challenges><p><ul><li>Understand SRML and its editing environment.</li><li>Study scope and aims of BPEL4People (and some minimal background on related work).</li><li>Develop a model in BPEL4People (or adapting an existing one) and develop a similar model in SRML. The challenge is NOT to be able to model BPEL4People with SRML but to gain awareness and provide a critical assessment of the degree up to which this is possible.</li> </ul> </p></challenges>
  <learning-outcomes><p>At the end of the project, the student should be able to:<ul><li>create and relate models in SRML and BPEL4People,</li><li>perform a critical analysis of the state of the art and compare different languages,</li><li>rely on a background on business processes over the SOA involving humans, which is an emerging topic.</li> </ul> </p></learning-outcomes>
  <end-product><p>BPEL4People model, SRML model, possibly using SRML editor, report on the expressiveness and usability of SRML and BPEL4People to model business processes involving humans. </p></end-product>
  <timetable><p>Preliminary study SRML metamodel. </p><p>Study of BPEL4People and related work. </p><p>Definition of a model in BPEL4Pepople (or adaptation of an existing one). </p><p>Definition of a corresponding SRML model. </p><p>Analysis of the experience. </p></timetable>
  <references><reference>
  <author>L. Bocchi</author>
  <author>J. Fiadeiro</author>
  <author>A. Lopes</author>
  <volume>A Use-Case Driven Approach to Formal Service-Oriented Modelling</volume>
  <published year="2008">http://www.cs.le.ac.uk/people/jfiadeiro/Papers/SRML_useCases2.0.pdf</published>
  </reference><reference>
  <author>A. Agrawal et al.</author>
  <volume>WS-BPEL Extension for People (BPEL4People), Version 1.0</volume>
  <published year="2007">https://www.sdn.sap.com/irj/sdn/go/portal/prtroot/docs/library/uuid/30c6f5b5-ef02-2a10-c8b5-cc1147f4d58c</published>
  <note></note>
  </reference></references>
</project>
<project label="8dafc7e6c284916565ccab8a217f0a96">
  <title>Quantitative analysis for Service-Oriented Models</title>
  <supervisor>
    <jwf4 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Knowledge of SRML </p><p>Knowledge of web services </p><p>Knowledge of UML 2 (statechart/sequence diagrams) </p><p>Familiarity with Eclipse </p></prerequisites>
  <profiles><WAS/><ADS/><ASE/></profiles>
  <aims><p>The aim of this MSc project is to perform the quantitative analysis (i.e., analysis of time properties) of a SRML module. The SRML module has to be encoded into PEPA, a process algebra for performance analysis. The process to follow in order to perform the encoding will be provided to the student as a guideline. The derived PEPA model has to be analysed using the PEPA Eclipse plug-in to perform qualitative analysis. </p></aims>
  <challenges><p><ul><li>Gain experience in modelling with SRML (and its time aspects).</li><li>Study aims and syntax of PEPA and the methodology.</li><li>Understand the relationship between PEPA and SRML.</li><li>Use of PEPA Eclipse plug-in and SRML Editor.</li> </ul> </p></challenges>
  <learning-outcomes><p>At the end of the project, the student should be able to:<ul><li>understand and handle non trivial SRML modules,</li><li>understand and handle PEPA models,</li><li>analyse time properties of a SRML model through an Eclipse plug-in,</li><li>have a general idea on analysing properties for systems involving time.</li> </ul> </p></learning-outcomes>
  <end-product><p>The PEPA model of a chosen SRML model, in the format usable by the PEPA Eclipse plug-in and a report on the analysis results. </p></end-product>
  <timetable><p>Develop a minimal background on PEPA. </p><p>Understand and possibly refine a given SRML module. </p><p>Derive the PEPA model corresponding to the given SRML model. </p><p>Use the obtained PEPA model as an input for the PEPA Eclipse plug-in to perform qualitative analysis. </p></timetable>
  <references><reference>
  <author>J. Abreu</author>
  <author>L. Bocchi</author>
  <author>J. Fiadeiro</author>
  <author>A. Lopes</author>
  <volume>The SENSORIA Reference Modelling Language</volume>
  <published year="2008">https://campus.cs.le.ac.uk/teaching/resources/CO7205/SRML(notes).pdf</published>
  </reference><reference>
  <author>S. Gilmore</author>
  <author>J. Hillson</author>
  <volume>The PEPA Workbench: A Tool to Support a Process Algebra-based Approach to Performance Modelling</volume>
  <published>http://www.dcs.ed.ac.uk/pepa/workbench.pdf</published>
  <note>(for Eclipse plug-in see http://www.dcs.ed.ac.uk/pepa/tools/)</note>
  </reference></references>
</project>
<project label="6dc869a738ecf73e58d8ccc86187373b">
  <title>Service-Oriented Modelling</title>
  <supervisor>
    <jwf4 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Depending on its precise nature, to be agreed with the student, the project(s) will require either a strong background in Java/Eclipse (for tool development) or the ability of critically approaching a technical paper and applying the acquired knowledge to a case study (for using formal techniques to model a case study). </p><p>Attendance of CO7205 is recommended. </p></prerequisites>
  <profiles><SET/><SFS/><WAS/><ADS/><ASE/></profiles>
  <aims><p>Service-Oriented Architectures enable the dynamic discovery and binding of services in order to increase the flexibility of business interactions. Sensoria is a European Project with the aim of providing methods and tools for the development of service-oriented systems. The role of Leicester consists in developing and implementing high-level modelling languages for services, in defining the transformation of models into implementations, and in the re-engineering of legacy systems into service-oriented ones. </p><p>The focus of the topics proposed for one or more MSc projects is the reference language SRML that we are defining within Sensoria for the design of business processes in a service-oriented architecture. The aim of each project is either the development of visual/textual/reasoning tools to support the modeling activity with SRML, or the usage of SRML to model a case study. The exact topics will be negotiated based on the needs of Sensoria and the interests of the students. </p></aims>
  <challenges><p>The project involves innovative topics; students have to get familiar with a number of new concepts, technologies, and tools beyond what is currently being taught in BSc programmes. The project will provide the opportunity for critical reading and applying formal techniques to real case studies. </p></challenges>
  <learning-outcomes><p>Learn about service-oriented systems, web services, and their high-level modelling. </p><p>Gain experience in using state-of-the-art languages and tools. </p><p>Get an insight into scientific and industry-oriented research. </p></learning-outcomes>
  <end-product><p>SRML model for a case study and/or extensions to existing SRML tools (editor or model-checker) or other tools, depending on the nature of the project. </p></end-product>
  <timetable><p>Background research on SRML and the case study. </p><p>Initial experience with relevant tools. </p><p>Development of the case study or of the tool extension. </p></timetable>
  <references><p>Several references to SRML (including case studies) are available at www.cs.le.ac.uk/jfiadeiro. </p></references>
</project>
<project label="96b1d69b95afc6109ca1ed33ec022e4b">
  <title>Service Oriented Modelling and Relationship with Standards</title>
  <supervisor>
    <jwf4 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p><ul><li>Knowledge of SRML (module CO7205)</li><li>Knowledge of web services</li> </ul> </p></prerequisites>
  <profiles><WAS/><ADS/><ASE/></profiles>
  <aims><p>The aim of the project is to compare, through the development of a case study, SRML with the Service Component Architecture (SCA). SRML is the outcome of academic research and SCA is a standard proposed by an industrial consortium. </p></aims>
  <challenges><p>The challenges of this project can be found in the following areas:<ul><li>developing a SRML module</li><li>survey of an industry standard and development of an example</li><li>critical evaluation of similarities, differences and relationships.</li> </ul>SRML has been inspired by SCA, so we expect a number of similarities. The challenge of the project is to critically evaluate differences, relationships and possible synergies in a overall engineering process. </p></challenges>
  <learning-outcomes><p>The student will:<ul>understand and handle non trivial SRML modules<li>get familiar with a standard proposed by major companies (IBM, BEA, etc.)</li><li>gain a comprehensive overview of new challenges addressed in both academia and industry.</li> </ul> </p></learning-outcomes>
  <end-product><p>A SRML module, a sketch of a SCA model, a report comparing the two technologies. </p></end-product>
  <timetable><p>Month 1 : learning SCA and developing a SRML example </p><p>Month 2 : using SCA </p><p>Month 3 : comparison </p></timetable>
  <references><reference>
  <author>J. Abreu, L. Bocchi, J. Fiadeiro and A. Lopes.</author>
  <published year="2008">The SENSORIA Reference Modelling Language. https://campus.cs.le.ac.uk/teaching/resources/CO7205/SRML(notes).pdf</published>
  </reference><reference>
  <published>Service Component Architecture. http://www.osoa.org/display/Main/Service+Component+Architecture+Specifications</published>
  </reference></references>
</project>
<project label="0751a62ebc80fb19cfbf982574bce6cc">
  <title>A graphical application to model quantitative properties of service-oriented applications</title>
  <supervisor>
    <lb148 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Knowledge of SRML </p><p>Knowledge of Web Service </p><p>Familiarity with Eclipse programming </p></prerequisites>
  <profiles><WAS/><ADS/><ASE/></profiles>
  <aims><p>Provide a GUI that allows to extend an existing model with one or more non-functional properties. </p><p>Implement an encoding of the extended model into PEPA, a language that allows quantitative analysis. </p></aims>
  <challenges><p>Understanding the inter-relation of SRML models with non-functional aspects </p><p>Defining the inter-relation between two languages at different levels of abstraction </p><p>Programming the GUI and the encoding </p></challenges>
  <learning-outcomes><p>The run-time provision of services is governed by negotiations/agreements defining expected quality-of-service metrics. It is crucial for the parts of such systems to analyse their conformance to mutually negotiated service level agreements (e.g., on performance), in order to guarantee the fulfilment of their contractual obligations. </p><p>At the end of the project the student will have familiarity with modelling and analysis of non-functional properties of service-oriented models. </p><p>Also the student will learn how to relate two different languages and applications (SRML Editor and PEPA Eclips plug in). </p></learning-outcomes>
  <end-product><p>An graphical application that allows (1) to edit non-functional properties on top of a SRML model (2) to encode the extended model in a format which allows analysis using an existing tool (PEPA Eclipse plug-in) </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author>J. Abreu, L. Bocchi, J. Fiadeiro and A. Lopes.</author>
  <published year="2008">The SENSORIA Reference Modelling Language. https://campus.cs.le.ac.uk/teaching/resources/CO7205/SRML(notes).pdf</published>
  </reference><reference>
  <author>S. Gilmore and J. Hillson.</author>
  <published>The PEPA Workbench: A Tool to Support a Process Algebra-based Approach to Performance Modelling. http://www.dcs.ed.ac.uk/pepa/workbench.pdf. (for Eclipse plug-in see http://www.dcs.ed.ac.uk/pepa/tools/)</published>
  </reference></references>
</project>
<project label="ce7a3f0fd88fecc2918d214ad3481712">
  <title>Deploying a Service-Oriented Application for a Healthcare Case Study</title>
  <supervisor>
    <lb148 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Basic knowledge of SRML </p><p>Knowledge of Web services </p><p>Programming skills </p></prerequisites>
  <profiles><WAS/><ASE/></profiles>
  <aims><p>The aim of this MSc project is to deploy a service-oriented application for healthcare. The student will be provided with a set of requirements and a high level model in UML 2 (especially use case and sequence diagrams) and SRML. The student will develop an application implementing the provided specification. </p></aims>
  <challenges><p><ul><li>Understand SRML models and UML 2.</li><li>Programming a service-oriented application which implements an interactive process involving both humans and computers.</li> </ul> </p></challenges>
  <learning-outcomes><p><ul><li>understand in detail models in SRML and UML2,</li><li>understand the main issues and advantages of deploying applications starting from high-level models,</li><li>gain familiarity with programming service-oriented, interactive applications,</li><li>have experience in a real critical case study</li> </ul> </p></learning-outcomes>
  <end-product><p>An application that implements the provided specifications on a health care case study. </p><p>Documentation and tutorial for the application. </p></end-product>
  <timetable><p>Preliminary study of SRML and UML2 </p><p>Study specification. </p><p>Implementation and documentation </p></timetable>
  <references><reference>
  <author>L. Bocchi</author>
  <author>J. Fiadeiro</author>
  <author>A. Lopes</author>
  <volume>A Use-Case Driven Approach to Formal Service-Oriented Modelling</volume>
  <published year="2008">http://www.cs.le.ac.uk/people/jfiadeiro/Papers/SRML_useCases2.0.pdf</published>
  </reference></references>
</project>
<project label="f31770586a4d9664bbbc9892a2952fac">
  <title>3d house planner</title>
  <supervisor>
    <mh55 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p> Experience in creating 3D environments</p></prerequisites>
  <profiles><SET/><SFS/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p> There are many professional 3D CAD programs available. A good example is the free google scatch up. As these are very flexible tools and no specifc a certain type of 3D object using them can be tricky at the best of times. </p><p>The aim of this project is create 3D CAD tool for drawing a house. </p></aims>
  <challenges><p>Creating an easy to use houes drawing tool </p><p>Point selection in a 3D space via mouse clicks </p><p>Handling multiple lighting </p><p>Open and close windows and doors </p><p>Create a walk through </p></challenges>
  <learning-outcomes><p> </p></learning-outcomes>
  <end-product><p>A house drawing tool </p></end-product>
  <timetable><p>Analyise needed skills to complete the project </p><p>Identitfy basic houes compnents </p><p>Design and implement a prototype </p>
  <p>Enhance prototype with additional component and manipulations of existing components </p><p>Testing </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="a5f58edea4a8667129363d3f5ce14b49">
  <title>A Research Workbench for Network Discovery Algorithms</title>
  <supervisor>
    <mh55 />
  </supervisor>
  <hidden>hidden</hidden>
  <prerequisites><p>Good programming skills. Interest in graph algorithms. </p></prerequisites>
  <profiles><ACM/><ADS/><ASE/></profiles>
  <aims><p>Recent research has studied the problem of discovering the topology of a communication network using certain types of measurements. For example, to discover the topology of the Internet, one can run traceroute experiments to detect all links that are used by packets sent between pairs of nodes. The aim of this research is to design measurement strategies that discover as much information about the network as possible in short time. In order to evaluate proposed algorithms, it would be useful to have a tool with a graphical user-interface that allows simulating and visualizing how the algorithms behave on different types of networks. Such a tool could be used by researchers as a workbench in which they experiment with and evaluate new algorithms. The goal of this project is to design and implement a tool of this type. </p></aims>
  <challenges><p>The challenges of this project lie in the following areas: * The system should be designed in a modular way so that it is flexible with respect to the addition of different query models and algorithms. * A user interface that is suitable for the visualization of network discovery processes must be designed. * A problem that is close to current research needs to be understood. </p></challenges>
  <learning-outcomes><p>The student will: * carry out a detailed requirements analysis and specification. * learn about the design and implementation of an original software project * learn about graph problems that are related to current Internet research </p></learning-outcomes>
  <end-product><p>A software system that supports research on network discovery problems by allowing the user to visualize and interact with different network discovery algorithms. </p></end-product>
  <timetable><p>* Detailed list of requirements. * Prototyping of needed components. * Implementing the system. * Testing. * Documentation. </p><p> </p></timetable>
  <references><reference>
  <author>Z. Beerliova, F. Eberhard, T. Erlebach, A. Hall, M. Hoffmann, M. Mihalak, L.S. Ram.</author>
  <volume>Network Discovery and Verification. IEEE Journal on Selected Areas in Communications, special issue on SAMPLING THE INTERNET: TECHNIQUES AND APPLICATIONS</volume>
  <published year="2006"></published>
  <note></note>
  </reference></references>
</project>
<project label="22046bbde985327ec2b79e3915b4fe18">
  <title>Agent Negotiation</title>
  <supervisor>
    <mh55 />
  </supervisor>
  <hidden>hidden</hidden>
  <prerequisites><p>Good programming skills in either Java or C++. </p></prerequisites>
  <profiles><WAS/><ACM/><ADS/></profiles>
  <aims><p>Consider following the situation: There are two people, each of them has a collection of different colored balls. For example person A has 2 red, 1 yellow and 1 blue ball. Also each person has an objective of what selection of colored balls he/she would like achieve. The two people can now start to negotiate. Offering 2 red balls for a yellow one and so on.... The negotiation will take place, some balls get exchanged, until either a certain time is up or both people don't want to trade any more. </p><p>For just two people this situation can be already tricky, but now imagine a whole network of these people (Agents). Each agents a selection of colored balls and an individual objective selection that they would like to achieve. The network structure restricts the communication between agents to only the ones that are linked together. The negotiation of making and accepting offers is no longer done by people but by computer programs for each agent. </p><p>The aim of this project is to create a computer program that allows the simulation of such a scenario. </p><p>The basic features of the product would be to handle different networks, starting selection, objectives of each agent and different computer programs controlling different agents. </p></aims>
  <challenges><p>The challenges in the project lie in<ul><li>defining and implementing a protocol on negotiation and trading between agents</li><li>Creating and handling of graph structures</li><li>Write your own agent controlling programs</li><li>Analyzing and evaluating different agent controlling programs</li> </ul> </p></challenges>
  <learning-outcomes><p>The student will learn about multi agents programs, the communications between them and agent programming strategies. </p></learning-outcomes>
  <end-product><p>The end product is a mulit agent negotiation simulator. It is based on agents are located on nodes of a graph (network. The agent trade different colored balls. </p></end-product>
  <timetable><p><ul><li>Analyzing skill needed to complete the project</li><li>Gaining/testing these skills by proto typing in a two agent scenario</li><li>Establish the communication protocol between the agents</li><li>Implement simple agents programs</li><li>Extend to multiple agent</li><li>Position the agent in a graph</li><li>Implement more agents programs</li><li>Analyze your finding</li> </ul> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="7126eefc18e82fc087eae8062397aa4d">
  <title>Agent Trading</title>
  <supervisor>
    <mh55 />
  </supervisor>
  <hidden>hidden</hidden>
  <prerequisites><p>Good programming skills in either Java or C++. </p></prerequisites>
  <profiles><SFS/><WAS/><ACM/><ADS/></profiles>
  <aims><p>Consider following the situation: There are two people, each of them has a collection of different colored balls. For example person A has 2 red, 1 yellow and 1 blue ball. Also each person has an objective of what selection of colored balls he/she would like achieve. The two people can now start to negotiate. Offering 2 red balls for a yellow one and so on.... The negotiation will take place, some balls get exchanged, until either a certain time is up or both people don't want to trade any more. </p><p>For just two people this situation can be already tricky, but now imagine a whole network of these people (Agents). Each agents a selection of colored balls and an individual objective selection that they would like to achieve. The network structure restricts the communication between agents to only the ones that are linked together. The negotiation of making and accepting offers is no longer done by people but by computer programs for each agent. </p><p>The aim of this project is to create a computer program that allows the simulation of such a scenario. </p><p>The basic features of the product would be to handle different networks, starting selection, objectives of each agent and different computer programs controlling different agents. </p></aims>
  <challenges><p>The challenges in the project lie in<ul><li>defining and implementing a protocol on negotiation and trading between agents</li><li>Creating and handling of graph structures</li><li>Write your own agent controlling programs</li><li>Analyzing and evaluating different agent controlling programs</li> </ul> </p></challenges>
  <learning-outcomes><p>The student will learn about multi agents programs, the communications between them and agent programming strategies. </p></learning-outcomes>
  <end-product><p>The end product is a mulit agent trading simulator. It is based on agents are located on nodes of a graph (network. The agent trade different colored balls. </p></end-product>
  <timetable><p><ul><li>Analyzing skill needed to complete the project</li><li>Gaining/testing these skills by proto typing in a two agent scenario</li><li>Establish the communication protocol between the agents</li><li>Implement simple agents programs</li><li>Extend to multiple agent</li><li>Position the agent in a graph</li><li>Implement more agents programs</li><li>Analyze your finding</li> </ul> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="0b0c739ac659bb699232f96d7ea4c63c">
  <title>Algorithms for areas of uncertainty problems</title>
  <supervisor>
    <mh55 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Good understanding of algorithm. Good programming skills in either Java or C++.  </p></prerequisites>
  <profiles><SET/><SFS/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>Most algorithmic problems assume that the precise input is known. However in reality the initial information might not be precise and with additional cost the exact data for a certain input can be obtained. 
  </p>
  
  <p>
  For example there are many algorithm for weighted graphs (a network where each edge of the network has a value). Typically it is assumed that the weight of an edge is known exactly. In fact the exact information is not always for the algorithm to run, and where more precise information is needed only requesting the precise weight of certain edges is needed. 
  </p>
  
  <p>
  The aim of this project is to design and implement algorithms for problems with areas of uncertainty and to evaluate them in systematic simulation experiments. Some algorithms have been proposed in the literature. In addition, there is opportunity to modify/improve the known algorithms or to develop new ones.  </p></aims>
  <challenges><p> The challenges of this project can be found in the following areas
  
  <ul>
  
  <li>
  Understanding the description of algorithms with uncertainty from the literature, and implementing them properly.
  </li>
  <li>Inventing new algorithms with uncertainty.</li>
  
  <li>
  Implementation and visualization of efficient algorithms
  </li>
  </ul></p></challenges>
  <learning-outcomes><p>The student will:
  
  <ul>
  
  <li>
  Be able to discuss the application background of problems with uncertainty.
  </li>
  
  <li>
  Be able to compare different algorithm for a problem with uncertainty.
  </li>
  
  <li>
  Design a tool for simulating different algorithm for problems with uncertainty.
  </li>
  </ul> </p></learning-outcomes>
  <end-product><p> A software tool to visualize and analyze algorithm with uncertainty. </p></end-product>
  <timetable><p> Reading of background material. </p>
  
  <p>
  Selection of the particular problem with uncertainty 
  </p>
  
  <p>
  Prototype for visualization of algorithms for the selected problem. 
  </p>
  <p>Implementing known algorithm. </p>
  <p>Design and implement new algorithm. </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="f297436521b3b804b1f7e373fb914509">
  <title>Automated Competition System</title>
  <supervisor>
    <mh55 />
  </supervisor>
  <hidden>hidden</hidden>
  <prerequisites><p>Good programming skills in Java. </p></prerequisites>
  <profiles><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>In the department we hold every year a programming competition for our first year students. This competition normally involves writing a computer player for a 'simple' board game. Over the past year I wrote each new competition from scratch. The aim of project is to create an automated competition system. This system will be used in the following way. Each new competition has to comply with the specification you determine. Students will be able to download a application version of the competition and create their own computer players. These can be uploaded via the system. Each uploaded computer will be dynamically added to the system. Via the competition system tournaments between the current available computer players can be played. As a result of the tournaments the strength, average time for a move and maximum time for a move will be determined. Also the competition system creates an applet where the user can play against the submitted computer players. </p></aims>
  <challenges><p>The challenges of this project can be found in the following areas<ul><li>Writing a detailed specification for new competitions</li><li>Dynamic imbedding of 3rd party code (e.g. the submitted computer player)</li><li>Secure execution of 3rd party code</li><li>Submission system with version control</li><li>Automatic creation of applets.</li> </ul> </p></challenges>
  <learning-outcomes><p>The student will: * carry out a detailed requirements analysis and specification of the problem. * learn about dynamic adding of classes in Java * learn about writing a detailed specification for further use of the system. </p></learning-outcomes>
  <end-product><p>The product of this project is automated competition system. </p></end-product>
  <timetable><p>* Detailed list of requirements. * Prototyping of needed components. (such as dynamic imbedding of new classes, secure execution of 3rd party classes) * Specifying the competition and computer player interfaces. * Implementing the system * Testing </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="cd8ea041be56f6f24e53bcd28751e272">
  <title>Flash Game Bloxorz clone</title>
  <supervisor>
    <mh55 />
  </supervisor>
  <hidden>hidden</hidden>
  <prerequisites><p>Flash Game Bloxorz clone </p></prerequisites>
  <profiles><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>Flash games became more and more popular in the past. Example of these games can be found at http://www.gamesoid.com/ The aim of this project to develop data exchanges for flush applitcations. This is achieved by write your own flash Bloxorz clone. For example users should be able to design their own level which then get uploaded for others to play. This is a link to the game bloxorz: http://www.gamesoid.com/free.asp?game=bloxorz </p></aims>
  <challenges><p>The challenges of this project can be found in the following areas<ul><li>a new programming language and environment</li><li>understanding the functionality and limitation of flash (ACtionScript)</li><li>build a robust software that can be used on our public web pages</li><li>establish additional data exchanges via other technologies, SQL database or perl.</li> </ul> </p></challenges>
  <learning-outcomes><p>The student will:<ul><li>learn about flash and ActionScript.</li><li>learn simple games design.</li><li>carry out a detailed requirements analysis and specification of the problem.</li><li>learn about security limitation for flash programs.</li><li>data exchanged in flash</li> </ul> </p></learning-outcomes>
  <end-product><p>The product of this project is Flash game. </p></end-product>
  <timetable><p>Familiarization of Flash and a new programming environment. Selection create a simple game design. Experimenting and prototyping techniques needed for the product. Implementing, testing and documenting the product. </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="0a0fb27813c01b1ef2a532ffa84b6aa5">
  <title>Go notation program</title>
  <supervisor>
    <mh55 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Good programming skills, a good understanding of databases, and some familiarity with game GO (Wei Chi). </p></prerequisites>
  <profiles><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>Go is an board game and has in Asia a similar status as chess in Europe. The aim of the project is to write a notation program for go. Each move should be recorded, together with comments and possible alternative move. </p></aims>
  <challenges><p>The challenges of this project can be found in the following areas<ul><li>Efficient structure of data</li><li>Design of efficient algorithm</li><li>Visualization of alternative moves</li><li>Finding similar situation in different recorded matched</li> </ul> </p></challenges>
  <learning-outcomes><p>The student will:<ul><li>carry out a detailed requirements analysis and specification of the problem.</li><li>produce an objected-oriented design of a software system to implement</li><li>learn about human computer interaction</li> </ul> </p></learning-outcomes>
  <end-product><p>The end product will be a go notation program. </p></end-product>
  <timetable><p>A detailed specification of the program. </p><p>Prototyping of the GUI and the board display. </p><p>Implement the specification and test the program </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="d40435d8e2485a749ead9111a2463230">
  <title>Graph colouring</title>
  <supervisor>
    <mh55 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Good understanding of algorithm. Good programming skills in either Java or C++. </p></prerequisites>
  <profiles><ACM/><ADS/><ASE/></profiles>
  <aims><p>A graph is a collection of nodes and collection of edges. You can think of a graph like a computer network, where a node is a computer or hub and each edge corresponds to a cable between two components. The colouring of graphs is a wide and interesting area. For example the task is to colour each node such that no two nodes with the same colour are connected by an edge; an algorithm could determine how many different colours are needed to complete the task for a given graph. Recently a tool for creating counter example for certain types of colouring has be developed in Leicester. The current tool produces very large counter example where actually smaller ones are available. The aim of this project to write a tool that firstly verifies that the previously found examples can not be colouring under certain condition. Finding smaller counter examples and representing the examples in a graphical form. </p></aims>
  <challenges><p>The challenges of this project can be found in the following areas Understanding the problem of graph colouring under certain conditions. Understanding recent research paper in that area. Representing graphs and their colouring inside a program Inventing new algorithms to find smaller counter examples. Implementation and visualisation of efficient algorithms </p></challenges>
  <learning-outcomes><p>The student will: Be able to discuss the problem of graph colouring. Be able to compare different approaches in that area. Design a tool for testing colouring of graphs. </p></learning-outcomes>
  <end-product><p>A software tool to test and create counter examples for graph colouring under certain conditions. </p></end-product>
  <timetable><p>Reading of background material. Selection of the data structure for the graph and colouring. Review the existing tool. Prototype for testing if a given colouring of a graph is valid. Present graphs and their colouring graphically Design and implementation of new algorithm. </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="f0884aad241bd9ae589bdd3762ee2ffa">
  <title>Scratch card Sudoku</title>
  <supervisor>
    <mh55 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p> Good programming skills. Knowledge about design and analysis of algorithms. Logical thinking and problem solving abilities.</p></prerequisites>
  <profiles><SFS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>Sudoku is popular puzzle game. In the traditional version the value of some cells of the 9x9 grid are given. The player need to fill in the remaining sell so that all constrains are satisfied. In the variant of the game no value of any cell is given. The player can 'scratch off' a cell to see the value of that cell. The aim for the player to complete the Sudoku with the least number of scratch of cells.
  </p>
  <p>
  The aim in this project is to create a program that allows a user to play this game. Create algorithms that can play the game, calculate the minimum number of cells that needed to scratched of to complete the Sudoku</p></aims>
  <challenges><p> Understand the setting of imprecise but request-able input data . Write a robust and functional software product. Design and analyze new algorithms. 
  </p></challenges>
  <learning-outcomes><p> The student will: * learn about the design and implementation of an original software project * learn about design and analysis of online algorithms * learn about uncertainty problems that are related to current research</p></learning-outcomes>
  <end-product><p> A scratch card Sudoku program. Analysis and evaluation of used algorithms.</p></end-product>
  <timetable><p> Creation of initial program with user interaction, but no algorithm</p>
  <p> 
  Learning about algorithms to solve traditional Sudokus.
  </p>
  
  <p> 
  Design, implement and analyze new algrithms</p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="c50f0bc4d056952fd931143ad543657a">
  <title>Sokoban solver</title>
  <supervisor>
    <mh55 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p> Good programming and problem solving skills</p></prerequisites>
  <profiles><SET/><SFS/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>Sokoban is an old puzzle games from the early 1980's. Over the years Sokoban was subject to some scientific research. Benchmarks and competition for Sokoban solver were established. </p><p>Some aspects of more modern puzzle games can be traced back to Sokoban. </p><p>The aim of the project is create a Sokoban clone and write your own Sokoban solver. </p><a href="http://en.wikipedia.org/wiki/Sokoban">wikipedia on Sokoban</a><a href="http://users.bentonrea.com/~sasquatch/sokoban/">collection of levels (Sasquatch)</a></aims>
  <challenges><p>The challenges in this project lie in:<ul><li>building a robust game</li><li>storing a game history to allow 'undos'</li><li>dealing with very large search space</li><li>problem analysis and problem solving</li> </ul> </p></challenges>
  <learning-outcomes><p>The student will learn about the complexity of algorithm, techniques to reduce a search space, solve problems in a systematic way </p></learning-outcomes>
  <end-product><p>A Sokoban clone with a build in solver </p></end-product>
  <timetable><p><ul><li>Analyzing required skills for the project</li><li>Gaining skills needed and write the Sokoban clone</li><li>reading about how to deal with large search spaces</li> 
  <li>creating simple solver</li><li>increase functionality to load in benchmark levels</li><li>improving the solver</li><li>analyzing and evaluating your findings</li>
  </ul> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="43f2b71a672d30472f394676a7a8efec">
  <title>A Map based faceted browser for Open street map data</title>
  <supervisor>
    <ms491 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Good programing and database design skills </p></prerequisites>
  <profiles><SET/><WAS/><ADS/><ASE/></profiles>
  <aims><p>OpenStreetMap is a free editable map of the whole world. The aim of this project is to build a faceted browser using maps and GIS using the map data from open street map. The data is a collection of nodes and ways. When the user selects a region in the map, the browser analyzes the descriptions of nodes and ways in that region and generates facets for filtering. Once a facet or a specific facet value has been selected, matching elements are displayed as markers on the map and in a list. If the selected region is changed, these are updated accordingly. </p></aims>
  <challenges><p>Analysing the data structure used for open street maps data, implementing the technique of faceted browsing, developing a browser interface. </p></challenges>
  <learning-outcomes><p>A good insight into developing faceted browsers using maps </p></learning-outcomes>
  <end-product><p>A map based faceted browser </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="af93505cba3bbc3a624c27283670c548">
  <title>A Protege 4 plugin for modelling Semantic web services</title>
  <supervisor>
    <ms491 />
  </supervisor>
  <hidden>Hidden</hidden>
  <prerequisites><p>Knowledge of Semantic web services, OWL-S, OWL 2.0, plugin development skills, good java programming skills </p></prerequisites>
  <profiles><WAS/><ADS/><ASE/></profiles>
  <aims><p>The aim of this project is to develop a plugin for Protege 4.0 to model Semantic web services described in OWL-S. The OWL-S specification will have to be extended using OWL 2.0 to be compatible with Protege 4.0 </p></aims>
  <challenges><p>Understanding OWL-S, OWL 2.0, Protege 4.0, Jena API </p></challenges>
  <learning-outcomes><p>knowledge of OWL-S, OWL 2.0, Protege 4.0 </p></learning-outcomes>
  <end-product><p>A protege plugin to model SWS using OWL-S </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="99aa3c7ff2b4429d7492b7d19965e065">
  <title>A Protege plugin for modelling Semantic web services</title>
  <supervisor>
    <ms491 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Knowledge of Semantic web services, OWL-S, OWL 2.0, plugin development skills, good java programming skills </p></prerequisites>
  <profiles><WAS/><ADS/><ASE/></profiles>
  <aims><p>The aim of this project is to develop a plugin for Protege to model Semantic web services described in OWL-S. The OWL-S specification of the profile, process and service models will be designed using the plugin. A case study would be provided to test the suitability of the plugin. </p></aims>
  <challenges><p>Implementing protege plugin for web services, designing the OWL-S profile, process and grounding models for the proposed case study, testing the plugin against the models  </p></challenges>
  <learning-outcomes><p>Exposure to plugin development using protege, an insight into developing semantic web services.  </p></learning-outcomes>
  <end-product><p>A protege plugin to model SWS using OWL-S </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="bb3f8ff5bddbdc290e844c36abbb9441">
  <title>A SPARQL editor as an Eclipse plugin</title>
  <supervisor>
    <ms491 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Good Java programming skills, familiarity with eclipse, Semantic web, SPARQL </p></prerequisites>
  <profiles><SET/><WAS/><ASE/></profiles>
  <aims><p>SPARQL is a query language for RDF/OWL. Most SPARQL queries are hand written or generated programmatically. The aim of this project is build a sparql editor as an eclipse plugin that allows the user to visually construct SPARQL queries. </p></aims>
  <challenges><p>eclipse plugin development, querying using the SPARQL language </p></challenges>
  <learning-outcomes><p>Eclipse plugin development, querying using  SPARQL </p></learning-outcomes>
  <end-product><p>An Eclipse- SPARQL plugin </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="0ed49c9b9eb7cb3e026db15dc876e5dd">
  <title>A Web 2 based interface for recording ontologies within the archaeological domain</title>
  <supervisor>
    <ms491 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>A good knowledge of web 2.0 tools and technologies, RDF/OWL 2.0, developing web based application and Protege, knowledge of web servers (Tomcat, Glassfish) </p></prerequisites>
  <profiles><WAS/><ADS/><ASE/></profiles>
  <aims><p>The aim of this project is to provide a web based interface that uses the OWL API provided by Protege as the business layer to store ontologies and record instances. Initial developments will focus on developing ontologies from the domain of arts. </p><p>The starting point is developing a representative ontology in coordination with domain experts from arts. The next step is to provide the user with a web based interface that has the capability to add as many properties and concepts as required. The interface should also allow updating the ontologies. It should be very similar to the interface provided by Protege as an application, however the reasoning and visualisation aspects can be omitted. Once the ontology is stored, the interface should allow making individuals and storing them within a separate namespace from the original ontology. A crucial aspect of this application will be its capability to run on a standalone server (localhost) as well as being available over the network. </p></aims>
  <challenges><p>Developing the representative ontology, understanding the protege API, understanding the dual nature of the availability for the application, developing a web based interface and a standalone version. </p></challenges>
  <learning-outcomes><p>Familiarity with the Protege API, understanding web servers, designing web based applications based on ontologies. </p></learning-outcomes>
  <end-product><p>An ontology for the domain of arts, A web based application for recording ontologies and instances, a standalone version of the application. </p></end-product>
  <timetable><p>Developing the ontology </p><p>Developing the application architecture </p><p>understanding the protege API </p><p>developing the web based application </p></timetable>
  <references></references>
</project>
<project label="4bbc117903436ef5836b7880765ed331">
  <title>A semantic web layer for open source geographical information system- JUMP</title>
  <supervisor>
    <ms491 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Good java programming skills, knowledge of semantic web </p></prerequisites>
  <profiles><SET/><WAS/><ADS/><ASE/></profiles>
  <aims><p>Geographical information systems are applications that generate/use digital maps and GIS data in various formats. The aim of this project is to develop a semantic web  module for an open source geographical information system, e.g., JUMP. Currently JUMP supports the GML markup language. The proposed module will allow users to provide GIS data  ta as RDF/OWL files. </p></aims>
  <challenges><p>Understanding GIS, developing the Semantic web layer </p></challenges>
  <learning-outcomes><p>A good understanding of GIS based system and semantic web technologies </p></learning-outcomes>
  <end-product><p>An RDF module for JUMP </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="2d34c5ff5e84807475ef1a449af20369">
  <title>A transformation framework from WSBPEL 2 to Timed Automata</title>
  <supervisor>
    <ms491 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>programming skills, WSBPEL familiarity </p></prerequisites>
  <profiles><SET/><WAS/><ADS/><ASE/></profiles>
  <aims><p>The aim of this project is to develop a framework for encoding WSBPEL specification into timed automata. WSBPEL specification is a language for service orchestration while timed automata is a formalism that is used to model real time specifications of web services. The framework proposed in the project will develop transformation rules for a subset of BPEL constructs that encode a service description into its timed automata counterpart. </p></aims>
  <challenges><p>reviewing Timed Automata, WSBPEL, implementing the framework </p></challenges>
  <learning-outcomes><p>modelling using Timed automata and  WSBPEL, implementation of rule frameworks </p></learning-outcomes>
  <end-product><p>A transformation framework </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="24c9e28e956645c69f3a2e829105e83d">
  <title>An integrated approach for populating Ontologies from Folksonomies</title>
  <supervisor>
    <ms491 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Knowledge of OWL 2.0, folksonomies, Mashups, good java programming skills, Protege 4.0 </p></prerequisites>
  <profiles><WAS/><ADS/><ASE/></profiles>
  <aims><p> With the rapid increase in Web 2.0 based social networking applications being developed and deployed, folksonomies are now widely used for tagging web pages, annotating pictures and classifying scholarly publications. Folksonomies are however limited in their expressivity. Since they are context independent and unstructured, they frequent suffer from inconsistencies and redundancies. Despite these limitations, they can be exploited in order to extend/populate ontologoies, which in turn can be used to suggest meaning ful tags to the users.
  
  The aim of this project is to develop a well integrated technique for generating ontologies from folksonomies.
  
  </p></aims>
  <challenges><p> 
  understanding social networks, folksonomies, ontologies, Web 2.0, OWL 2.0.
  Protege 4.0
  </p></challenges>
  <learning-outcomes><p> 
  An insight into folksonomies, A technique - semi automated that allows the generation of ontologies.
  </p></learning-outcomes>
  <end-product><p> An integrated technique for generating ontologies from Folksonomies.</p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="fdd08f3da317b517bfea393cc78be465">
  <title>An ontology based aquarium manager</title>
  <supervisor>
    <ms491 />
  </supervisor>
  <hidden>already taken</hidden>
  <prerequisites><p>An interest in aquatic life, Knowledge of RDF/OWL SPARQL and developing web based applications </p></prerequisites>
  <profiles><WAS/><ADS/></profiles>
  <aims><p>This project is for someone with an interest in marine life. The aim of this project is to develop an application that uses ontology based knowledge repositories from the marine and environmental domain to manage marine life in an aquarium. Aquatic (marine) life is difficult to breed because the conditions in an aquarium are too different from the natural conditions that induce spawning. The goal here is to use ontologies to suggest suitable breeding conditions (environmental controller) for marine life. This may also an effective solution to preserving endangered species. The first part of the project involves building the ontology based knowledge repositories. For a specific class of marine life (e.g. fishes breeding in lakes), properties of their natural environmental conditions such as </p><ul><li>water temperature</li><li>light</li><li>rainfall</li><li>water pH</li><li>water depth</li><li>water hardness</li><li>turbidity</li><li>water CO2 levels,</li><li>water O2 levels</li> </ul><p>should be recorded. For the marine life itself, interesting details for e.g.,<ul><li>category of the marine life,</li><li>biological details,</li><li>region where they can be found,</li><li>when the fish spawn,</li><li>the kind of food they consume,</li><li>environmental conditions</li> </ul>should be recorded. There has to be a clear mapping between the two ontologies that link the environmental conditions to the marine life and vice versa. Note that a marine life may belong to several categories, while certain environmental conditions may favour the breeding of some specific marine life. The second part of the project is to develop a web based system, which makes suggestion / answers questions about what possible environmental conditions of the tank may be set, for a new breed of marine life brought into the aquarium. The answers are provided by querying the ontologies using SPARQL. The ontologies can be further extended to include life threatening conditions for marine life. This may help provide explanation and possible solutions in the event of fatalities. </p></aims>
  <challenges><p>Understanding the domains, developing and validating the ontologies. Mapping between the two ontologies, developing the web based aquarium manager. </p></challenges>
  <learning-outcomes><p>An indepth understanding of knowledge engineering, ontology development, using ontology development tools, reasoners, developing semantic web applications </p></learning-outcomes>
  <end-product><p>Ontologies for the marine life and environmental conditions, web based aquarium manager </p></end-product>
  <timetable><p>Understand the domain, develop the ontologies, mapping between the ontologies, writing SPARQL queries, building the aquarium manager. </p><p> </p></timetable>
  <references>W3C documents on OWL, RDF, SPARQL</references>
</project>
<project label="2cc4587d51b99ff630ba43812ffd123c">
  <title>An ontology based collaborative application for managing aquariums</title>
  <supervisor>
    <ms491 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>An interest in aquatic life, Knowledge of OWL 2.0, reasoning techniques, semantic search and developing web based applications, good java programming skills </p></prerequisites>
  <profiles><WAS/><ADS/></profiles>
  <aims><p>This project is for someone with an interest in marine life. The aim of this project is to develop a collaborative application that uses ontology based knowledge repositories from the marine and environmental domain to manage marine life in an aquarium. Aquatic (marine) life is difficult to breed because the conditions in an aquarium are too different from the natural conditions that induce spawning. The goal here is to use ontologies to suggest suitable breeding conditions (environmental controller) for marine life. This may also an effective solution to preserving endangered species. The first part of the project involves building the ontology based knowledge repositories. For a specific class of marine life (e.g. fishes breeding in lakes), properties of their natural environmental conditions such as </p><ul><li>water temperature</li><li>light</li><li>rainfall</li><li>water pH</li><li>water depth</li><li>water hardness</li><li>turbidity</li><li>water CO2 levels,</li><li>water O2 levels</li> </ul><p>should be recorded. For the marine life itself, interesting details for e.g.,<ul><li>category of the marine life,</li><li>biological details,</li><li>region where they can be found,</li><li>when the fish spawn,</li><li>the kind of food they consume,</li><li>environmental conditions</li> </ul>should be recorded. There has to be a clear mapping between the two ontologies that link the environmental conditions to the marine life and vice versa. Note that a marine life may belong to several categories, while certain environmental conditions may favour the breeding of some specific marine life. The second part of the project is to develop a web based system, which makes suggestion / answers questions about what possible environmental conditions of the tank may be set, for a new breed of marine life brought into the aquarium. The answers are provided by querying the ontologies programmatically using the Protege-Jena API or OWL DL query language. The ontologies can be further extended to include life threatening conditions for marine life. This may help provide explanation and possible solutions in the event of fatalities. </p></aims>
  <challenges><p>Understanding the domains, developing and validating the ontologies. Mapping between the two ontologies, producing an API that other aquariums can extend and use, developing a web based interface for the aquarium manager. </p></challenges>
  <learning-outcomes><p>An indepth understanding of knowledge engineering, ontology development, using ontology development tools, reasoners, developing semantic web applications </p></learning-outcomes>
  <end-product><p>Ontologies for the marine life and environmental conditions, web based aquarium manager </p></end-product>
  <timetable><p>Understand the domain, develop the ontologies, mapping between the ontologies, writing SPARQL queries, building the aquarium manager. </p><p> </p></timetable>
  <references>W3C documents on OWL 2.0, OWL Manchester syntax (DL query language) </references>
</project>
<project label="91524e337a196f197941328561f9df55">
  <title>Compiling OWL-S specifications to MCMAS</title>
  <supervisor>
    <ms491 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p> Knowledge of semantic web services, multi agent systems, model checking, MCMAS</p></prerequisites>
  <profiles><WAS/><ADS/><ASE/></profiles>
  <aims><p> 
  OWL-S is a standard for describing semantic web services while   mcmas is a language to model multi agent systems. The aim of this project is to build a compiler that transforms OWL-S specification to mcmas models to be model checked using the model checker MCMAS
  </p></aims>
  <challenges><p> Understanding model checking, multi agent systems, OWL-S</p></challenges>
  <learning-outcomes><p> An insight into model checking of multi agent systesma dn web services</p></learning-outcomes>
  <end-product><p> A compiler that translates OWL-S service specifications into MCMAS </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="47f3d2808d4ff3f729e526fb8f0ff89f">
  <title>Composing Semantic Web Services using NeOn</title>
  <supervisor>
    <ms491 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Semantic web, ontologies semantic web services, Protege, OWL, RDF, OWL-S </p></prerequisites>
  <profiles><WAS/><ADS/><ASE/></profiles>
  <aims><p>The NeOn toolkit is a state-of-the-art, open source multi-platform ontology engineering environment, which aims to provide comprehensive support for all activities in the ontology engineering life-cycle. The toolkit is based on the Eclipse platform, a leading development environment. The aim of this project is to develop a NeOn plugin that allows composition of semantic web services, The plugin shoudl allow the desgin of profile, process and grounding models for a web service. It should allow the user to define the data flow and control flow for the service. </p></aims>
  <challenges><p>Understanding NeOn, service composition </p></challenges>
  <learning-outcomes><p>A good grasp on programming plugins, a good understanding of SWS and ontologies </p></learning-outcomes>
  <end-product><p>A NeOn plugin </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="547e0868fa1e9cd69fd306842352aeef">
  <title>Developing a web based interface for storing ontologies and recording instances using Protege API</title>
  <supervisor>
    <ms491 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>A good knowledge of RDF/OWL, SPARQL, developing web based application and Protege, knowledge of web servers (Tomcat, Glassfish) </p></prerequisites>
  <profiles><WAS/><ADS/><ASE/></profiles>
  <aims><p>The aim of this project is to provide a web based interface that uses the OWL API provided by Protege as the business layer to store ontologies and record instances. Initial developments will focus on developing ontologies from the domain of arts. </p><p>The starting point is developing a representative ontology in coordination with domain experts from arts. The next step is to provide the user with a web based interface that has the capability to add as many properties and concepts as required. The interface should also allow updating the ontologies. It should be very similar to the interface provided by Protege as an application, however the reasoning and visualisation aspects can be omitted. Once the ontology is stored, the interface should allow making individuals and storing them within a separate namespace from the original ontology. A crucial aspect of this application will be its capability to run on a standalone server (localhost) as well as being available over the network. </p></aims>
  <challenges><p>Developing the representative ontology,  reviewing the protege API, illustrate  the dual nature of the availability for the application, developing a web based interface and a standalone version. </p></challenges>
  <learning-outcomes><p>Familiarity with the Protege API, designing web based applications based on ontologies. </p></learning-outcomes>
  <end-product><p>An ontology for the domain of arts, A web based application for recording ontologies and instances, a standalone version of the application. </p></end-product>
  <timetable><p>Developing the ontology </p><p>Developing the application architecture </p><p>understanding the protege API </p><p>developing the web based application </p></timetable>
  <references></references>
</project>
<project label="1357b095761a86053c0594156f59fa86">
  <title>From SKOS vocabularies to OWL ontologies for archaeological domains using SKOS2GenTax</title>
  <supervisor>
    <ms491 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>An interest in archaeology, working knowledge of developing ontologies, RDF, OWL, Protege tool for modelling ontologies. </p></prerequisites>
  <profiles><WAS/><ADS/></profiles>
  <aims><p>Knowledge organisation systems, such as taxonomies, thesauri or subject heading lists, play a fundamental role in information structuring and access. The Simple Knowledge Organization System(SKOS) is a common data model for knowledge organization systems. Using SKOS, a knowledge organization system can be expressed as machine-readable data. It can then be exchanged between computer applications and published in a machine-readable format in the Web. The aim of this project is to represent Thesauri deveolped by English Heritage for the archaeological domain as SKOS vocabularies, and then converting the hierarchical classifications defined in SKOS as RDF-S or OWL ontologies using the SKOS2GenTax online tool. </p></aims>
  <challenges><p>Understanding the domain, understanding how thesauri is conventionally documented, converting the thesauri to SKOS, understanding SKOS and SKOS2GenTax </p></challenges>
  <learning-outcomes><p>A good understanding of semantic web technologies such as SKOS, RDF, OWL, A good knowledge of building sW applications </p></learning-outcomes>
  <end-product><p>A thesauri developed in SKOS, the thesauri transformed to OWL. Both of these can be used in departmental projects </p></end-product>
  <timetable><p>understanding the domain </p><p>understanding the structure of a thesauri </p><p>understanding SKOS </p>,<p>building the thesauri in SKOS using a SKOS editor or Protege </p><p>understanding SKOS2GenTax tool </p>converting the SKOS thesauri to OWl using the tool.</timetable>
  <references><reference>
  <note>http://www.w3.org/2004/02/skos/</note>
  </reference></references>
</project>
<project label="ac84bcd9f184a6de6a0d65ae4ee8f9ec">
  <title>Migration - from Legacy Relation DB to Ontology-based DB</title>
  <supervisor>
    <ms491 />
  </supervisor>
  <hidden>already taken</hidden>
  <prerequisites><p>Good knowledge on relation database and SQL Semantic web, ontology languages (RDF/OWL), Knowledge of web service </p></prerequisites>
  <profiles><WAS/><ADS/><ASE/></profiles>
  <aims><p>The aim of this MSc project is to design a simplify archaeological ontology for existing archaeological databases (usually MS Access *.mdb) from different research team, migrate and integrate these legacy databases to a centralised ontology-based repository that allows query, backup and further reasoning though web service interface. </p></aims>
  <challenges><p><ul><li>Understanding of domain-specific ontology and representation in ontology language.</li><li>Understanding of relation database and ontology-based repository.</li><li>Database schema migration and automatic data transfer. Use of ontology query language and reasoner.</li><li>Use of web service interface for data manipulation. Learning Outcomes</li> </ul> </p></challenges>
  <learning-outcomes><p><ul><li>Create well-designed domain-specific ontology.</li><li>Create ontology-based repository.</li><li>Analyse existing relation database and migrate to ontology-based database.</li><li>Access to ontology-based repository through web service interface.</li> </ul> </p></learning-outcomes>
  <end-product><p>An ontology-based repository and corresponding SOAP query interface (using SPARQL). </p></end-product>
  <timetable><p>Collect and analyse existing archaeological database </p><p>Study basic archaeological concept, design and implement a simple archaeological ontology. </p><p>Create ontology-based repository and migrate existing data. </p><p>Create web service interface for the repository. </p></timetable>
  <references><reference>
  <note>OWL Specification http://www.w3.org/TR/owl-features,</note>
  <note>RDF Specification http://www.w3.org/RDF/</note>
  </reference></references>
</project>
<project label="16dda615274348c14b56bf540caaaf2b">
  <title>RESTful web services for vocabularies represented in SKOS Core Vocabulary</title>
  <supervisor>
    <ms491 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Good java programming skills, Knowledge of semantic web technologies, protege OWL-API </p></prerequisites>
  <profiles><SET/><WAS/><ADS/><ASE/></profiles>
  <aims><p>Simple Knowledge Organization System—provides a model for expressing the basic structure and content of concept schemes such as thesauri, classification schemes, subject heading lists, taxonomies, folksonomies, and other similar types of controlled vocabulary. As an application of the Resource Description Framework (RDF), SKOS allows concepts to be composed and published on the World Wide Web, linked with data on the Web and integrated into other concept schemes. Representational State Transfer (REST) is a style of software architecture for distributed hypermedia systems such as the World Wide Web. The aim of this project is to implement RESTful web services for vocabularies represented in SKOS Core Vocabulary. The vocabularies would be provided as text files or web based resources. The project involves modelling the vocabularies in SKOS and developing RESTful APIs for accessing the vocabularies. </p></aims>
  <challenges><p>Implementing RESTful web services, modelling vocabularies using the SKOS ontology, implementing knowledge representation systems </p></challenges>
  <learning-outcomes><p>Show the application of REST and SKOS to solve the problem of modelling domain vocabularies.</p></learning-outcomes>
  <end-product><p>RESTful web services for accessing vocabularies represented in SKOS Core Vocabulary </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="dbf02d95133e1018e2da5fb3d21352f2">
  <title>Resolving database heterogeneity through Ontology mapping for Archaeology</title>
  <supervisor>
    <ms491 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Databases, good Java programming skills, Semantic web, ontologies, Protege  </p></prerequisites>
  <profiles><WAS/><ADS/><ASE/></profiles>
  <aims><p> The aim of this project is to develop a semantic search engine that queries heterogeneous databases linked together through the CIDOC CRM ontology for  Archaeological data sets.</p></aims>
  <challenges><p>Understanding the Archaeology domain, understanding CIDOC CRM, developing a search engine</p></challenges>
  <learning-outcomes><p> Understanding the Archaeology domain, understanding CIDOC CRM, developing a search engine</p></learning-outcomes>
  <end-product><p> Ontologies, A search engine</p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="16507e268dcc934101a26132933fe420">
  <title>Semantic Web services for UK goverment data</title>
  <supervisor>
    <ms491 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>A good understanding of RESTful web services, semantic web technologies </p></prerequisites>
  <profiles><SET/><WAS/><ADS/><ASE/></profiles>
  <aims><p>The UK Goverment has provided a large number of public datasets which are accessible via data.gov.uk. A lot of these datasets are available in RDF. Representational State Transfer (REST) is a style of software architecture for distributed hypermedia systems such as the World Wide Web. The aim of this project is to provide web services along with REST based APIs for accessing some of the RDF linked data sets provided at www.data.gov.uk. Students are free to choose a dataset of their choice, provided there is sufficient data available to check the web service. </p></aims>
  <challenges><p>Implementing linked data, using REST APIs such as jersey for developing RESTful web services, implementing the web services, developing APIs </p></challenges>
  <learning-outcomes><p>implementing linked data, developing services using REST APIS </p></learning-outcomes>
  <end-product><p>A REST based API </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="84659967051b7a4333bdc2ab396ae389">
  <title>Semantic search across multilingual thesauri in the archealogical domain</title>
  <supervisor>
    <ms491 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>A good understanding of Semantic web technologies, a working knowledge of developing search based applications </p></prerequisites>
  <profiles><WAS/><ADS/></profiles>
  <aims><p>The application uses thesauri written in the SKOS representation model. The tool shall provide a semantic search service that makes use of mapped thesauri to allow user to use any terminology in any of the languages the thesauri are available and retrieve information from resources which may have been indexed by one of the mapped vocabularies. This is thus an application that consumes a SKOS vocabulary and uses it to provide some service or functionality to the user -- in this case search across thesauri. </p></aims>
  <challenges><p>modelling SKOS vocabularies, researching thesauri available for a specific concept in different languages, developing the mapping between the SKOSvocabularies, implementing the semantic search engine </p></challenges>
  <learning-outcomes><p> model vocabularies, implement a search engine</p></learning-outcomes>
  <end-product><p>A semantic search engine for SKOS vocabularies </p></end-product>
  <timetable><p>understanding the domain </p><p>understanding the structure of a thesauri </p><p>understanding SKOS </p>,<p>building the thesauri in SKOS using a SKOS editor or Protege </p><p>Implementing the search engine. </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <note>http://www.w3.org/2004/02/skos/</note>
  ,<note>http://thesaurus.english-heritage.org.uk/frequentuser.htm</note>
  </reference></references>
</project>
<project label="f45887207cd4eccd6287c276e219e821">
  <title>Skosifying the Spectrum terminologies from the Collections trust</title>
  <supervisor>
    <ms491 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Knowledge of SKOS, RDF, protege Jena API, good java programming skills </p></prerequisites>
  <profiles><WAS/><ADS/><ASE/></profiles>
  <aims><p>SPECTRUM is the UK and international standard for Collections Management relating to artifacts in museums and art galleries. SPECTRUM provides terminology for museums workers and collection management software suppliers. The aim of this project is to produce SKOS models of some of the terminologies used in SPECTRUM and build an API of semantic web services that allows users to search over the collection data. </p></aims>
  <challenges><p>Learning SKOS, modelling the domain, defining a schema for  spectrum, implementing semantic web services </p></challenges>
  <learning-outcomes><p>design vocabularies using SKOS, implement semantic web services </p></learning-outcomes>
  <end-product><p>SKOS models for SPECTRUM terminology, semantic web service APIs to query the SKOS models </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="07de6b393bff38f7282a0dd4d970e90b">
  <title>Using the GoodRelations ontology: Semantic web services for opticians</title>
  <supervisor>
    <ms491 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Knowledge of semantic web technologies and tools, good programming skills </p></prerequisites>
  <profiles><SET/><WAS/><ADS/><ASE/></profiles>
  <aims><p>GoodRelations is a standardized vocabulary for product, price, and company data that can (1) be embedded into existing static and dynamic Web pages and that (2) can be processed by other computers. This increases the visibility of products and services in the latest generation of search engines, recommender systems, and other novel applications. The aim of this project is to develop semantic web services for opticians using the GoodRelations ontology. The project involves developing ontology instances of the GooDRelationsOntology for opticians and incorporating the descriptions in the OWL-S ontology for an optician web service. </p></aims>
  <challenges><p>Assess the suitability of the GoodRelations ontology for application to the domain of opticians, create instances of the ontology and integrate it with OWL-S service description for the service, implementing OWL-S based semantic web services </p></challenges>
  <learning-outcomes><p>An insight into how GoodRelations can be used in practice for e-commerce applications, implementing OWL-S semantic web services. </p></learning-outcomes>
  <end-product><p>Semantic web services developed in OWL-S using the good relations ontology for opticians </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="1bf8a6ecc7734b6ba4fbf9ba9e2391b2">
  <title>A Tool for Ontology Engineering</title>
  <supervisor>
    <ps56 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Interest in Ontology Engineering </p><p>Semantic Web: RDF/OWL </p><p>Excellent programming skills in Java. </p></prerequisites>
  <profiles><WAS/><ADS/></profiles>
  <aims>Ontology engineering in computer science and information science is a new field, which studies the methods and methodologies for building ontologies: formal representations of a set of concepts within a domain and the relationships between those concepts. The aim of this project is to develop a tool for Ontology Engineering. The tool will be based on a particular method.</aims>
  <challenges><p>Understanding a method for Ontology Engineering </p><p>Understanding the Protege API </p></challenges>
  <learning-outcomes><p>Learning the method for Ontology Engineering </p><p>Familiarity with the Protege API </p></learning-outcomes>
  <end-product><p>A plug-in for Protege 4.0 to assist building ontologies. </p></end-product>
  <timetable><p>Learning the Protege API </p><p>Understanding the method </p><p>Developing the tool as a Protege plug-in </p></timetable>
  <references><reference>
  <author>Ontology Engineering</author>
  <note><a href="http://en.wikipedia.org/wiki/Ontology_engineering">Definition from Wikipedia.</a></note>
  </reference><reference>
  <author>Protege Plug-ins</author>
  <published year="2010"></published>
  <note><a href="http://protege.stanford.edu/download/plugins.html">Protege Plug-ins Website.</a></note>
  </reference><reference>
  <author>Protege OWL-API</author>
  <note><a href="http://protege.stanford.edu/plugins/owl/api/">Open-source Java library for the Web Ontology Language and RDF(S).</a></note>
  </reference><reference>
  <author>OWL 2</author>
  <note><a href="http://www.w3.org/TR/2009/WD-owl2-overview-20090421/#Relationship_to_OWL_1">OWL 2 Web Ontology Language Document Overview</a></note>
  </reference></references>
</project>
<project label="46880de86796b3b1cf74fe496e0768b4">
  <title>Semantic Web for Birding</title>
  <supervisor>
    <ps56 />
  </supervisor>
  <hidden>work in progress</hidden>
  <prerequisites><p>Semantic Web: RDF/OWL </p><p>Excellent programming skills in Java. </p><p>Interest in Birds </p></prerequisites>
  <profiles><WAS/><ADS/></profiles>
  <aims>Birdwatching or birding is the observation and study of birds with the naked eye or through a visual enhancement device like binoculars. The aim of this project is to develop an application that uses ontology based knowledge repositories from the Bird domain to identify bird species.</aims>
  <challenges><p>Understanding the Bird Domain. </p><p>Modelling the information used to characterize bird species in ontologies. </p><p>Understanding the Protege API. </p></challenges>
  <learning-outcomes><p>Familiarity with the Protege API </p></learning-outcomes>
  <end-product><p>A Web Identifier of Bird Species. </p></end-product>
  <timetable></timetable>
  <references><reference>
  <author>OWL 2</author>
  <note><a href="http://www.w3.org/TR/2009/WD-owl2-overview-20090421/#Relationship_to_OWL_1">OWL 2 Web Ontology Language Document Overview</a></note>
  </reference><reference>
  <author>Protege OWL-API</author>
  <note><a href="http://protege.stanford.edu/plugins/owl/api/">open-source Java library for the Web Ontology Language and RDF(S).</a></note>
  </reference>
  <reference>
  <author>Bird Species </author>
  <note><a href="http://www.avianweb.com/birdindex.htm">
  A guide to Bird Species.</a></note>
  </reference>
  </references>
</project>
<project label="e6cb1d9d644f901e82454581efd0beee">
  <title>Web Gallery of Paintings</title>
  <supervisor>
    <ps56 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Excellent programming skills in Java. </p><p>Semantic Web: RDF/OWL, SPARQL </p><p>Web Technologies: how to develop web based applications, web servers (Tomcat, Glassfish) </p></prerequisites>
  <profiles><WAS/><ADS/></profiles>
  <aims><p>The Web Gallery of Altarpieces will be a virtual museum of altarpieces. An altarpiece is a painting located behind the altar of churches or temples (See References Below). This is part of a larger project between the School of Arts and the Computer Science Department at the University of Leicester. The database for the collection of altarpieces is already provided in the Ontology of Altarpieces (see References Below). </p><p>In this project the student will have to develop a web based interface for doing queries over the existing Ontology of Altarpieces. The new interface will differ from SPARQL in two important points:1) It will be more friendly and addressed to the art specialists. 2) It will have the capabilty of realizing queries that are not possible in SPARQL. The new interface will also differ from existing virtual museums because it will be able to perform more sophisticated queries than an Advanced Search. </p><p>A crucial aspect of this application will be its capability to run on a standalone server (localhost) as well as being available over the network. </p></aims>
  <challenges><p>Understanding the Protege API, understanding how to do queries from an ontology using the Protege API </p><p>Developing a web based interface and a standalone version. </p></challenges>
  <learning-outcomes><p>Familiarity with the Protege API, understanding web servers, designing web applications based on ontologies. </p></learning-outcomes>
  <end-product><p>A web based application for doing queries over the existing Ontology of Altarpieces, a standalone version of the application. </p></end-product>
  <timetable><p>Understanding the Ontology of Altarpieces. </p><p>Create structure of web pages. </p><p>Understanding the protege API. </p><p>Developing the web based application. </p></timetable>
  <references><reference>
  <author>David Ekserdijan and Paula Severi</author>
  <volume>Technical Report</volume>
  <published year="2009">Ontology of Altarpieces</published>
  </reference><reference>
  <author>An example of Altarpiece</author>
  <published year="1514">Sistine Madonna by Raphael.</published>
  <note><a href="http://en.wikipedia.org/wiki/Sistine_Madonna">Click here to see it.</a></note>
  </reference><reference>
  <author>Examples of Virtual Museums</author>
  <note><a href="http://www.wga.hu/">The Web Gallery of Art.</a></note>
  <note><a href="http://www.nationalgallery.org.uk/">The National Gallery in London</a></note>
  </reference></references>
</project>
<project label="9138a45e6d75d3cb13e1af81411cf3c8">
  <title>A Timetable Management Tool</title>
  <supervisor>
    <pyf1 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Programming skills in web technologies. </p></prerequisites>
  <profiles><SET/><WAS/><ACM/><ASE/></profiles>
  <aims><p>Every year the departmental timetable officer produces the department's timetable for the next academic year. One of the most problematic aspects is to keep track of a variety of different constraints, with some arriving <i>very</i> late, and thus there is a need for easily updating the timetable to satisfy these new constraints (and at the same time not violating other existing constraints). </p><p>The aim of this project is to develop a timetabling system to serve this purpose. It will be based on the product of a previous project, which supports updating the timetable by dragging items in a grid view, in a Google-calendar-like way. However, for a number of reasons, it is not completely satisfactory and cannot be put to real use, and further development is needed. Some software re-engineering techniques might therefore be useful. </p><p>The software <b>must</b> implement exactly what the client (the departmental timetable officer) wants; success of the project will be judged by to what extent the timetable officer (and possibly other users) is satisfied. </p><p>It is impossible to list all requirements beforehand - in fact this is part of the project, and the software should be developed in an "agile" way to satisfy this - but it includes at least the following: </p><ol><li>constraint checking (both "responsive mode", i.e. immediately after a change is made, and "batch mode", i.e. check the entire database);</li><li>handling recurring and non-recurring events properly;</li><li>interface to the <a href="https://campus.cs.le.ac.uk/ForStudents/labTimTables">department's Google calendar account</a>;</li><li>works on the department's computing platform.</li></ol><p>A warning to potential students: this project is different from what you may think as a "typical" timetable project; if you googled "timetable project" and come up with a few keywords and think you know what this is, then it is more likely that you got it wrong. In particular, we are not looking at producing a timetable automatically. </p></aims>
  <challenges><p>Capture complicated, sometimes ambiguous, user requirements; deal with evolving requirements; use of advanced web technologies. </p></challenges>
  <learning-outcomes><p>Successful completion of the project should provide student with skills and experience in using advanced web technologies in a real-life scenario, and the software engineering experience in dealing with evolving requirements and flexible software development. </p></learning-outcomes>
  <end-product><p>A web-based software system for managing the departmental timetable. </p></end-product>
  <timetable><p>Learn relevant web technologies; understand functionalities and limitations of existing system; capture new requirements; software system modelling and design; implementation and testing; go back to step 3. </p></timetable>
  <references></references>
</project>
<project label="ca4c18d7c15997ac24b46ab3a5aea59e">
  <title>AdSense and Generalized Online Matching</title>
  <supervisor>
    <pyf1 />
  </supervisor>
  <hidden>Taken in Summer 2009</hidden>
  <prerequisites><p>Programming skills in web-based languages. Basic knowledge in algorithms as in CO7002 or equivalent would be helpful. </p></prerequisites>
  <profiles><WAS/><ACM/></profiles>
  <aims><p>Search engine companies like Google display "relevant" adverts to users based on queries they typed in. Typically, each advertiser has a budget and a list of keywords they are interested in placing their ads to. How does the company maximize the profit of selling ad space? This can be modelled as an online bipartite matching problem. </p><p>The aim of the project is to create a web-based system that simulates such a system. The web-based front end of the system should accept queries from users; accepts adverts and "bids" from advertisers; and diplay matched ad(s) to each query. Such matching is done at the back-end by implementing some existing algorithms in the literature. It should also keep a log of such data. The performance of these algorithms should be evaluated by experimental simulation, and should be compared against their theoretical competitive analysis results. </p></aims>
  <challenges><ul><li>Understanding of a research work in a new research area.</li><li>Implementation of algorithms.</li> </ul></challenges>
  <learning-outcomes><ul><li>Understanding of search engine advertising as an online matching problem, and understanding of some algorithms for solving this problem.</li><li>Programming ability in implementation of such algorithms.</li><li>Skills in performing empirical evaluation of algorithms.</li> </ul></learning-outcomes>
  <end-product><p>A web-based system for adverts matching. </p></end-product>
  <timetable><p>Month 1: Background research. </p><p>Month 2: Design and implementation of system. </p><p>Month 3: Evaluation of algorithms. </p></timetable>
  <references><reference>
  <author>A. Metha et al.</author>
  <volume>AdWords and Generalized Online Matching</volume>
  <published year="2007">Journal of the ACM 54(5)</published>
  <note></note>
  </reference></references>
</project>
<project label="256650ac74961beb5a74ece97ffb8cd2">
  <title>An Automatic Cryptanalysis Tool for Secret Key Ciphers</title>
  <supervisor>
    <pyf1 />
  </supervisor>
  <hidden>Taken in Summer 2009</hidden>
  <prerequisites><p>Programming skills in C++/Java. Having taken CO7099 is desirable but not essential. </p></prerequisites>
  <profiles><SFS/><ACM/><ASE/></profiles>
  <aims><p>Cryptography is the study of secret writing. There are many methods to encrypt data, with varying degree of security. Cryptanalysis concerns the breaking of these ciphers by exploiting the mathematical or statistical patterns of the encrypted message. For example, the well-known Vigenere cipher can be broken by studying the frequency of each of the letters in the ciphertext. Various statistical tests can also help to determine the ciphers or keys being used. </p><p>The aim of the project is to produce a software using C++/Java which automatically (without user intervention) recover an encrypted message as accurately as possible, without necessarily knowing the ciphers used. The ciphers to be considered are likely to be classical substitution and transposition ciphers like Vigenere and Hill cipher. </p></aims>
  <challenges><p>Research into and implementation of cryptanalysis algorithms. </p></challenges>
  <learning-outcomes><p><ul><li>Understanding of secret key cryptography algorithms and techniques of cryptanalysis.</li><li>Skills and practice of designing and implementing a large-scale software system following an established software engineering process.</li> </ul> </p></learning-outcomes>
  <end-product><p>A software package for analysing ciphertext for a number of ciphers using different tests and tools. </p></end-product>
  <timetable><p>Month 1: Research into cryptanalysis. </p><p>Month 2: Design and implementation of system. </p><p>Month 3: Implementation and testing. </p></timetable>
  <references><reference>
  <author>W. Stallings</author>
  <volume>Cryptography and Network Security. Prentice Hall</volume>
  <published year="2006"></published>
  <note>(Chapter 2)</note>
  </reference><reference>
  <author>S. Singh</author>
  <volume>The Code Book</volume>
  <published year="1999"></published>
  <note></note>
  </reference></references>
</project>
<project label="b9e5bfb6cbece8b5433961db1594a920">
  <title>An Interactive Cryptanalysis Tool for Secret Key Ciphers</title>
  <supervisor>
    <pyf1 />
  </supervisor>
  <hidden>Taken in Spring 2010</hidden>
  <prerequisites><p>Programming skills in C++/Java or web-based languages. Having taken CO7099 is desirable but not essential. </p></prerequisites>
  <profiles><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>Cryptography is the study of secret writing. There are many methods to encrypt data, with varying degree of security. Cryptanalysis concerns the breaking of these ciphers by exploiting the mathematical or statistical patterns of the encrypted message. For example, the well-known Vigenere cipher can be broken by studying the frequency of each of the letters in the ciphertext. Various statistical tests can also help to determine the ciphers or keys being used. </p><p>The aim of the project is to produce a software, either stand-alone or web-based, which recover an encrypted message, without necessarily knowing the ciphers used. If the amount of ciphertext is too little or it has unusual statistical patterns, it is very difficult to recover the message correctly automatically; hence, the system aims to work interactively with the user by providing the ability to perform dictionary search, pattern matching, computation of statistical data, etc., and allowing the user to iteratively make informed guesses to break the cipher. The ciphers to be considered are likely to be classical substitution and transposition ciphers like Vigenere. </p></aims>
  <challenges><p>Research into and implementation of cryptanalysis algorithms. </p></challenges>
  <learning-outcomes><p>Successful completion of the project will give students a good understanding of secret key cryptography algorithms and techniques of cryptanalysis. Students will also develop skills in designing and implementing a large-scale software system using an established software engineering process. </p></learning-outcomes>
  <end-product><p>A software package for analysing ciphertext for a number of ciphers using different tests and tools. </p></end-product>
  <timetable><p>Month 1: Research into cryptanalysis. </p><p>Month 2: Design and implementation of system. </p><p>Month 3: Implementation and testing. </p></timetable>
  <references><reference>
  <author>W. Stallings</author>
  <volume>Cryptography and Network Security. Prentice Hall</volume>
  <published year="2006"></published>
  <note>(Chapter 2)</note>
  </reference><reference>
  <author>S. Singh</author>
  <volume>The Code Book</volume>
  <published year="1999"></published>
  <note></note>
  </reference></references>
</project>
<project label="7d277e5d8106631c97b7af1e2c1ea255">
  <title>Data structures for geometric search</title>
  <supervisor>
    <pyf1 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Programming skills in C++/Java or some web-based language. </p><p>Basic understanding of algorithms. </p></prerequisites>
  <profiles><WAS/><ACM/><ASE/></profiles>
  <aims><p>Geometric range search problems are problems of the following form: given n points in a e.g. two-dimensional plane, which points (or just how many of them) lie inside a given query range (e.g. a rectangle)? Frequently there are a large number of relatively static points and a large number of different queries, thus it is better to preprocess the input data into some data structure so that the querying can be done quickly. In higher dimensions, this has applications in, for example, database query where each attribute can be represented as a dimension ("List all people aged between 20 and 39, with salary above 20K, have been with the company for less than 2 years, and...") </p><p>Many algorithms and data structures exist in the literature for these problems. The aim of this project is to implement some of these algorithms and to visualise how they work. </p></aims>
  <challenges><p>To understand some algorithms in computational geometry and to implement them. </p></challenges>
  <learning-outcomes><p>Successful completion of the project should give students a good understanding of the algorithms and issues in geometric data structures and algorithms, and the ability to implement these algorithms. </p></learning-outcomes>
  <end-product><p>A software which implements some range searching algorithms which shows not only the final output of a query but also how preprocessing and search are done. </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author>M. de Berg et al</author>
  <volume>Computational geometry: algorithms and applications</volume>
  <published year="1997"></published>
  <note></note>
  </reference></references>
</project>
<project label="aa50b333a96b9a20c548110449eaac41">
  <title>Haplotype Inference on Pedigrees</title>
  <supervisor>
    <pyf1 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Strong programming skills in C++/Java. An interest in bioinformatics. Knowledge in algorithms as given in CO7002 or equivalent. </p></prerequisites>
  <profiles><ACM/><ASE/></profiles>
  <aims><p>The modeling of human genetic variation is critical to the understanding of the genetic basis for complex diseases. <i>Single nucleotide polymorphisms</i>(SNPs) are the most frequent form of this variation, and it is useful to analyze <i>haplotypes</i>, which are sequences of linked SNP genetic markers (small segments of DNA) on a single chromosome. In diploid organisms, such as humans, chromosomes come in pairs, and experiments often yield <i>genotypes</i>, which blend haplotypes for the chromosome pair. This gives rise to the problem of inferring haplotypes from genotypes. For example, assume there are two markers 0 and 1, and the genotype of an individual is 0*1**, where * denotes a mixture of different types. Then his pair of haplotypes can be {00100, 01111}, or perhaps {00101, 01100}, or others. </p><p>There are many possibilities if we consider only one individual. In our case, we are given a pedigree (family tree) with genotype information. Since the pedigrees are passed from parents to offsprings, we can use this extra information to determine the precise haplotypes. Cubic-time as well as linear-time algoithms have been derived. </p><p>There are various directions to this project: (1) one can implement the algorithms for deducing haplotype from genotype information of a pedigree; or (2) one can implement an educational tool that visualises how haplotypes are passed along a pedigree; or (3) one can implement a "game" so that "players" fill in these haplotypes. Note that for (1) the algorithms are fairly complex and involve either elaborate graph traversals or solving systems of linear equations; for (2) and (3) some tree drawing algorithms probably need to be investigated; and mutations and recombinations should be considered for (2) to make it more interesting. </p></aims>
  <challenges><p><ul><li>Understanding of a current research problem.</li><li>Implementation of sophisticated algorithms.</li> </ul> </p></challenges>
  <learning-outcomes><p><ul><li>Understanding of an important research problem in bioinformatics and the algorithms to solve it.</li><li>Be able to implement sophisticated algorithms using appropriate data structures and coding techniques to produce efficient programs.</li> </ul> </p></learning-outcomes>
  <end-product><p>A software package for inferring haplotype information from given genotype information in a pedigree. </p></end-product>
  <timetable><p>Research on algorithms; design of system; implementation and testing of system. </p></timetable>
  <references><reference>
  <author>J. Li and T. Jiang</author>
  <article>Efficient rule-based haplotyping algorithms for pedigree data</article>
  <volume>RECOMB</volume>
  <published year="2003"></published>
  <note></note>
  </reference><reference>
  <author>W.-T. Chan et al.</author>
  <article>Linear-Time Haplotype Inference on Pedigrees without Recombination</article>
  <volume>SIAM J. Computing 38(6)</volume>
  <published year="2008"></published>
  </reference></references>
</project>
<project label="59c9a325c7d3462d80f5bcd810e11cc3">
  <title>Online Algorithms as Games</title>
  <supervisor>
    <pyf1 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Programming skills in Java/C++ or web-based languages. An interest in algorithms. Haven taken CO7002 is desirable but not essential. </p></prerequisites>
  <profiles><WAS/><ACM/><ASE/></profiles>
  <aims><p>Online algorithms deal with problems with unknown future inputs and decisions have to be made irrevocably.  For example, in the game of Tetris, players need to decide how to place the tiles without knowing what will come later. Such problems can be considered as a game between a "player" (the online algorithm) and an "adversary" (an entity who knows the entire input sequence and can therefore construct the best solution; equivalently it is the one who generates input sequences to make the player's outcome as bad as possible). Thus, it is natural to consider these problems as games. Many such problems have been studied; a few examples include bin packing, caching, load balancing, etc. </p><p>The aim of the project is to study some chosen online problem(s), and implement some online or offline algorithms for these problems in the form of a game. For example, a human player can compete with a known online algorithm for the same input sequence generated by some adversary. The problems/algorithms chosen should have a sufficient level of complexity, and the game implemented should be fun to play. </p></aims>
  <challenges><ul><li>Research the literature on various online problems.</li><li>Implementation of some online algorithms as a game with a suitable user interface.</li> </ul></challenges>
  <learning-outcomes><ul><li>Understanding of online algorithms and their performance analysis.</li><li>Skills in implementation of some non-trivial algorithms.</li> </ul></learning-outcomes>
  <end-product><p>A software package for online algorithms as games. </p></end-product>
  <timetable><p>Month 1: Research on the literature of online algorithms; select problems and algorithms. </p><p>Month 2: Design of system; a prototype showing GUI and basic functionalities; implementation of algorithms. </p><p>Month 3: Implementation and testing of system. </p></timetable>
  <references><reference>
  <author>A. Borodin and R. El-Yaniv</author>
  <volume>Online computation and competitive analysis</volume>
  <published year="1998">Cambridge University Press</published>
  <note></note>
  </reference></references>
</project>
<project label="9da6e5c035833da5aed74d4cb2e9ffdf">
  <title>Online Competitive Algorithms for Trading and Portfolio Selection</title>
  <supervisor>
    <pyf1 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Programming skills in C++/Java; a basic understanding of financial market operations; good mathematical skills. </p></prerequisites>
  <profiles><SFS/><ACM/></profiles>
  <aims><p>In the trading or portfolio selection problem, we have a certain amount of money to invest in a fluctuating market consisting of one or more financial products. The aim is of course to make as much money as possible. There are many ways to try to model the market fluctuations and to develop corresponding "good" strategies. In this project we look at this from the algorithmic viewpoint of competitive analysis. </p><p>The aim of this project is to implement some algorithms for the trading and portfolio selection problems. Since these algorithms are designed based on various worst-case or statistical assumptions, their practical performance may be very different from theoretical predictions. These algorithms will therefore be evaluated with real (e.g. FTSE) data. </p></aims>
  <challenges><p>Understand and implement a number of online competitive algorithms trading or portfolio selection.</p></challenges>
  <learning-outcomes><p>After completing the project, students should develop a good understanding in the area of online competitive algorithms in computational finance.  Students will also learn how to implement and systematically evaluate these algorithms.</p></learning-outcomes>
  <end-product><p>A software implementing a selection of such algorithms. </p></end-product>
  <timetable><p>Month 1: Background research, system design. </p><p>Month 2: Implementation. </p><p>Month 3: Implementation and evaluation. </p></timetable>
  <references><reference>
  <author>A. Borodin and R. El-Yaniv</author>
  <volume>Online Computation and Competitive Analysis (Chapter 14)</volume>
  <published year="1998">Cambridge University Press</published>
  <note></note>
  </reference></references>
</project>
<project label="cc045a30c4690d54024b39c9fcd23fde">
  <title>Polygon and polyhedron triangulation</title>
  <supervisor>
    <pyf1 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Programming skills, particularly with graphical elements. Basic understanding in algorithms. </p></prerequisites>
  <profiles><WAS/><ACM/></profiles>
  <aims><p>Triangulation refers to the partitioning a 2D polygon into a set of triangles. This is a basic operation in computational geometry. A lot of research has been done on this problem and many algorithms have been developed for different purposes (e.g. just finding any triangulation, or finding a "minimum weight" triangulation). In three dimensions, a polyhedron can be similarly partitioned into "tetrahedra". </p><p>The aim of the project is to implement some of these algorithms and to visualise them. Note that visualising polyhedra and their associated algorithms in three dimensions is non-trivial.  Some programming tools supporting 3D graphics (e.g. Java3D) may be necessary/useful.</p></aims>
  <challenges><p>Understanding and implementation of such triangulation algorithms, particularly in 3D. </p></challenges>
  <learning-outcomes><p>By doing the project, students will learn a number of such triangulation algorithms as well as the programming skills for dealing with 2D and 3D geometric structures. </p></learning-outcomes>
  <end-product><p>A software implementing and visualising some 2D and possibly 3D triangulation algorithms. </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author>Mark de Berg et al</author>
  <volume>Computational geometry: algorithms and applications</volume>
  <published year="1997"></published>
  <note></note>
  </reference></references>
</project>
<project label="de19f36a662ccc411547792bef423b72">
  <title>Simulation of Packet Buffering Algorithms</title>
  <supervisor>
    <pyf1 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Programming skills and experience in Java/C++. Knowledge in algorithms would be helpful. </p></prerequisites>
  <profiles><ACM/><ADS/><ASE/></profiles>
  <aims><p>Today's networks are "best-effort" in the sense that all packets are equal and there is no guarantee for packet delivery. Next-generation networks will support Quality of Service (QoS) where different packets can receive different treatment, according to their priority. Recent research has derived a number of algorithms for packet buffering supporting QoS with theoretical performance guarantees. We aim to implement some of these algorithms and evaluate their practical performance. </p><p>The aim of this project is to design and implement a software package using Java/C++ to simulate a number of network switching and packet buffering algorithms supporting QoS. As a minimum, the project should consider the "bounded delay model" with multiple finite-size buffers; but other models and variations can be investigated (see references below). </p><p>The program should be able to generate random input instances according to some statistical distribution, and/or allow users to easily specify the input manually. The program should display the simulation process and results in a user-friendly format, and output various measures on the effectiveness of the algorithms (e.g. the percentage of high-priority packets that get delivered within their time limits). The program should ideally be modular so that new algorithms can be incorporated relatively easily. If possible, new heuristics to enhance the performance of the algorithms should be investigated. </p></aims>
  <challenges><p><ul><li>Visualizing the operation of packet buffering algorithms in a user-friendly manner.</li><li>Modular design for easy incorporation of new algorithms.</li><li>Investigate new heuristics to improve the performance of these algorithms</li> </ul> </p></challenges>
  <learning-outcomes><p><ul><li>Understanding of Quality of Service issues in networks, and the algorithms involved.</li><li>Skills in the design and implementation of a simulation system with an appropriate user interface.</li> </ul> </p></learning-outcomes>
  <end-product><p>A software package for simulation of packet buffering algorithms. </p></end-product>
  <timetable><p>Month 1: Research on packet buffering algorithms; specification and design of software. </p><p>Month 2: Implementation of software. </p><p>Month 3: Testing; evaluation of algorithms; introduce new heuristics. </p></timetable>
  <references><reference>
  <author>Y. Azar and N. Levy</author>
  <volume>Multiplexing Packets with Arbitrary Deadlines in Bounded Buffers</volume>
  <published year="2006">Proceedings of 10th Scandinavian Workshop on Algorithm Theory</published>
  <note></note>
  </reference>
  <reference>
  <author>A. Kesselman et al</author>
  <volume>Buffer Overflow Management in QoS Switches</volume>
  <published year="2001">Proceedings of 33th Symposium on Theory of Computing</published>
  <note></note>
  </reference>
  </references>
</project>
<project label="419bfcccbcf0df9be9bfafb26438a626">
  <title>Smartphone application development</title>
  <supervisor>
    <pyf1 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Interest in mobile computing technology; Good programming skills. </p></prerequisites>
  <profiles><SET/><SFS/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>The aim of this project is to develop some <b>new</b> applications for smartphones. It is up to the student to come up with original ideas to refine this topic into a concrete project; in some sense the student proposes the project. Please discuss the project with the supervisor only after you have a good idea. Since smartphones have been around for quite some time and there are thousands of applications already, the project must be of sufficient complexity and based on an original idea, i.e. a simple game is not acceptable.  Preferably you should try to make use of features on a smartphone, e.g. camera, touchscreen, accelerometer etc.</p><p>The application will probably be developed using some SDK and an emulator, although it should also run on a real phone. It could be as platform-independent as possible, or it could target specifically at one OS. </p></aims>
  <challenges><p>Original idea for new applications; developing software on specific and/or new platforms. </p><p>Note that the supervisor cannot provide any technical assistance regarding programming on these mobile platforms or indeed the hardware devices themselves. </p></challenges>
  <learning-outcomes><p>Successful completion of the project should give the student skills and experience in developing code on new platforms. </p></learning-outcomes>
  <end-product><p>A software program runnable on a smartphone. </p></end-product>
  <timetable><p>"Dreaming up" a business idea; technical background research and learning to use the relevant development tools; software design, implementation and testing. </p></timetable>
  <references></references>
</project>
<project label="4e295aa866b4cd4314f222d81fbe7763">
  <title>Temperature-aware task scheduling in microprocessors</title>
  <supervisor>
    <pyf1 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Programming skills in C++/Java. Knowledge in algorithms would be helpful. </p></prerequisites>
  <profiles><ACM/><ADS/></profiles>
  <aims><p>Modern microprocessors generate a lot of heat because of their high clock frequency. But high temperature can damage the processor and hence managing the temperature of the processor is an important issue. One approach is to dynamically adjust the speed (and hence power) of the processor to complete tasks with the minimum temperature. Another approach, which we consider in this project, is to use heat characteristics of different tasks to make scheduling decisions to optimise throughput while maintaining the temperature below a critical limit. Newer multicore processors allow additional flexibility in temperature control by balancing the load between different processors, but we also aims at the additional objective of minimizing the spatial variation of temperature, i.e. the difference in temperature in different cores should be minimized. </p><p>In this project we aim to implement existing or new algorithms for temperature management in microprocessors. The algorithms are evaluated through simulations. </p><p>Note that this project is at an abstract algorithmic level and NOT the hardware level; no kernel hacking or experimenting with real hardware is expected, and no technical or supervision support on these can be provided. </p></aims>
  <challenges><p><ul><li>Research into the topic of temperature scheduling for microprocessors.</li><li>Design and implementation of algorithms.</li> </ul> </p></challenges>
  <learning-outcomes><p><ul><li>Understanding of a current research problem.</li><li>Skills in experience in designing and implementing such algorithms.</li> </ul> </p></learning-outcomes>
  <end-product><p>A software for simulation of temperature-aware scheduling algorithms. </p></end-product>
  <timetable><p>Month 1: Research into algorithms. </p><p>Month 2: Design and implementation. </p><p>Month 3: Implementation, testing, analysis of results. </p></timetable>
  <references><reference>
  <author>Chrobak et al</author>
  <volume>Algorithms for temperature-aware task scheduling in microprocessor systems</volume>
  <published year="2008">Proc. Int. Conference on Algorithmic Aspects in Information and Management</published>
  <note></note>
  </reference><reference>
  <author>S. Fung</author>
  <volume>Online algorithms for maximizing the weighted throughput of unit jobs with temperature constraints</volume>
  <published year="2009">Proc. 9th Workshop on Models and Algorithms for Planning and Scheduling Problems</published>
  <note></note>
  </reference></references>
</project>
<project label="deac5a98071171d4bfbd21eb8215724b">
  <title>The Racetrack Game</title>
  <supervisor>
    <pyf1 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Programming skills; knowledge in basic algorithms as given in CO7002 or equivalent. </p></prerequisites>
  <profiles><WAS/><ACM/></profiles>
  <aims><p>The racetrack game, also called under various other names, is a pencil-and-paper game where players have to "drive" around a track. In each step the horizontal/vertical velocities can be changed by at most +1/-1. See the reference section below for more details of the rules. </p><p>The aim of the project is to implement such a game as either a web-based or a standalone application. In addition, an algorithm for finding the optimal race line, given any track, should also be implemented. Such an algorithm can then be used, for example, as a computer player. The game should also allow users to "draw" and design a track. </p></aims>
  <challenges><p>Implement algorithms for finding optimal race lines; Design and implement user interfaces not just for playing the game but also designing tracks. </p></challenges>
  <learning-outcomes><p>Successful completion of the project should give the student skills and experience in programming using a language of his/her choice; and an understanding of graph algorithms. </p></learning-outcomes>
  <end-product><p>A software implementing such a game. </p></end-product>
  <timetable><p>Background research; system design; algorithm design; implementation and testing. </p></timetable>
  <references><reference>
  <author>Racetrack (game)</author>
  <article>Wikipedia</article>
  <volume>
  http://en.wikipedia.org/wiki/Racetrack_(game)</volume>
  <published year="2010"></published>
  <note></note>
  </reference><reference>
  <author>J. Erickson</author>
  <article>How hard is optimal racing? </article>
  <volume>
  http://3dpancakes.typepad.com/ernie/2009/06/how-hard-is-optimal-racing.html</volume>
  <published year="2009"></published>
  <note></note>
  </reference></references>
</project>
<project label="2d2413a2c26b3757022c52924043731e">
  <title>Virtual Forex Trading</title>
  <supervisor>
    <pyf1 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Programming skills in web technologies. Interest and knowledge in financial markets and foreign exchange would be useful. </p></prerequisites>
  <profiles><SFS/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>The aim of the project is to design and implement a web-based software system for virtual foreign exchange (forex) trading. Users will be able to (virtually) buy and sell currencies, so that they can practise or test their skills without using real money on the market. The prices should either be (i) live prices on real markets retrieved from standard sources, or (ii) determined by the buying and selling behaviour of users in the system, just like how the real market operates. The system should record the history of prices and provide suitable graphical tools to present this data. Common statistical indicators used in price trend analysis (e.g. moving averages) should also be provided to the user. Users will be able to view their current portfolio, transaction history, etc. The system should be web-based using appropriate technologies (Java/php/mySQL etc.), and should support a relatively large number of users. Some additional features may include, for example, the simulation of a large number of agents running some some statistical-indicator-based trading strategies and to measure their effectiveness; or an algorithm to detect "money-making" trading cycles. </p></aims>
  <challenges><p>Implementation of advanced features such as:<ul><li>Advanced graphical display of forex prices and common statistical indicators for price trends (see e.g. <a href="http://www.google.co.uk/finance?q=GBPUSD">Google Finance</a> where graphs can be dragged or zoomed).</li><li>Use of web services to obtain real live currency prices.</li><li>Detecting money-making cycles using shortest paths-based algorithms.</li> </ul> </p></challenges>
  <learning-outcomes><ul><li>Skills and experience in designing and implementing a large-scale software system using an established software engineering process.</li><li>Skills and experience in the use of web services and/or Ajax-based interactive web technologies.</li> </ul></learning-outcomes>
  <end-product><p>A web-based software for virtual currency trading. </p></end-product>
  <timetable><p>Background research on forex market operations and web-based technologies; design and implementation of basic system; implementation of advanced features; testing of system. </p></timetable>
  <references><reference>
  <author>Yahoo! Finance website.</author>
  <volume>http://uk.finance.yahoo.com</volume>
  <note></note>
  </reference></references>
</project>
<project label="f65835debd8c8753d32addac4e19825d">
  <title>Virtual Stock Trading</title>
  <supervisor>
    <pyf1 />
  </supervisor>
  <hidden>Taken in Summer 2009</hidden>
  <prerequisites><p>Programming skills in web technologies. Interest and knowledge in financial markets and stock trading would be useful. </p></prerequisites>
  <profiles><SFS/><WAS/><ADS/><ASE/></profiles>
  <aims><p>The aim of the project is to design and implement a web-based software system for virtual stock trading. Users will be able to (virtually) buy and sell stocks, so that they can practise or test their skills without using real money on the market. The stock prices should either be (i) live prices on real markets retrieved from standard sources, or (ii) determined by the buying and selling behaviour of users in the system, just like how the real market operates. The system should record the history of stock prices and provide suitable graphical tools to present this data. Common statistical indicators used in price trend analysis (e.g. moving averages) should also be provided to the user. Users will be able to view their current portfolio, transaction history, etc. The system should be web-based using appropriate technologies (Java/php/mySQL etc.), and should support a relatively large number of users. Some additional features may include, for example, a ranking of highest-profit users, or the simulation of a large number of agents running some some statistical-indicator-based trading strategies and to measure their effectiveness. </p></aims>
  <challenges><p>Implementation of advanced features such as:<ul><li>Advanced graphical display of stock prices and common statistical indicators for price trends (see e.g.<a href="http://www.google.co.uk/finance?q=INDEXFTSE:.FTSE">Google Finance</a>where graphs can be dragged or zoomed).</li><li>Use of web services to obtain real live stock prices.</li><li>Simulation of rule-based agent trading.</li> </ul> </p></challenges>
  <learning-outcomes><ul><li>Skills and experience in designing and implementing a large-scale software system using an established software engineering process.</li><li>Skills and experience in the use of web services and/or Ajax-based interactive web technologies.</li> </ul></learning-outcomes>
  <end-product><p>A web-based software for virtual stock trading. </p></end-product>
  <timetable><p>Month 1: Background research on stock market operations and web-based technologies. </p><p>Month 2: Design and implementation of system. </p><p>Month 3: Implementation of advanced features; testing of system. </p></timetable>
  <references><reference>
  <author>Yahoo! Finance website.</author>
  <volume>http://uk.finance.yahoo.com</volume>
  <note></note>
  </reference></references>
</project>
<project label="01789ddeb5b981b5740458c04ab65435">
  <title>CV and document management software</title>
  <supervisor>
    <reiko />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>The project will use the following technologies and skills: Microsoft Windows operating systems (XP / Vista / 2003); Microsoft SQL Server; Microsoft Visual Studio (ASP.Net and VB.Net); Microsoft Internet Information Services (IIS); HTML </p></prerequisites>
  <profiles><SET/><WAS/><ACM/><ASE/></profiles>
  <aims><p>This MSc project is intended as a design and feasibility study for a potentially larger project. </p><p>This project is about a software application that can facilitate a reduction in CV administration from 2 hours per day to 15 minutes per day by automating the bulk of CV administrative tasks, at the same time maintaining 100 percent control of CV management while retaining compliance relating to data protection. </p><p>There are many companies providing reasonable recruitment software, as yet we have not identified one without some form of "function creep" which merely substitutes one cumbersome administration system with another. Although there are reasonable packages on the market, each with some time saving qualities, they tend to be linked into large corporate systems and include payroll, CRM, diary management etc. </p><p>We require a web based application suitable for use over multiple offices and also enabled for Blackberry / laptops. The software needs to transfer documents from mainly e-mail (but also any location on a PC) to a database. The key to successful CV management will be in its simplicity, the crux being the transferring of documents in any format. </p></aims>
  <challenges><p>The project will be supervised in cooperation with the company Carney Jones in Whetstone near Leicester. The project thus combines technical and academic challenges with that of interacting with a real client. </p><p>Interviews will be conducted by the company in January before candidates are admitted on the project. </p></challenges>
  <learning-outcomes><p>Interpreting user requirements; Presenting design ideas in a technically accurate way and in a way which is comprehendible by a non-technical audience; Planning of project tasks to deliver defined targets within a prescribed time-scale. </p></learning-outcomes>
  <end-product><p>Functional Specification document; Software Design Specification document; ASP.Net web application prototype </p></end-product>
  <timetable><p>Month 1: Functional Specification </p><p>Month 2: Design and Prototype I </p><p>Month 3: Prototype II </p></timetable>
  <references><reference>
  <author>Carney Jones Ltd</author>
  <published year="2009">CV and Document Management Software</published>
  <note>Available on request from reiko@mcs.le.ac.uk</note>
  </reference></references>
</project>
<project label="d8eb89b7d0815359c498fb7c2d05b30f">
  <title>Data Logging Analysis and Reporting System</title>
  <supervisor>
    <reiko />
  </supervisor>
  <hidden>taken in Jan 2009</hidden>
  <prerequisites><p>Microsoft SQL Server, Microsoft Visual Studio (ASP.Net and VB.Net), Microsoft Internet Information Services (IIS), HTML, Technical writing. </p></prerequisites>
  <profiles><SET/><WAS/><ACM/><ASE/></profiles>
  <aims><p>This MSc project is intended as a design and feasibility study for a potentially larger project. </p><p>The project shall use a server based approach to, ultimately, deliver data logging, analysis and reporting functions for deployment in diverse applications and environments. </p><p>The focus of this project will be on Reporting and Analysis. For the purposes of this project, logged data will be provided either using an existing dataset or generated using off-the-shelf data logging packages. The generation of the database and the data shall be outside the scope of this project. </p><p>The Reporting module will provide the sole user interface for data retrieval. The user interface shall employ an easy to use "click to select" style front-end. The user will select parameters to specify a data-set which will be retrieved from the database(s) and displayed to the user. Data will be made available in graphical (trend) and tabular formats. Where aggregated, rather than discrete, data is requested, this shall be sourced from the Data Analysis module. The logged data would be presented to the user via a web browser. The user would be able to select ad-hoc data sets for trending with configurable scaling. An export tool shall be available via a web browser to allow the user to extract data from the database in tabular format, such as a CSV file, for use in spreadsheet applications. The data query comprising data points, time scales and sample intervals would be user configurable. </p><p>The Analysis module will perform functions on the data in order to provide summary data sets. For example, a dataset comprising the median value for a logged parameter over a given time window might be used in order to provide a graph of the median values over a time period. </p></aims>
  <challenges><p>The project will be supervised in cooperation with the company goIT (UK) Ltd. in Countesthorpe near Leicester. The project thus combines technical and academic challenges with that of interacting with a real client. </p><p>Interviews will be conducted by the company in January before candidates are admitted on the project. </p></challenges>
  <learning-outcomes><p>Interpreting user requirements; Presenting design ideas in a technically accurate way and in a way which is comprehendible by a non-technical audience; Planning of project tasks to deliver defined targets within a prescribed time-scale. </p></learning-outcomes>
  <end-product><p>Functional Specification document; Software Design Specification document; ASP.Net web application prototype </p></end-product>
  <timetable><p>Month 1: Functional Specification </p><p>Month 2: Design and Prototype I </p><p>Month 3: Prototype II </p></timetable>
  <references><reference>
  <author>goIT (UK) Ltd</author>
  <published year="2008">Data Logging, Analysis and Reporting System</published>
  <note>Preliminary requirements document, see<a href="https://campus.cs.le.ac.uk/teaching/resources/CO7201/uploads/goIT.pdf">https://campus.cs.le.ac.uk/teaching/resources/CO7201/uploads/goIT.pdf</a></note>
  </reference></references>
</project>
<project label="e64ee29a629de094be6648696c8531b3">
  <title>Graphical Manipulation of Data</title>
  <supervisor>
    <reiko />
  </supervisor>
  <hidden>hidden</hidden>
  <prerequisites><p>The project will use the following technologies and skills: Microsoft Windows operating systems (XP / Vista / 2003); Microsoft SQL Server; Microsoft Visual Studio (ASP.Net and VB.Net); Microsoft Internet Information Services (IIS); HTML. </p></prerequisites>
  <profiles><ACM/><ADS/><ASE/></profiles>
  <aims><p>This project is done in collaboration with<a href="http://www.carneyjones.co.uk/">Carney Jones Ltd.</a>, a recruitment agency that supplies staff across a variety of business disciplines and work with a wide range of market sectors for companies ranging from major PLC's to small firms.The project consists in the definition and development of a software system that automatically extract data from the a set of databases distributed in multiple offices and locations. The main functionality that the software has to provide is to collect and graphically present various sources of data. The purpose is to extract (relevant) information for monitoring the performance of staff at the agency in a way that helps consultant from Carney Jones Ltd. to take decisions and improve the overall efficiency of the company.Two important requirements of the system are usability and simplicity as the users will not necessarily be highly I.T. literate (also, the activity of gathering statistics is typically perceived as a tiresome task).More preciesely,<ol><li>data must be represented in very easy to understand graphical interfaces</li><li>data must be very flexible and adaptable</li></ol>The overall goal is to highlight possible needs of training and/or re-structure by comparing information of activity data among consultants, offices and departments.The importance of gathering data from any company is vital for analyzing information to facilitate ways to improve business processes and pinpoint which individuals and departments require training. Approaches such as<a href="http://en.wikipedia.org/wiki/Business_process_reengineering">Business Process Re-Engineering</a>(BPR) and<a href="http://en.wikipedia.org/wiki/Training_needs_analysis">Training Needs Analysis</a>(TNA) are used to identify and disentangle business processes and identify areas for skill improvement. These can be time consuming and costly processes for any organisation, especially if using external consultants, both BPR and TNA use large amounts of data drawn from organisations. An example may help to have an idea of the type of scenario in which the software to be developed in this project may help.There are 3 offices of a recruitment company, each supplying aerospace personnel to their clients from 3 separate locations. Each office has 4 consultants working within it. Office A Places individuals into 10 vacant positions per month, additionally finding new business through sales activity of 10 positions. The profit from this office is 50,000 GBP per annum. Office B Places 5 individuals per month, additionally finding new business through sales activity of 5 positions. The profit from this office is 150,000 GBP per annum. Office C Places 25 individuals per month, additionally finding new business through sales activity of 25 positions. The profit from this office is 5,000 GBP per annum.The decisions to be taken correspond to answer typical questions like:<ol><li>Why does office B make 3 times as much profit when filling half the positions and doing half the sales of office A?</li><li>Why is the profit of office C so much lower than A and B when they have far more filled vacancies and higher sales activity?</li><li>Is there a reason to keep office C open?</li></ol> </p></aims>
  <challenges><p>This project requires a rather high inventiveness. The student will liaise with real stakeholders and has to find good graphical representations for data as well as resolve many technical challenges (as dealing with many different data formats, distributed DBs / filesystems, etc.). </p></challenges>
  <learning-outcomes><p>At the end of the project, the student should be able to analyse, design and implement a computational problem; moreover, the student will acquire the ability of developing an application for a real user. </p></learning-outcomes>
  <end-product><p>A software to support decision making </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author>Carney Jones Ltd.</author>
  <volume>CV and Document Management Software (2008). Preliminary requirements document</volume>
  <published year="1901"></published>
  <note>Available on request from reiko@mcs.le.ac.uk</note>
  </reference></references>
</project>
<project label="1942000db4ebf97a84de68d8ff7c15c1">
  <title>Matching of applicants against Vacancies</title>
  <supervisor>
    <reiko />
  </supervisor>
  <hidden>hidden</hidden>
  <prerequisites><p>The project is likely to require the following technologies and skills: Microsoft Windows operating systems (XP / Vista / 2003); Microsoft SQL Server; Microsoft Visual Studio (ASP.Net and VB.Net); Microsoft Internet Information Services (IIS); HTML </p></prerequisites>
  <profiles><SET/><ACM/><ADS/><ASE/></profiles>
  <aims><p>A recruitment agency like Carney Jones Ltd receives circa 100 applications per job vacancy, of which only one individual may be successful in obtaining the position. This leaves 99 applicants, and therefore CV's, who although not suitable for the original positions are in general highly skilled individual's actively seeking work. Our database currently contains thousands of company / client details but little information on the technical capability of our clients. </p><p>A new system designed and developed recently by another MSc project, requires modifications to contain a client information page which can be populated by text directly input by a user, copied and pasted from a company's website or downloaded from a company brochure. This page needs to be 'Organic' and will develop over time as more information is input by consultants to cover the technical abilities of a company and its subsidiary companies. Once this page has been populated it will contain lists of words that need to be cross referenced against CV's of individuals that have applied to. The aim is to find the most suitable client to which an applicant can apply. </p><p>A simple example: </p><p>An applicant applies for a telecommunications position with BT who has asked Carney Jones Ltd to look for a suitably qualified Network Design Engineer. An applicant applies but is not successful as his/her skills are primarily in the marine and subsea / oil and gas telecommunications field. We would ideally like to choose / highlight key skills from the CV which would then search our database of clients and provide a top 10 list of suitable clients such as BP, Shell, Tyco Marine Networks etc. the applicant can apply to as information matching key words on the company is also on the applicants CV. </p><p>For example,the applicant CV mentions Design and Plan the fibre connectivity between UK and Isle of Man via Submarine cable using Alcatel DWDM, SDH products. Design and Plan the national networks for Isle of Man, use of Alcatel and Marconi DWDM, SDH products. </p><p>Another client, Tyco Telecom Undersea System Supply has the following on their web page: As a vertically-integrated supplier of undersea communications systems and services, we are able to leverage our ... Tyco Telecommunications Laboratories continues to make great strides in providing our customers with new products which form the underpinning of the system equipment. Coupled with terrestrial network equipment such as Network Protection Equipment, Routers, ATM, SDH Multiplexers, terrestrial transceivers, etc. from a variety of suppliers, our engineers ... SDH &amp;amp;amp; PDH Networks ... Sub-Marine cabling to multiple off shore projects . . . </p><p>This would ideally highlight to a consultant the possible match in skill to company requirements and lead to calling the company asking if thet have a vacancy, the matching words obviously being Sub-Marine cable and SDH. The software needs to be very flexible and have the ability to screen multiple CV's, groups of CV's, selected keywords or sections of CV's. Additionally the CV's need to be cross referenced with past vacancies that Carney Jones Clients has tried to fill as this historical data is a good bank of clients skill requirements. </p><p>Optional extra - vacancy pages from companies not on the Carney Jones Database can be highlighted to the software. These pages can be used to populate a 'skill' database of companies that are potential clients of Carney Jones Ltd but have requirements within a similar field. This would need to have specific web pages highlighted by a consultant and placed on the database, scanned and updated / added to when changed. </p><p>The software needs to be web based to function across multiple sites. A full brief and data to be used will be provided. </p></aims>
  <challenges><p>The student will liaise with real stakeholders. Development of a web application in an industrial context. Efficient algorithms for querying data that might be in different formats. </p></challenges>
  <learning-outcomes><p>At the end of the project, the student should be able to analyse, design and implement a computational problem; moreover, the student will acquire the ability of developing an application for a real user. </p></learning-outcomes>
  <end-product><p>Prototype as described above </p></end-product>
  <timetable></timetable>
  <references><reference>
  <author>Carney Jones Ltd.</author>
  <volume>CV and Document Management Software (2009). Preliminary requirements document</volume>
  <published year="2008-9"></published>
  <note>Available on request from reiko@mcs.le.ac.uk</note>
  </reference></references>
</project>
<project label="7d3f1936c1d69fb97721db5d92fe1797">
  <title>Model-based regression testing of web services</title>
  <supervisor>
    <reiko />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Background in Web Service development and Modelling related courses e.g. (Service Oriented Architecture (CO7214), System Reengineering (CO7206), Generative Development (CO7216) etc), Programming Languages e.g. VC.Net or Java</p></prerequisites>
  <profiles><SET/><SFS/><WAS/><ADS/><ASE/></profiles>
  <aims><p>Regression testing has the aim of assessing if, during the evolution of a system to a new version, previously existing functionality has been lost or is changes.  This is achieved by maintaining a set of test cases and re-executing it after each change to the system, using the old version to establish if the test produced the expected result.</p>
  
  <p>In model-based testing, test cases are derived from models. Combining model-based testing and regression testing, we are interested in the question, how to evolve test cases from the old to the new version and which of these test cases have to be executed again after a change in the model.</p>
  
  <p>The project will conduct a case study, consisting in the modelling and implementation of several successive versions of services and their test cases to experiment with these notions.</p>  </aims>
  <challenges><p>Use of advanced technologies and tools both at modelling and implementation level</p></challenges>
  <learning-outcomes><p>Perform independent research on non-trivial technical problem; Understand software testing, evolution and service oriented systems analysis and design. 
  </p></learning-outcomes>
  <end-product><p>Case study involving: Models and implementation of services in different versions; Test cases and their evolution; Examples for various evolution scenarios and their analysis.
  </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author>Heckel et al</author>
  <volume>Papers on service modelling and testing.</volume>
  <published year="2005-9"></published>
  <note>Available on request from reiko@mcs.le.ac.uk</note>
  </reference></references>
</project>
<project label="6c1c9a84a4efbe247e3b00b05e70387e">
  <title>Open project with external client</title>
  <supervisor>
    <reiko />
  </supervisor>
  <hidden>not needed</hidden>
  <prerequisites><p>Depending on project in question. </p></prerequisites>
  <profiles><SET/><SFS/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>This is to allow for students to bring forward their own projects that they want to pursue in cooperation with industry or other external partners. It is up to the student to find an external partner and agree the project with them. Please email a brief description of the project you would like to undertake, and the partner, to reiko@mcs.le.ac.uk </p></aims>
  <challenges><p>Solve a real-world problem and learn to interact and work with real clients and/or other developers. </p></challenges>
  <learning-outcomes><p>Depending on project in question. </p></learning-outcomes>
  <end-product><p>Depending on project in question. </p></end-product>
  <timetable><p>Depending on project in question. </p></timetable>
  <references></references>
</project>
<project label="3d9c0d76753c05c66dfa1f23a87508f5">
  <title>Stochastic Modelling and Simulation of P2P Networks</title>
  <supervisor>
    <reiko />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Background in probability theory and stochastic modeling (e.g., as taught in CO7211: Discrete Event Systems) as well in formal software specification CO7094: Software Modelling. UML and programming skills required. Background in metamodelling and model transformation desirable. </p></prerequisites>
  <profiles><SET/><SFS/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>Structured Peer-to-Peer networks employ different kinds of protocols to organize and optimize communication in the absence of a centralized network infrastructure. The evaluation of such protocols both in terms of their functional properties and their performance and reliability requires tool support for modelling and simulation so that protocols can be tried out before they are actually implemented. </p><p>The project shall start out as a case study, using existing tools for modelling P2P network protocols and analysing their properties by simulating them. It may go on to propose a more general methodology and improve on the existing tools. </p></aims>
  <challenges><p>Learn about stochastic modelling and analysis using an approach based on graph and model transformation, and apply this to a non-trivial problem. This is an open-ended research project, not a standard software project. </p></challenges>
  <learning-outcomes><ul><li>Perform independent research on non-trivial technical and mathematical problems.</li><li>Gain experience in using cutting-edge tools.</li><li>Use executable models to reason about and evaluate P2P network protocols.</li> </ul></learning-outcomes>
  <end-product><p>Case study with evaluation and documentation, possibly improvement of existing tools. </p></end-product>
  <timetable><p>First stage: background study and small example to get familiar with the tool </p><p>Second stage: address more complex case study, evaluate its performance and possibly develop variants. Assess existing tool support and possibly improve it. </p></timetable>
  <references><reference>
  <author>Heckel et al</author>
  <volume>Papers on stochastic simulation of graph transformation systems.</volume>
  <published year="2009"></published>
  <note>Available on request from reiko@mcs.le.ac.uk</note>
  </reference></references>
</project>
<project label="717a737160da4ac5808d21833e4ca50a">
  <title>Stochastic modeling and simulation of mobile systems</title>
  <supervisor>
    <reiko />
  </supervisor>
  <hidden></hidden>
  <prerequisites></prerequisites>
  <profiles><SET/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims>In distributed and mobile systems with volatile bandwidth
  and fragile connectivity, non-functional aspects like performance and reliability become more and more important. To formalise, measure, and
  predict these properties, stochastic methods are required. At the same
  time such systems are characterised by a high degree of architectural
  reconfiguration. Viewing the architecture of a distributed system as a
  graph, this is naturally modelled by graph transformations.
  
  To address these two concerns, stochastic graph transformation systems
  associate with each rule and match a probability distribution governing the delay of its application. Depending on the nature of these distributions, different techniques for analysis are available.
  In the case of exponential distributions, continuous-time Markov chains can be derived which allow us to verify reliability properties through model checking.
  
  The project will address a case study of an accident management system deploying emergency vehicles to serve accidents with the aim to minimise delays for other traffic. Existing tools will be used (and possibly improved on) in order to model and evaluate the scenario.
  
  
  </aims>
  <challenges><p>Learn about stochastic modelling and analysis using an approach based on graph and model transformation, and apply this to a non-trivial problem. This is an open-ended research project, not a standard software project. </p></challenges>
  <learning-outcomes><p> Perform independent research on non-trivial technical and mathematical problems.
  Gain experience in using cutting-edge tools.
  Use executable models to reason about and evaluate P2P network protocols.
  </p></learning-outcomes>
  <end-product><p>Case study with evaluation and documentation, possibly improvement of existing tools.</p></end-product>
  <timetable><p>First stage: background study and small example to get familiar with the tool </p><p>Second stage: address more complex case study, evaluate its performance and possibly develop variants. Assess existing tool support and possibly improve it. </p></timetable>
  <references><reference>
  <author>Heckel et al</author>
  <volume>Papers on stochastic simulation of graph transformation systems.</volume>
  <published year="2009"></published>
  <note>Available on request from reiko@mcs.le.ac.uk</note>
  </reference></references>
</project>
<project label="dc5508936fe99c0c14a13590f6dbe0a7">
  <title>Visualisation of online status data for alarm panels</title>
  <supervisor>
    <reiko />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>The project will incorporate the use of C# working with Microsoft technolgies such as WPF and Silverlight for displaying information. The application will use APIs and COM objects to communicate with various IP enabled devices and make heavy use of threading, which will need to be handled in an efficient and sophisticated manner. Good knowledge of advanced web technologies and distributed systems </p></prerequisites>
  <profiles><SET/><WAS/><ADS/><ASE/></profiles>
  <aims><p>The MSc project will be part of a wider effort to develop a solution for monitoring so called alarm panels, i.e., control devices for sensors and cameras placed in homes and businesses to raise intruder alarms. The online status of these panels needs to be monitored regularly and the results displayed or reported. The MSc project will be focussing on the visualization of these monitoring results and the creation of statistics and reports. </p></aims>
  <challenges><p>The project will be supervised in cooperation with a company Video Domain Technologies UK. The project thus combines technical and academic challenges with that of interacting with a real client. </p><p>Interviews will be conducted by the company before candidates are admitted on the project. </p></challenges>
  <learning-outcomes><p>Interpreting user requirements; Presenting design ideas in a technically accurate way ; Planning of project tasks to deliver defined targets within a prescribed time-scale. </p></learning-outcomes>
  <end-product><p>Documentation, software, and tests </p></end-product>
  <timetable></timetable>
  <references></references>
</project>
<project label="d7f34f59ea99428dc4019e471f2d66d5">
  <title>3D Data Visualization in a Retail Environment</title>
  <supervisor>
    <rlc3 />
  </supervisor>
  <hidden>to be approved by Red Dot Square Solutions</hidden>
  <prerequisites><p>A SOUND understanding of C++ programming is ESSENTIAL for this project. Without this, and a strong desire to produce a high quality end product, this project will not be allowed to proceed, since it involves an external client. For good C++ programmers, this project offers an excellent opportunity. </p></prerequisites>
  <profiles><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>Red Dot Square Solutions (RDSS) has a market-leading position as a supplier of custom virtual reality solutions for research and visualisation in the retail environment. The company makes use of virtual reality simulation tools to gather data on the shopping behaviour of customers in the context of a supermarket or store. The amount of data which is collected can be very large. This makes it important to have an effective way to visualize the data and to present it back to clients (the retailers) so that they can gain actionable insight. </p><p>The aim of this project is to investigate and implement some novel ways for visualizing data in 2D and 3D in the context of a supermarket store. RDSS will supply some suitable data-sets. You may be required to sign a standard non-disclosure agreement. </p></aims>
  <challenges><p>The project might be approached in a number of ways. Suppose that we want to understand the position data which shows the path customers followed through the store (and perhaps other properties of the customer as well). One might apply a false colour to the floor to indicate regions of high traffic, or flow markers to indicate the direction and speed of traffic at that point. Equally well, one might illustrate the path that one person took through the store by animating an avatar and watching their progress from a 3rd person viewpoint. In each case, the visualization consists of a 3D model of the store (to be supplied by RDSS) together with some annotation, either fixed or dynamic, to represent the data. </p><p>The starting point for the project will be to download and build OpenSceneGraph, a high performance toolkit for 3D graphics written in C++. This includes a 3D viewer application which can be used to inspect a store model. The main challenge will be to learn and understand how to use the OpenSceneGraph API and then apply that knowledge to extend the plain 3D viewer to produce a data visualization application. </p></challenges>
  <learning-outcomes><p><ul><li>Knowledge of modern 3D graphics using a scene-graph architecture.</li><li>Ability to understand relevant large data-sets and how they may be interpreted.</li><li>Construction of a software system that graphically realises the interpretation.</li> </ul> </p></learning-outcomes>
  <end-product><p>A prototype of a visualization tool which can demonstrate the effectiveness of some particular techniques to convey and present data on the shopping behaviour of customers in 2D or within the 3D context of a store. </p></end-product>
  <timetable><p>Research and background reading. Some initial experiments and prototyping. Make sure you build a prototype during the first few weeks.</p><p>Specification, design and iterative development of visualization application. </p></timetable>
  <references><reference>
  <author></author>
  <volume>OpenSceneGraph http://www.openscenegraph.org/projects/osg</volume>
  <published year=""></published>
  <note></note>
  </reference><reference>
  <author>Alan Watt</author>
  <volume>3D Computer Graphics</volume>
  <published year="1999">Addison Wesley</published>
  <note></note>
  </reference><reference>
  <author>Dave Shreiner, Mason Woo, and Jackie Neider</author>
  <volume>OpenGL Programming Guide: The Official Guide to Learning OpenGL, Version 2.1 by OpenGL Architecture Review Board</volume>
  <published year="2007"></published>
  <note></note>
  </reference></references>
</project>
<project label="1878e79768fccf0dfcc0a0adde57c76c">
  <title>A Learning Tool for Car Safety Dynamics</title>
  <supervisor>
    <rlc3 />
  </supervisor>
  <hidden>work in progress</hidden>
  <prerequisites><p>Familiarity with a good object oriented language such as Java or C++. Ability to code up GUIs. Some knowledge of physical and mathematical dynamics. </p></prerequisites>
  <profiles><ACM/><ADS/><ASE/></profiles>
  <aims><p>To produce a software tool that simulates car safety systems, and allows the user to learn the basics of car safety technology by using the simulator. (The aim is NOT to build a system that, for example, analyses real data records.) </p></aims>
  <challenges><p>You will need to either know or learn about the dynamics of physical systems, and be able to render such dynamics in a graphical form. It will be a challenge to apply these ideas within the context of a learning tool, and to work out at what points of the project it is appropriate to make physical simplifications while still being able to develop an effective learning tool. You will also need to learn about and understand a number of concepts and ideas in car dynamics. </p></challenges>
  <learning-outcomes><p><ul><li>An account of high level car dynamics terminologies.</li><li>A summary of the required mathematical dynamics.</li><li>An interactive GUI that renders a simple car track and associated views, especially of the car body and wheels.</li><li>A computer program that enables the user to simulate a driver's inputs to a car (such as braking) and to simulate the effects through the GUI.</li> </ul> </p></learning-outcomes>
  <end-product><p>A simulation system that allows the user to specify and modify a car's behaviour, and observe the car's dynamics as it progresses round the track. The system should graphically illustrate specific dynamic aspects and how the safety systems act to stabilise the car. </p></end-product>
  <timetable><p>Summarise the key aspects of car dynamics that are to be captured by the system; study the relevant theory of dynamics; specify the software system and interface; design the system ; implement and test. </p></timetable>
  <references></references>
</project>
<project label="d1253dbc7b886355a6c3f6c53c331bfe">
  <title>A Modular Processor Simulator</title>
  <supervisor>
    <rlc3 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Knowledge of a high level programming language (functional or object oriented), and of details of a basic microprocessor consisting both of the ISA code and of core circuit diagrams. You will need to be able to code up a dynamic GUI. Knowledge of XML might be useful. </p></prerequisites>
  <profiles><ACM/><ADS/><ASE/></profiles>
  <aims><p>This project will involve the development of a simulator for microprocessors, using either a functional language or an object oriented language. Simulations for both register and stack based machines could be developed, along with a suitable front end GUI. The purpose of the project is to develop a tool which could be used for the teaching and learning of computer architecture. The tool should be modular in that it should allow processor components to be specified, and for the components to then be utilised in the modular construction of (a family of) processors. </p></aims>
  <challenges><p>The key challenge here is to decide on a suitable approach to this project. There are many choices for simple instruction sets, many ways to parse in the instructions, many ways to display the processor animation, wide choices of the actual processor architecture and so on. Once your approaches to the components are decided upon, you will also need to formulate a suitable strategy for the specification and design of the modularity. </p></challenges>
  <learning-outcomes><p>The outcomes will consist of some or all of the following, but will not be restricted to the list below which is to act as a guide </p><p><ul><li>A description of a simple model processor (ISA) at a very high level</li><li>a framework for modular component selection and building</li><li>specification and design of the simulator, using either objects or functions;</li><li>implementation of the underlying processor engine; and</li><li>design and implementation of a GUI.</li> </ul> </p></learning-outcomes>
  <end-product><p>A GUI based software system, which will take a simple assembly language program as input, and run the program (simulate its execution) on an interpreter model of a CPU. The program execution will be visually traced, and processor statistics will be displayed. </p><p>The user should be able to specify the functionality of different processor components and be able to build new architectures using the components. </p></end-product>
  <timetable><p>Choice/description of the ISA and corresponding processor architecture; specification of the simulator framework; specification of the framework for describing components; design of the complete system; a full implementation and testing. </p></timetable>
  <references><reference>
  <author>Steve Hill</author>
  <volume>The Functional Simulation of a Simple Microprocessor</volume>
  <published year="1994"></published>
  <note>Available from Dr Crole</note>
  </reference></references>
</project>
<project label="48fd0f7e79d6308ab4161e1b7d044d89">
  <title>A Tactical Theorem Prover</title>
  <supervisor>
    <rlc3 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>You will need to know a functional programming language and be familiar with at least first order logic and ideally some other systems. </p></prerequisites>
  <profiles><ACM/><ADS/><ASE/></profiles>
  <aims><p>A theorem prover is a program which enables theorems (often of some logical system) to be derived in a (semi) automated fashion. Theorem provers have been used to study problems in mathematics, and for the verification of both hardware and software systems. This project will give you a chance to design and implement a simple theorem prover. </p></aims>
  <challenges><p>The key challenge is to understand how a theorem prover works in theory, and the principles of implementing a prover. Once the key software structures of a theorem prover are understood, one can fairly rapidly build one that is reasonably powerful. Many stages of this project are technically challenging. </p></challenges>
  <learning-outcomes><p><ul><li>To give an account of a simple logic;</li><li>a coding of the logic's syntax in Haskell or ML;</li><li>implementation of a simple theorem prover for the logic;</li><li>design and implementation of a GUI for the theorem prover.</li> </ul> </p></learning-outcomes>
  <end-product><p>A software system which has as inputs statements in a logic, and outputs formal proofs of these statements (whenever the statement is a theorem of the logic.) </p></end-product>
  <timetable><p>Formulate a logic for implementation ; outline the algorithm for proof inference; decide on suitable data-structures ; code the algorithm; undertake testing and modifications. </p></timetable>
  <references><reference>
  <author>Larry Paulson</author>
  <volume></volume>
  <published year="1999">ML for the Working Programmer</published>
  <note></note>
  </reference></references>
</project>
<project label="ea956687ac5670c68a73e836811d496c">
  <title>Implementing Operational Semantics</title>
  <supervisor>
    <rlc3 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>This project requires familiarity with either a functional or object oriented programming language. If you enjoyed CO2008 Functional Programming you are likely to enjoy this project which is ideally suited to coding in a functional style; however coding in OO style is also quite acceptable. </p></prerequisites>
  <profiles><ACM/><ADS/><ASE/></profiles>
  <aims><p>Programming languages can be specified at different levels of abstraction. At the lowest level we have processor microprogramming, and at the highest we have programming languages such as Haskell and Java. A method known as structured operational semantics (SOS) allows computer scientists to describe the syntax (written language) and semantics (the meaning or execution behaviour) of high level languages, without concern for the complication of low level machine detail. In fact, a SOS amounts to a description of an interpreter. The aim of this project is to study a simple high level language (let's call it L) by describing L using a SOS, and then implementing the SOS-interpreter for L within a real language such as C++, JAVA or Haskell. </p></aims>
  <challenges><p>This is a reasonably challenging project, but the reward will be learning a great deal about the ways in which high level languages can be defined, and the ways in which they execute. The key challenges are to understand how a collection of syntax "rules" can be used to give a high level description of run-time behaviour; and how to turn such rules into interpreter code. </p></challenges>
  <learning-outcomes><p><ul><li>An account of the SOS of a simple language L.</li><li>Review of an appropriate programming language in which the SOS will be implemented.</li><li>The construction of a parser for L.</li><li>The implementation of the SOS-interpreter for L (this will be a substantial part of the project).</li> </ul> </p></learning-outcomes>
  <end-product><p>Implementation of SOS-interpreter, including a user friendly interface. The inputs will be simple L programs, and the outputs will be illustrations of the execution of the L program. </p></end-product>
  <timetable><p>Review/learn an appropriate programming language, study the SOS of a small high level language L, specify and design the SOS-interpreter. </p><p>Implement the SOS-interpreter, build a GUI, and write up project report. </p></timetable>
  <references></references>
</project>
<project label="405c1a2e0a7597299760b833c5e24b54">
  <title>Scrabble</title>
  <supervisor>
    <rlc3 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Ability to programme in Java, C++ or a similar langauge. </p></prerequisites>
  <profiles><SET/><SFS/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>The aim is to write a computer program that can play scrabble against a human player, and perhaps against other machines. </p></aims>
  <challenges><p>The key challenges are to understand suitable game playing algorithms; and methods of dictionary storage. This will require some algorithms theory, and some simple automata minimalisation (for the dictionary). The GUI will also require careful thought if it is to be a good one. Note that although many people can produce adequate players, implementing one of high quality is not as easy as one might think. </p></challenges>
  <learning-outcomes><p><ul><li>You will understand the game of scrabble in detail.</li><li>You will be able to describe, and code, efficient game playing algorithms.</li><li>You will be able to describe, and code, efficient dictionary storage and access systems.</li><li>You will be able to produce good GUIs for this and similar games.</li> </ul> </p></learning-outcomes>
  <end-product><p>A computer program that can play scrabble, with a very good user interface, and efficient playing strategy. </p></end-product>
  <timetable><p>Literature and product survey; understanding and selection of playing algorithms; research into dictionaries; a prototype system which can play a very simplified game of scrabble; specification and design of the final system. </p><p> </p></timetable>
  <references></references>
</project>
<project label="2e1107aaaef8d4f17710d2101359e39b">
  <title>Type Checking Algorithms with Implementations</title>
  <supervisor>
    <rlc3 />
  </supervisor>
  <hidden>in progress</hidden>
  <prerequisites><p>A solid grounding in a high level programming language. A knowledge of functional programming and the associated type systems is desirable. </p></prerequisites>
  <profiles><ACM/><ADS/><ASE/></profiles>
  <aims><p>Types play a crucial role in a wide variety of programming languages, guiding the construction of sensible code, and enabling a program which embodies a single algorithm to be applied to arguments of different types. Many languages employ type-checking algorithms which, given a program, decide whether the program can be assigned a type, and if so find that type. The construction of new (typed) programming languages, and their associated type-checking algorithms, has been made possible (in part) by the development of type theory. This project is to write an account of some aspects of the theory of types in Computer Science, and to implement a simple type-checker. </p></aims>
  <challenges><p>The key challenge is to understand how a type checker and inference algorithm works, and the important data structures involved in implementation. You will need to understand the difference between type checking and inference. </p></challenges>
  <learning-outcomes><p><ul><li>A written account of the theory of type checking of programs.</li><li>An explanation of a simple type checking algorithm, such as algorithm W.</li><li>An implementation of the algorithm.</li> </ul> </p></learning-outcomes>
  <end-product><p>A software system which will take simple programs as input, and will either return a type error, or the type of the program if this is possible. </p></end-product>
  <timetable><p>Literature survey of relevant algorithms and type systems; specification of suitable data-structures to represent the types; design of algorithm(s); implementation and testing.   </p></timetable>
  <references></references>
</project>
<project label="d53a87557126afd522e4b20367b7f9e8">
  <title>Mining Frequent Itemsets from Transaction Databases or Website Interaction Mining</title>
  <supervisor>
    <rr29 />
  </supervisor>
  <hidden>Taken in Summer 2009</hidden>
  <prerequisites><p>No specific pre-requisites, but the project should be done in Java or C++. There are two versions of this project, one for ACS and one for WAS/ASE. The latter should do the website interaction pattern mining version of the project (see below). If so, a simple website may need to be created using HTML, and a webserver log to be accessed. </p></prerequisites>
  <profiles><WAS/><ACM/><ASE/></profiles>
  <aims><p>The objective is to discover sets of elements that tend to be found simultaneously in the same row (in the supermarket example, this means that these are items that tend to be bought simultaneously). For example, such a set might be {tomato,lettuce,salad dressing}. Frequent itemsets are used for association rule mining; such information is very useful for supermarkets to determine for example which products to place near each other, or which products to group together for special offers. Note that transaction databases are normally very big so algorithms have to be somewhat efficient. </p><p>Students doing MSc WAS or MSc ASE should mine not transaction databases but web interaction traces, to discover patterns of user behaviour when interacting with a website. The can be used to customize websites to user behaviour patterns. </p></aims>
  <challenges><p>Various challenges; the algorithms are complex, and there could be interesting pre-processing and analysis of the data. (in the web interaction pattern mining version). One may also consider synthetic data generation. </p></challenges>
  <learning-outcomes><p><p>Apart from generic learning outcomes from an MSc project, this project gives insight into a major data mining sub-area. </p> </p></learning-outcomes>
  <end-product><p>The ACS version of the project involves implementing some of the most famous algorithms: Apriori, FP-growth or ECLAT (see for instance [Han et al.], or any number of courses on this subject,also see Wikipedia), and testing their performance on a number of real-life data sets [FIMI'04]. Writing a good description of these algorithms in the final report is an important part of the project. </p><p>For mining website interaction patterns (the ASE and WAS version) the sequential pattern mining algorithm of [El-Ramly et al.] should be implemented, as well as potentially a test website, and/or a synthetic data generator. </p></end-product>
  <timetable><p><ul><li>First month: read about the algorithms. Download data sets and other peoples implementations, understand their file formats, and test the existing implementations on the data sets.</li><li>Second month: code your software.</li><li>Third month: complete coding and performance enhancement of your code. Perfomance testing. Documentation.</li> </ul> </p></timetable>
  <references><reference>
  <author>Jiawei Han, Hong Cheng, Dong Xin and Xifeng Yan</author>
  <article>Frequent Pattern Mining: Current Status and Future Directions</article>
  <published year="2007">Data Mining and Knowledge Discovery,15, pp. 55-86</published>
  <note>DOI:10.1007/s1 0618-006-0059-1</note>
  </reference><reference>
  <author>FIMI'04</author>
  <article>Workshop on Frequent Itemset Mining Implementations.</article>
  <note>http://fimi.cs.helsinki.fi/fimi04/</note>
  <note>Accessed in Jan 2009.</note>
  </reference><reference>
  <author>Mohammad El-Ramly, Eleni Stroulia and Paul Sorenson</author>
  <article>From Run-time Behavior to Usage Scenarios: An Interaction-pattern Mining Approach.</article>
  <published year="2002">Proceedings of the 8th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (SIGKDD), pp. 315-324.</published>
  <note>ACM Press, ISBN 1-58113-567-X</note>
  </reference></references>
</project>
<project label="a6c3962c18f874ab7efc33e9e1bce728">
  <title>Optimising for high-performance cache utilisation</title>
  <supervisor>
    <rr29 />
  </supervisor>
  <hidden>Taken in Summer 2009</hidden>
  <prerequisites><p>CO7104 (C++ programming and advanced algorithm design). </p></prerequisites>
  <profiles><ACM/><ASE/></profiles>
  <aims><p>Over the last 20 years CPU clock rates have grown explosively, but the speeds of main memory (DRAM) have not increased nearly as rapidly. Nowadays accessing data from main memory can be nearly 70 times slower than accessing data in the registers of the CPU. In addition, accessing main memory dissipates much more energy than accessing registers, which is especially undesirable for mobile devices, where battery life is an important consideration. In order to reduce memory accesses, modern computers have multiple levels of cache between CPU and memory. A cache is a small fast memory that holds the values of frequently-accessed memory locations. The movement of data into the cache is managed automatically by the system (compiler, hardware and OS). If the code is written without understanding of the cache, however, there will be many memory accesses regardless of what the system does, and the code will be very slow. All performance-oriented applications (such as computer games, weather forecasting etc.) must use cache-aware code. The aim of the project is to get a detailed understanding of caches and how they work, and to demonstrate this by several relatively simple code examples, timing and cache profiling results. </p></aims>
  <challenges><p>To understand in depth how the cache memory of a modern computer works. To understand more about cache optimizations. To learn how to run a series of timing experiments; elementary data analysis and graphical presentation of results. </p></challenges>
  <learning-outcomes><p><ul><li>Deeper understanding of C++ code optimisation.</li><li>Understanding of algorthmic optimisations for cache usage.</li><li>Understanding performance evaluation, graphical presentation of experimental results.</li> </ul> </p></learning-outcomes>
  <end-product><p><ul><li>a short survey that explains various kinds of caches (including the TLB), th e cache-oblivious model and Morton-order layout of matrices.</li><li>Code that implements the following matrix-multiplication algorithms.:</li><ul><li>Standard matrix multiplication.</li><li>Blocked matrix multiplication.</li><li>Recursive matrix multiplication, including Strassen\'s algorithm.</li><li>Morton-order layout matrix multiplication.</li> </ul><li>Using a cache profiler such as cachegrind, an experimental evaluation of these algorithms and an explanation.</li> </ul> </p></end-product>
  <timetable><p><ul><li>First month: understand caches and performance. Learn to use cachegrind. Begin work on survey.</li><li>Second month: implement various matrix multiplication algorithms.</li><li>Third month: obtain experimental results, analyse them and present experimen tal conclusions. Complete documentation.</li> </ul> </p></timetable>
  <references><reference>
  <author>Harald Prokop</author>
  <article>Cache-Oblivious Algorithms</article>
  <note>(MSc thesis, MIT)</note>
  <published year="1999">http://citeseer.ist.psu.edu/rd/0%2C212387%2C1%2C0.25% 2CDownload/http%3AqSqqSqsupertech.lcs.mit.eduqSqcilkqSqpapersqSqProkop99.ps.gz</published>
  </reference><reference>
  <author>Unknown</author>
  <article>Morton-Order Matrix Layout</article>
  <published>http://en.wikipedia.org/wiki/Morton-order_matrix_represention</published>
  </reference><reference>
  <author>John L Hennessy</author>
  <article>Computer Architecture, 4th Ed</article>
  <published year="2006">Morgan Kaufmann</published>
  </reference></references>
</project>
<project label="e2bcc88e802c4641ef1b6c13ef589c92">
  <title>Sequential Pattern Mining</title>
  <supervisor>
    <rr29 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>No specific pre-requisites. These are "Technical" projects, which should be done in Java, C++ or C#. </p></prerequisites>
  <profiles><WAS/><ACM/><ADS/></profiles>
  <aims><p>Sequential pattern mining aims to extract meaningful patterns from large databases of "events". </p><ul><li>Events are generated by "sources": each event is associated with the source that generated it.</li><li>Events have time-stamps associated with them: given two events, one knows which event occured earlier.</li> </ul><p>Thus, the database consists of a number of records which specify the event, the source that caused the event, and the time that the event occurred. The aim is to mine this data so that we can discover meaningful patterns of events that occur one after the other. A pattern is considered meaningful if this pattern occurs in the events associated with more than say 10% of sources (the 10% is specified by the user). </p><p>Examples of such databases include: </p><ul><li>A user (source) browses a website, and the events are the web pages accessed by the user. Web-logs of websites contain vast amounts of such information.</li><li>a shopper (source) visits makes several visits to an on-line retailer, and the events are the set of items bought by the user in each visit.</li><li>a car (source) is driving around a city centre and the events are the roads that it drives along.</li> </ul><p>We want to mine this data -- namely, given a database, we want to discover interesting patterns of behaviour. For example, that customers that buy product X and Y in one visit then come back and buy Z in a subsequent visit. Or cars that make lefts at two particuar intersections then tend to make a right at some later intersection. Understanding this behaviour is useful to a number of business intelligence, transport planning, website design etc. </p><p>We focus on a new area within this topic, namely the case where the data is<i>uncertain</i>. It is widely recognized that most databases are uncertain and/or inconsistent. One model for uncertainty is<i>probabilistic databases</i>(see the video and by Dalvi and Suciu and the survey article by Dalvi, Re and Suciu below). Sequential pattern mining in probabilistic databases is not well studied, even though the kind of uncertainty present in sequential pattern mining databases is naturally modelled in a probabilitic manner. </p><p>This is a general theme and within this theme a number of projects are possible. Examples include: </p><ul><li>A model for how uncertain data for sequential patterns can be modelled as probabilistic database; data generation for such models.</li><li>Implementation and experimental evaluation of sequential pattern mining algorithms on probabilistic data.</li> </ul></aims>
  <challenges><p> </p></challenges>
  <learning-outcomes><p> </p></learning-outcomes>
  <end-product><p>Software and experimental results as agreed with supervisor. </p></end-product>
  <timetable><p>The timetable will be negotiated with the supervisor once the precise project specification is known. </p></timetable>
  <references><reference>
  <author>Nilesh Dalvi and Dan Suciu</author>
  Project title:<note>Video (only under Internet Explorer) here: http://content.digitalwell.washington.edu/msr/external_release_talks_12_05_2005/12377/lecture.htm</note>
  http://content.digitalwell.washington.edu/msr/external_release_talks_12_05_2005/12377/lecture.htm</reference><reference>
  <author>Nilesh Dalvi, Christopher Re, Dan Suciu</author>
  Project title:<published year="2009">Communications of the ACM</published>
  <note>http://pages.cs.wisc.edu/~chrisre/papers/cacm-paper-full.pdf</note>
  </reference><reference>
  <author>Nodira Khoussainova, Magdalena Balazinska, Dan Suciu</author>
  Project title:<published year="2008">Proceedings ICDE conference</published>
  <note>DOI http://dx.doi.org/10.1109/ICDE.2008.4497596</note>
  </reference><reference>
  <author>Oktie Hassanzadeh and Renee J. Miller</author>
  <published year="2009">The VLDB journal</published>
  <note>URL http://www.springerlink.com/content/u536165qvl3507m2/</note>
  </reference><reference>
  <author>Jian Pei, Jiawei Han, Behzad Mortazavi-Asl, Jianyong Wang, Helen Pinto, Qiming Chen, Umeshwar Dayal, Mei-Chun Hsu</author>
  Project title:<published year="2004">IEEE TKDE Journal</published>
  <note>http://doi.ieeecomputersociety.org/10.110910.1109/TKDE.2004.77</note>
  </reference></references>
</project>
<project label="965ad01eff64508f6a356b6bd52ad8aa">
  <title>Sliding Window Protocol Simulator</title>
  <supervisor>
    <rr29 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>CO7213 and CO7211 are essential pre-requisites. The software will be programmed in Java or C++.</p></prerequisites>
  <profiles><WAS/><ACM/><ADS/></profiles>
  <aims><p>The aim is to produce a teaching tool that will aid the understanding of &amp;amp;amp;amp;quot;sliding window&amp;amp;amp;amp;quot; protocols used in direct link networks.</p>
  
  <p>The software will:
  <ul>
  <li>Show a simulation that transmits frames from 
  sender to receiver; the user should be able to specify key
  parameters such as: RTT, SWS, RWS (set the sequence numbers to be the minimum correct range), error rate, bandwidth, 
  packet size etc.</li>
  <li>If the sequence number range is too small, then
  a simulation of an example that shows incorrect operation.
  </li>
  <li>Given the bandwidth, packet size, RTT and 
  error rate of the channel, a tool that will 
  help the user pick the best SWS/RWS to maximize
  the througput of the channel.</li>
  </ul>
  </p></aims>
  <challenges><p>Understanding discrete event simulation and
  implementing the graphics.</p></challenges>
  <learning-outcomes><p> </p></learning-outcomes>
  <end-product><p> Software as above</p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references></references>
</project>
<project label="c8e6df2028a517f4757a9c89a9645b15">
  <title>XML Access Control</title>
  <supervisor>
    <rr29 />
  </supervisor>
  <hidden>Project taken in Feb 2009</hidden>
  <prerequisites><p> </p></prerequisites>
  <profiles><WAS/><ACM/><ASE/></profiles>
  <aims><p> </p></aims>
  <challenges><p> </p></challenges>
  <learning-outcomes><p> </p></learning-outcomes>
  <end-product><p> </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="b3ef81c721e7569912344689071491d1">
  <title>XML Access Control - variant</title>
  <supervisor>
    <rr29 />
  </supervisor>
  <hidden>variant project</hidden>
  <prerequisites><p> </p></prerequisites>
  <profiles><WAS/><ACM/><ASE/></profiles>
  <aims><p> </p></aims>
  <challenges><p> </p></challenges>
  <learning-outcomes><p> </p></learning-outcomes>
  <end-product><p> </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="46b7df0a5956ab5334c1f0bf77592f24">
  <title>XML Database for Bibliograpic Citations</title>
  <supervisor>
    <rr29 />
  </supervisor>
  <hidden>Taken in Summer 2009</hidden>
  <prerequisites><p>Java/C++, XML. It is strongly recommended that you have taken CO7098 or have equivalent knowledge. Furthermore, if you do the web service you should have taken CO7214. </p></prerequisites>
  <profiles><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>To develop an XML-based bibliographic reference manager which also has functionality for maintaining a database of research publications. In order to publish a research paper, it is essential to ensure that all relevant prior research work has been cited appropriately. Thus, most researchers have a large database of research outputs from which they could select a few to include in a particular paper that they write; thus it is important to have a bibliographic reference manager to manage this collection. </p><p>Research outputs are of many different kinds. There are journal articles, conference proceedings, BSc/MSc/PhD theses, edited books, authored books etc. There is a standard (flat file) format for these called BiBTeX. Using BiBTeX as a guide you will generate an XML Document Type Definition (DTD) for the various kinds of publications, possibly simplifying the DTD provided by the BiBTeXML project (see below). Bibliographic references should then be stored in this XML format you have defined. </p><p>The functionality of the software will include, among other things:<ul><li>The ability to manage a collection of references including: adding new references, changing/deleting old ones, searching the references, creating folders containing the "current" references that a researcher is working on. Optional functionality would be to associate pdf files with each reference.</li><li>The ability to import and export references BibTeX and XML format. HTML export should also be supported, according to a variety of bibliographic styles.</li><li>More advanced functionality would be to make available your software's functionality as a web service or to provide a &amp;quot;reference finder&amp;quot; service, which will build a set of references related to a particular topic.</li> </ul> </p></aims>
  <challenges><p>Understanding the BibTeX file format, and how it is used, in particular Bibilography Style Files. Writing a parser for BibTeX with suitable functionality, and writing XSLT style sheets based on.bstfiles. </p><p>The advanced functionalities referred to above. </p></challenges>
  <learning-outcomes><p> </p></learning-outcomes>
  <end-product><p>Software as above. Use it to help with your project report! </p></end-product>
  <timetable></timetable>
  <references><reference>
  <note><a href="http://bibtex.sourceforge.net">BibTeX as XML Markup</a></note>
  </reference><reference>
  <note><a href="http://www.w3.org/TR/xquery">XQuery 1.0: An XML Query Language</a></note>
  </reference><reference>
  <note>There are a number of existing packages, we can discuss the most appropriate ones as soon as it is clear what direction the project is going in.</note>
  </reference></references>
</project>
<project label="9694ec5dde6a6020dadf3f630a0cdf54">
  <title>Active Contours</title>
  <supervisor>
    <sk223 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Some mathematics, good programming skills </p></prerequisites>
  <profiles><SET/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>Active Contour, also called Snakes, is a framework for delineating an object outline from a possibly noisy 2D image. </p><p>Given an initial starting shape and positon on an image contour changes shape (deforms) until it reaches a state of convergance. This model is highly popular in Computer Vision, and led to several developments in 2D and 3D. </p><p>Your task for this project would be to implement an Active Contour and apply it to a real life dataset of images. </p></aims>
  <challenges><p><ul><li>Familiarising oneself with Active Contour literature - good practice for a student considering a career in research</li><li>Familiarisation with dataset</li> </ul> </p></challenges>
  <learning-outcomes><p><ul><li>Computer Vision</li><li>2D image manipulation</li><li>Research skills</li> </ul> </p></learning-outcomes>
  <end-product><p>A software tool to allow use of Active Contour on a user-selected image. Experimental results from real-life data. </p></end-product>
  <timetable><p><ul><li>Reading of background material.</li><li>Prototype</li><li>Completed project + report.</li> </ul> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="192be7306c9c3a2adbd34daacb214a1b">
  <title>Course Marker Front End</title>
  <supervisor>
    <sk223 />
  </supervisor>
  <hidden>hidden by Artur</hidden>
  <prerequisites><p>Knowledge of Java, Regular Expressions and some C++ </p></prerequisites>
  <profiles><SET/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>CourseMarker is the software used by the Department of Computer Science to develop exercises in 1st and 2nd year programming modules using Java and C++. Currently creation of exercises is very laborious, requiring numerous mark, .txt and .java files. This project would create a front-end for creating and testing CourseMarker exercises that simplifies the process and deploys them on test servers and the Departmental server. </p></aims>
  <challenges><p>Learning coursemarker, programming, communication with server, robustness of exercises created </p></challenges>
  <learning-outcomes><p>Advanced programming, potential to develop a web application for deploying CM exercises, learn more about creating test stubs/harnesses and skeleton code for students. </p></learning-outcomes>
  <end-product><p>A completed program/web application that is used to create CM exercises for C++ or Java. </p></end-product>
  <timetable><p>Reading of background material. Prototype. Finished Project </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="069da939fc4b036bb40d8eeab523ca2f">
  <title>Gaming with Augmented Human Computer Interface</title>
  <supervisor>
    <sk223 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p><ul><li>Good knowledge of a programming language (Java, C++, C#, .NET etc.)</li><li>multimedia skills</li><li>knowledge of UML</li><li>capability of understanding new technology</li><li>strong presentation skills.</li> </ul> </p></prerequisites>
  <profiles><SET/><ACM/><ADS/><ASE/></profiles>
  <aims><p>The human computer interface paradigm has evolved in recent years. No longer is interacting with a computer game necessarily a sedentary activity. Systems such as the EyeToy and Wii now use webcam and remote sensing technology to allow active participation in the game. The goal of the project(s) is to implement a computer game (or if time allows a suite of games) controlled by such means (most likely by webcam but ultimately up to the student). The exact game to implement is negotiable, but the actual game itself should be kept to a comfortable level of difficulty for the student. </p><p>Requirements for this project include </p><ul><li>Single player mode against an intelligent computer player</li><li>Multiplayer competitive functionality (simultaneous or turn-based depending on nature of game).</li><li>Investigation of different algorithms/methods for control and their effect on game playability</li><li>Expansion of control mechanism to multiple games</li><li>Playable when projected from computer</li><li>Portability, program should be easily moved from one computer to another. Cross-platform compatibility is also desirable.</li> </ul></aims>
  <challenges><p>The need to learn to implement new technology, as well as potentially some image processing or remote sensing skills. </p></challenges>
  <learning-outcomes><p>Understanding image processing/remote sensing, Experience of game programming </p></learning-outcomes>
  <end-product><p>Complete working game </p></end-product>
  <timetable><p>Design documentation, Early implementation of prototype, this could be the game controlled by conventional means (i.e. by keyboard) along with some indication of early implementation of the new HCI, Report, Completed Game </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="9f69408446b02f53d0c6a06d437fd670">
  <title>Gaming with Augmented Human Computer Interface Breakout</title>
  <supervisor>
    <sk223 />
  </supervisor>
  <hidden>hidden by Artur</hidden>
  <prerequisites><p><ul><li>Good knowledge of a programming language (Java, C++, C#, .NET etc.)</li><li>multimedia skills</li><li>knowledge of UML</li><li>capability of understanding new technology</li><li>strong presentation skills.</li> </ul> </p></prerequisites>
  <profiles><SET/><ACM/><ADS/><ASE/></profiles>
  <aims><p>The human computer interface paradigm has evolved in recent years. No longer is interacting with a computer game necessarily a sedentary activity. Systems such as the EyeToy and Wii now use webcam and remote sensing technology to allow active participation in the game. The goal of the project(s) is to implement a computer game (or if time allows a suite of games) controlled by such means (most likely by webcam but ultimately up to the student). </p><p>The intention here is to create a version of the game of<a href="http://en.wikipedia.org/wiki/Breakout">Breakout</a>that is controlled via webcam or remote sensing. </p><p>Requirements for this project include </p><ul><li>Single player mode</li><li>Multiplayer mode (i.e. two bats).</li><li>Investigation of different algorithms/methods for control and their effect on game playability</li><li>Playable when projected from computer</li><li>Portability, program should be easily moved from one computer to another. Cross-platform compatibility is also desirable.</li><li>Additional features to expand on the basic<a href="http://en.wikipedia.org/wiki/Breakout">Breakout</a>game should be added by the student.</li> </ul>A demonstration of<a href="http://en.wikipedia.org/wiki/Breakout">Breakout</a>can be found<a href="http://www.play.vg/games/10-Breakout.html">here</a>.</aims>
  <challenges><p>The need to learn to implement new technology, as well as potentially some image processing or remote sensing skills. </p></challenges>
  <learning-outcomes><p>Understanding image processing/remote sensing, Experience of game programming </p></learning-outcomes>
  <end-product><p>Complete working game </p></end-product>
  <timetable><p>Design documentation, Early implementation of prototype, this could be the game controlled by conventional means (i.e. by keyboard) along with some indication of early implementation of the new HCI, Report, Completed Game </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="abda87b8c36511070ea46c9bdc2dd8f7">
  <title>Gaming with Augmented Human Computer Interface - Pong</title>
  <supervisor>
    <sk223 />
  </supervisor>
  <hidden>hidden by Artur</hidden>
  <prerequisites><p><ul><li>Good knowledge of a programming language (Java, C++, C#, .NET etc.)</li><li>multimedia skills</li><li>knowledge of UML</li><li>capability of understanding new technology</li><li>strong presentation skills.</li> </ul> </p></prerequisites>
  <profiles><SET/><ACM/><ADS/><ASE/></profiles>
  <aims><p>The human computer interface paradigm has evolved in recent years. No longer is interacting with a computer game necessarily a sedentary activity. Systems such as the EyeToy and Wii now use webcam and remote sensing technology to allow active participation in the game. The goal of the project(s) is to implement a computer game (or if time allows a suite of games) controlled by such means (most likely by webcam but ultimately up to the student). </p><p>The intention here is to create a version of the game of<a href="http://en.wikipedia.org/wiki/Pong">Pong</a>that is controlled via webcam or remote sensing. </p><p>Requirements for this project include </p><ul><li>Single player mode against an intelligent computer player</li><li>Multiplayer competitive functionality (simultaneous or turn-based depending on nature of game).</li><li>Investigation of different algorithms/methods for control and their effect on game playability</li><li>Expansion of control mechanism to multiple games</li><li>Playable when projected from computer</li><li>Portability, program should be easily moved from one computer to another. Cross-platform compatibility is also desirable.</li><li>Additional features to expand on the basic<a href="http://en.wikipedia.org/wiki/Pong">Pong</a>game should be added by the student.</li> </ul></aims>
  <challenges><p>The need to learn to implement new technology, as well as potentially some image processing or remote sensing skills. </p></challenges>
  <learning-outcomes><p>Understanding image processing/remote sensing, Experience of game programming </p></learning-outcomes>
  <end-product><p>Complete working game </p></end-product>
  <timetable><p>Design documentation, Early implementation of prototype, this could be the game controlled by conventional means (i.e. by keyboard) along with some indication of early implementation of the new HCI, Report, Completed Game </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="7a4a7e289219e7181d7214d4d1439780">
  <title>Gaming with Augmented Human Computer Interface - Welltrix</title>
  <supervisor>
    <sk223 />
  </supervisor>
  <hidden>hidden by Artur</hidden>
  <prerequisites><p><ul><li>Good knowledge of a programming language (Java, C++, C#, .NET etc.)</li><li>multimedia skills</li><li>knowledge of UML</li><li>capability of understanding new technology</li><li>strong presentation skills.</li> </ul> </p></prerequisites>
  <profiles><SET/><ACM/><ADS/><ASE/></profiles>
  <aims><p>The human computer interface paradigm has evolved in recent years. No longer is interacting with a computer game necessarily a sedentary activity. Systems such as the EyeToy and Wii now use webcam and remote sensing technology to allow active participation in the game. The goal of the project(s) is to implement a computer game (or if time allows a suite of games) controlled by such means (most likely by webcam but ultimately up to the student). </p><p>The intention here is to create a version of the game of Tetris/Welltrix that is controlled via webcam or remote sensing. </p><p>Requirements for this project include </p><ul><li>Single player mode</li><li>Multiplayer mode (i.e. two pieces controlled).</li><li>Investigation of different algorithms/methods for control and their effect on game playability</li><li>Playable when projected from computer</li><li>Portability, program should be easily moved from one computer to another. Cross-platform compatibility is also desirable.</li><li>Additional features to expand on the basic Tetris (or Welltrix, the 3D variant) game should be added by the student.</li> </ul></aims>
  <challenges><p>The need to learn to implement new technology, as well as potentially some image processing or remote sensing skills. </p></challenges>
  <learning-outcomes><p>Understanding image processing/remote sensing, Experience of game programming </p></learning-outcomes>
  <end-product><p>Complete working game </p></end-product>
  <timetable><p>Design documentation, Early implementation of prototype, this could be the game controlled by conventional means (i.e. by keyboard) along with some indication of early implementation of the new HCI, Report, Completed Game </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="ee371a75b8150ae33426f908787cd9e3">
  <title>Robust Ellipse Fitting</title>
  <supervisor>
    <sk223 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p><ul><li>Good knowledge of a programming language (Java, C++, C#, .NET etc.)</li><li>multimedia skills</li><li>knowledge of UML</li><li>capability of understanding new technology</li><li>good mathematical skills.</li> </ul> </p></prerequisites>
  <profiles><SET/><ACM/><ADS/><ASE/></profiles>
  <aims><p>The least squares method is the most commonly used technique for fitting an ellipse through a set of points. However, it has a low breakdown point, which means that it performs poorly in the presence of outliers. Least median of squares is the most suitable method in terms of accuracy and robustness. You are required to demonstrate this algorithm and evaluate it.</p>
  <p>LMedS uses
  the residuals of the full data set of each hypothesised ellipse. The ideal error
  measure would be the Euclidean distance between the point and the ellipse, but
  that is expensive to calculate, requiring solving a quartic equation and choosing the
  smallest of the four solutions. In practice there are many simpler approximations
  that are often used. The principle one (and both the simplest and most
  efficient) is the algebraic distance</p></aims>
  <challenges><p>The need to learn to understand robust statistics and implement a demonstration package. </p></challenges>
  <learning-outcomes><p>Understanding robust and non-robust ellipse fitting. </p></learning-outcomes>
  <end-product><p>Completed implementation of algorithm </p></end-product>
  <timetable><p>Design documentation, Early implementation of prototype, this could be the game controlled by conventional means (i.e. by keyboard) along with some indication of early implementation of the new HCI, Report, Completed Game </p></timetable>
  <references><reference>
  <author>Paul L Rosin</author>
  <volume>8th British Machine Vision Conf</volume>
  <published year="1997"></published>
  <note>http://users.cs.cf.ac.uk/Paul.Rosin/resources/papers/ellipse3.pdf</note>
  </reference></references>
</project>
<project label="e0816eb6cbb3585c9e1b44f5fea75050">
  <title>Synthetic Images of Total Hip Replacements</title>
  <supervisor>
    <sk223 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Good programming skills, some mathematical skills, willingness to learn new skills </p></prerequisites>
  <profiles><ACM/><ASE/></profiles>
  <aims><p>Measurements of<a href="http://en.wikipedia.org/wiki/Hip_replacement">total hip replacements</a>(THRs) are performed on radiographs (colloquially known as x-rays). This is a 2D projection of a 3D scene, thus error is introduced. </p><p>The aim of this project is to create a package that allows the creation of synthetic THR images from a 3D scene created from user entered parameters (such as how far apart the components are) and can estimate the error introduced to measurements performed on these synthetic images due to the projection from 2D to 3D. </p><p>Here is a sample (real) radiograph:- </p><p> </p></aims>
  <challenges><p>Familiarising oneself with THR literature - good practice for a student considering a career in research or working in a multi-disciplinary team </p><p>Understanding the concept of measurements and error estimation </p></challenges>
  <learning-outcomes><p>3D modelling </p><p>2D projection </p><p>Research skills </p></learning-outcomes>
  <end-product><p>A software tool to allow manipulation of 3D scene, produce synthetic images, perform measurements on both synthetic image and 3D scene and compare the measurements, and a preliminary investigation into magnitude of error introduced by 3D to 2D projection </p></end-product>
  <timetable><p>* Reading of background material. </p><p>* Selection of particular measurements to investigate. </p><p>* Prototype of 3D scene. </p><p>* Completed project + report. </p></timetable>
  <references></references>
</project>
<project label="437723ba12c137622c3ce6acdebead5a">
  <title>Code Certification and Transformation</title>
  <supervisor>
    <smg24 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p><ul><li>CO7095 (desirable)</li><li>CO7206 (essential)</li> </ul> </p></prerequisites>
  <profiles><SET/><SFS/><ASE/></profiles>
  <aims><p><ul><li>To gain an understanding of best practices for coding in certain languages</li><li>To develop understanding of using CARE</li><li>To implement a set of code certification rules for a specific language</li><li>To implement a set of safe transformation rules</li> </ul> </p></aims>
  <challenges><p><ul><li>Understanding best practices and why they are important</li><li>Using CARE</li><li>Understanding and implementing markings based on XML/XPath</li> </ul> </p></challenges>
  <learning-outcomes><p>At the end of this project, the student should be able to:<ul><li>Critically analyze codesets and highlight bad coding blocks, with justification as to why they are bad and what the alternative could be</li><li>Analyze, design and implement a substational quantity of code certification rules in CARE</li><li>Design and implement a set of safe transformation rules in CARE</li> </ul> </p></learning-outcomes>
  <end-product><p>CARE project as defined above. </p></end-product>
  <timetable><p><ul><li>Familiarisation with CARE</li><li>Research into PL/SQL best practices</li><li>Generation of test scripts</li><li>Implementation of code certification rules</li><li>Implementation of transformation rules</li><li>Documentation</li> </ul> </p></timetable>
  <references></references>
</project>
<project label="de217f21d21d8d894b470020765efa06">
  <title>Reengineering of VBA to OO</title>
  <supervisor>
    <smg24 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p><ul><li>CO7206 (essential)</li> </ul> </p></prerequisites>
  <profiles><SET/><ASE/></profiles>
  <aims><p><ul><li>To gain a better understanding of reengineering practices.</li><li>To develop a methodology and toolset for the automated transformation of VBA code to either Java or C#.</li> </ul> </p></aims>
  <challenges><p><ul><li>Creation of a VBA parser</li><li>Development and implementation of transformation rules</li><li>Analyze, design and implement and set of code block identifiers for VBA code and their corresponding transformation rules to the target language</li> </ul> </p></challenges>
  <learning-outcomes><p>At the end of the project, the student should be able to:<ul><li>Analyze VBA code with respect to the target language and identify semantic differences between the two</li><li>Analyze, design and implement an XML parser for VBA code</li><li>Understand the subtle details of reengineering at the code level and the differences between languages</li> </ul> </p></learning-outcomes>
  <end-product><p><ul><li>VBA to XML parser</li><li>XML to OO (Java or C#) transformer</li><li>Documentation</li> </ul> </p></end-product>
  <timetable><p><ul><li>Design and implement VBA parser</li><li>Identify and categorise code block types in VBA</li><li>Design and implement transformation rules to target language, based on the XML model of the VBA code</li> </ul> </p></timetable>
  <references><reference>
  <author>R Seacor, D Plakosh and G Lewis</author>
  <volume>Modernizing Legacy Systems: Software Technologies, Engineering Processes and Business Practices</volume>
  <published year="2003"></published>
  <note>Mostly available from Google Books</note>
  </reference></references>
</project>
<project label="8b8373817381d1ed9147d22d394604b7">
  <title>A Ranking Mechanism for Service Oriented Models</title>
  <supervisor>
    <srm13 />
  </supervisor>
  <hidden>hidden by Artur upon Stephan's request</hidden>
  <prerequisites><p>Knowledge of SRML </p><p>Knowledge of web services </p></prerequisites>
  <profiles><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>The aim of the project is to explore an approach, the Logic Scoring of Preferences (LSP), for the definition of Service Level Agreement (SLA) constraints in Service Oriented Models expressed in SRML. The investigated approach is used to define a ranking, for example, of the available services based on a number of non-functional properties. </p></aims>
  <challenges><p><ul><li>Addressing the key challenges of the ranking of services based on Quality of Service</li><li>Familiarizing with an abstract framework for the definition of ranking criteria and the related tool</li><li>Providing a critical evaluation of the modelling exercise.</li> </ul> </p></challenges>
  <learning-outcomes><p>At the end of the project the student will be familiar with the key issues that concern the definition of Quality of Service constraints, which is a crucial in Service Oriented Engineering. This will allow straightforward familiarization with the specific technologies used, for example, Web services, Grid computing etc. The student will also be familiar with a tool for the definition of ranking criteria. </p></learning-outcomes>
  <end-product><p>The end product consists a set of ranking criteria for a given SLA of a given SRML module expressed with LSP and an account on the usage of a tool for LSP. Also the student will provide an brief report on that comments on the modelling experience. </p></end-product>
  <timetable><p>Develop a minimal background on LSP. </p><p>Understand the SLA of a given SRML module and express the ranking criteria with the tested framework (LSP). </p><p>Use the provided tool to analyze the produced SRML module. </p></timetable>
  <references><reference>
  <author>J. Abreu</author>
  <author>L. Bocchi</author>
  <author>J. Fiadeiro</author>
  <author>A. Lopes</author>
  <volume>The SENSORIA Reference Modelling Language</volume>
  <published year="2008">https://campus.cs.le.ac.uk/teaching/resources/CO7205/SRML(notes).pdf</published>
  </reference><reference>
  <author>H.Q. Yu and S. Reiff-Marganiec</author>
  <volume>A Method for Automated Web Service Selection.</volume>
  <published year="2008">2nd International Workshop on Web Service Composition and Adaptation (WSCA-2008) in IEEE Congress on Services - Part I, pp. 513-520.</published>
  </reference></references>
</project>
<project label="a9a8b86de3be6e1c741a551f1746ab84">
  <title>OWL-S Editor</title>
  <supervisor>
    <srm13 />
  </supervisor>
  <hidden>hidden by Artur</hidden>
  <prerequisites><p><b>NOTE:</b>Supervision will mainly be conducted by Hong Qing Yu. </p><p>Good understanding of XML, WSDL, OWL, Basic knowledge of Semantic Web &amp; Web services and Java (Eclipse) and web programming. </p></prerequisites>
  <profiles><WAS/><ASE/></profiles>
  <aims><p>OWL-S is an OWL-based (Web Ontology Language) framework of the Semantic Web. OWL-S is used to describing Semantic Web Services. It will enable users and software agents to automatically discover, invoke, compose, and monitor Web resources offering services, under specified constraints. However, it is lacking of easily and friendly used supporting tools for editing the OWL-S files, although OWL-S is still under research stage. The main aim of the project to develop a Web-GUI based light weighted OWL-S text editor (it focuses on the OWL-S profile and ground information editing) to mark up existed services. The service information is provided by the service's WSDL, functional properties and non-functional properties from service developers or providers. </p></aims>
  <challenges><p>(1) Fully understanding what OWL concept, syntax and logical semantics are.(2) Clearly understanding what relations between OWL and Web services are.(3) Understanding how the OWL-S marks up the services for specifying services' constraints. </p></challenges>
  <learning-outcomes><p>(1) Identifying the gap between Web service standard and semantic web service standards.(2) Define an ontology standard to describe service's non-functional properties.(3) Analyse OWL-S's benefits and downsides to give suggestions of the future Semantic Web service standards. </p></learning-outcomes>
  <end-product><p>The OWL-S text editor can easily for end-user wrap Web services' profile and grounding information through a friendly Web-GUI by providing the WSDL and related service documents. The outputs of the editor should have at least profile.owl and grounding.owl files. Moreover, the OWL-S files can be finally published on a central repository mapping to the correct services. </p></end-product>
  <timetable><p>(1) Researching on OWL-S and Web services to understand the concept and gain the basic technical skills. In this period, you can define the system architecture and challenges of development. (2) Further research to see if some OWL-S components or interfaces are existed for solving the challenges, then you can decide if you can reuse them into your project. (3) Develop the prototype of the editor to find hidden research issues or challenges and find out the solutions. (4) Fully develop the editor based on the prototype. (5) Writing Document and testing. (6) Start to evaluate the system. References </p><p> </p></timetable>
  <references><p>Texts on OWL-S, WSDL and Semantic Web </p></references>
</project>
<project label="673576c68958a8e5508cf2ed71b7e951">
  <title>Ant Colony Optimisation for the Shortest Path Problem</title>
  <supervisor>
    <sy11 />
  </supervisor>
  <hidden>shengxiang not taking projects this term</hidden>
  <prerequisites><p>Knowledge on algorithms and data structures. Programming skills in Java or C++ </p></prerequisites>
  <profiles><SET/><SFS/><ACM/><ADS/></profiles>
  <aims><p>The Shortest Path Problem (SPP) can be stated as follows: given a weighted network G in which each edge has a weight representing the length of the edge, the objective of Shortest Path Problem is to find a shortest path from some node s, called the source to another node, called the sink, in G. The SPP problem is the basic ingredient problem in network optimization problems. It also has numerous applications in other areas. </p><p>Many tranditional algorithms have been proposed for the SPP problem. However, in nature the ant colony can also solve the SPP problem when they are searching for food. From this researchers developed Ant Colony Optimisation (ACO) algorithms. The aim of this project is to design, implement, and demonstrate ACO algorithms and some tranditional optimization algorithms for SPPs with comparison of their performance in either C++ or Java </p></aims>
  <challenges><p>Understanding the key concepts of Ant Colony Optimisation </p><p>Implementing an Ant Colony Optimisation algorithm to solve the Shortest Path Problem in C++ or Java </p></challenges>
  <learning-outcomes><p>Learn about algorithm engineering </p><p>Learn about Ant Colony Optimisation </p><p>Implement an Ant Colony Optimisation algorithm for solving the Shortest Path Problem </p><p>Build a simple software package </p></learning-outcomes>
  <end-product><p>A practical software package for animating Ant Colony Optimisation for the Shortest Path Problem </p></end-product>
  <timetable><p>Month 1: Learning about Ant Colony Optimisation, the requirements and design of the tool, design of algorithms, start of prototype </p><p>Month 2: Prototype </p><p>Month 3: Final software tool, evaluation of algorithms </p></timetable>
  <references><reference>
  <author>Marco Dorigo and Thoms Stutzle</author>
  <volume>Ant Colony Optimisation</volume>
  <published year="2004">The MIT Press</published>
  <note>Available as<a href="http://www.cs.le.ac.uk/people/syang/ACO-Book.pdf">pdf</a></note>
  </reference></references>
</project>
<project label="13038680f45005c57fda7e149620ee83">
  <title>Evolutionary Algorithms for the Travelling Salesman Problem</title>
  <supervisor>
    <sy11 />
  </supervisor>
  <hidden>shengxiang not taking projects this term</hidden>
  <prerequisites><p>Knowledge on algorithms and data structures. Programming skills in Java or C++ </p></prerequisites>
  <profiles><SET/><SFS/><ACM/><ADS/></profiles>
  <aims><p>Evolutionary algorithms (EAs) are a class of problem solving algorithms based on principles drawn from natural evolution, such as nature selection and heredity. EAs maintain a population of candidate solutions to a given problem which are evaluated according to a problem-specific fitness function that defines the environment for the evolution. New population is created by selecting relatively fit members of the present population and recombining them through genetic operations using various genetic operators. Due to EA's characteristics of easy-to-use, great robustness and good parallel processing capacity, it has been used in a great number of scientific and engineering problems and models, such as numerical function optimization, combinatorial optimization (e.g., the knapsack problem, the job-shop scheduling problem, and the traveling salesman problem), automatic programming, machine learning, economics, and finance analysis. </p><p>The aim of this project is to design and implement a simple software package to demostrate and animate the process of using Evolutionary Algorithms for solving the Traveling Salesman Problem (TSP), which is to find the shortest cyclic route that passes each of a set of cities once and only once, in either C++ or Java. </p></aims>
  <challenges><p>Understanding the key concepts of evolutionary algorithms </p><p>Implementing evolutionary algorithms to solve the TSP in C++ or Java </p></challenges>
  <learning-outcomes><p>Learn about algorithm engineering </p><p>Learn about Evolutionary Algorithms </p><p>Implement Evolutionary Algorithms for solving the TSP </p><p>Build a simple software package </p></learning-outcomes>
  <end-product><p>A practical software package for animating Evolutionary Algorithms for the TSP </p></end-product>
  <timetable><p>Month 1: Learning about Evolutionary Algorithms, the requirements and design of the tool, design of algorithms, start of prototype </p><p>Month 2: Prototype </p><p>Month 3: Final software tool, evaluation of algorithms </p></timetable>
  <references><reference>
  <author>Zbigniew Michalewicz</author>
  <volume>Genetic Algorithms + Data Structures = Evolution Programs</volume>
  <published year="1999">Springer-Verlag</published>
  <note>3rd edition</note>
  </reference></references>
</project>
<project label="185931bef94e45c085235b3edef3e090">
  <title>Genetic Algorithms for Production Scheduling Systems</title>
  <supervisor>
    <sy11 />
  </supervisor>
  <hidden>shengxiang not taking projects this term</hidden>
  <prerequisites><p>Knowledge on algorithms and data structures. Programming skills in Java or C++ </p></prerequisites>
  <profiles><SET/><SFS/><ACM/><ADS/></profiles>
  <aims><p>The Job-shop Scheduling Problem (JSP) can be stated as follows: given N jobs to be processed on M machines in a prescribed order under certain restrictive assumptions. The objective of job-shop scheduling is to optimally arrange the processing order and the start times of operations to optimize certain criteria, such as the due date reliability, the mean lead time, and the makespan (the time required to process all of the given set of jobs). Minimizing the makespan will be considered as the main optimization criterion in this project. The JSSP problem is one of the most complicated and typical constraint satisfaction problems. Usually, it is NP-hard combinatorial optimization problem and arises in numerous applications, especially in the manufacturing systems. </p><p>Genetic algorithms (GAs) are a class of problem solving algorithms based on principles drawn from natural evolution, such as nature selection and heredity. GAs maintain a population of candidate solutions to a given problem which are evaluated according to a problem-specific fitness function that defines the environment for the evolution. New population is created by selecting relatively fit members of the present population and recombining them through genetic operations using various genetic operators. Due to GA's characteristics of easy-to-use, great robustness and good parallel processing capacity, it has been used in a great number of scientific and engineering problems and models, such as numerical function optimization, combinatorial optimization (e.g., the knapsack problem, the job-shop scheduling problem, and the traveling salesman problem), automatic programming, machine learning, economics, and finance analysis. </p><p>The aim of this project is to design and implement a simple software package using GAs for the JSSP in either C++ or Java. </p></aims>
  <challenges><p>Understanding the key concepts of genetic algorithms </p><p>Implementing GAs to solve the job-shop scheduling problem in C++ or Java </p></challenges>
  <learning-outcomes><p>Learn about algorithm engineering </p><p>Learn about Genetic Algorithms </p><p>Implement Genetic Algorithms for solving the JSSP </p><p>Build a simple software package </p></learning-outcomes>
  <end-product><p>A practical software package for animating Genetic Algorithms for the JSSP </p></end-product>
  <timetable><p>Month 1: Learning about Genetic Algorithms, the requirements and design of the tool, design of algorithms, start of prototype </p><p>Month 2: Prototype </p><p>Month 3: Final software tool, evaluation of algorithms </p></timetable>
  <references><reference>
  <author>Zbigniew Michalewicz</author>
  <volume>Genetic Algorithms + Data Structures = Evolution Programs</volume>
  <published year="1999">Springer-Verlag</published>
  <note>3rd edition</note>
  </reference></references>
</project>
<project label="05912bd46a4a24dcace5bee184b732ce">
  <title>Algorithms for Geometric Set Cover Problems</title>
  <supervisor>
    <te17 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Interest in algorithms. Programming skills. </p></prerequisites>
  <profiles><SET/><ACM/><ASE/></profiles>
  <aims><p>The set cover problem is one of the most fundamental problems in combinatorial optimisation: Given a family of subsets of a ground set, the goal is to compute a smallest number of sets that are sufficient to cover every element of the ground set. This project focuses on geometric versions of the problem, where the ground set consists of points in the plane and the subsets are given by simple geometric objects. This problem has recently received increasing attention, e.g. due to its applications in wireless networks. The aim of the project is to implement a tool that allows the generation of instances of the problem and the execution of algorithms on these instances, with the purpose of supporting algorithms researchers working on these topics. Some algorithms should be implemented and tested as well. The software can be implemented in any suitable programming language, e.g. C++ or Java. </p></aims>
  <challenges><p>Learn about a fundamental combinatorial optimisation problem. Design and implement new algorithms for geometric set cover problems. </p></challenges>
  <learning-outcomes><p>Ability to understand combinatorial optimisation problems and implement algorithms to solve them. Ability to design and evaluate heuristic solutions to optimisation problems. Ability to implement software tools for algorithms research. </p></learning-outcomes>
  <end-product><p>Software tool and evaluation of algorithms. </p></end-product>
  <timetable><p>Month 1: Learning about the problem and the known algorithms. Requirements and design of software tool. </p><p>Month 2: Prototype </p><p>Month 3: Final software, algorithm evaluation. </p></timetable>
  <references></references>
</project>
<project label="b7ef1b7cbccf12f9ffd358cb5a6ba38e">
  <title>Animation of Algorithms</title>
  <supervisor>
    <te17 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Interest in algorithms and visualisation. Programming skills in a suitable language/platform (e.g. Java, C++, C#, Silverlight). </p></prerequisites>
  <profiles><SET/><SFS/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>Advanced algorithms are often difficult to explain and understand. Algorithm animation can help by allowing the user to watch a visualisation of the execution of the algorithm on different input examples. The aim of this project is to implement a software tool or web application that supports the animation of selected algorithms (e.g. alignment algorithms in bioinformatics, geometric sweepline algorithms, etc.) </p></aims>
  <challenges><p>Understand and implement advanced algorithms; design and implement suitable animations. </p></challenges>
  <learning-outcomes><p>The student will be able to: Design and implement a moderately complex software solution; Understand and implement advanced algorithms; Design and implement visual animations to illustrate advanced concepts and methods. </p></learning-outcomes>
  <end-product><p>Software tool.</p></end-product>
  <timetable><p>Month 1: Learning about the algorithm, designing the animation requirements, starting the implementation. </p><p>Month 2-3: Completing the implementation and dissertation. </p></timetable>
  <references></references>
</project>
<project label="02a292e64646a70a676da9049e5dd0a3">
  <title>Automatic Map Labelling</title>
  <supervisor>
    <te17 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Interest in algorithms and graphics. Programming skills. </p></prerequisites>
  <profiles><SET/><ACM/><ASE/></profiles>
  <aims><p>The aim of this project is to implement a software tool that displays maps in which a number of point features (cities) are labelled automatically. The tool should allow zooming in and out, with labels appearing consistently in non-overlapping positions. This involves implementing an algorithm to select the features to be labelled at a given level of zooming, and to place the labels in disjoint positions. The tool can be implemented in any suitable programming language, e.g. in C++ or Java. It can also be a web application. </p></aims>
  <challenges><p>Understanding existing methods and designing new methods for automatic map labelling. Implementing nontrivial algorithms and creating a functional application. </p></challenges>
  <learning-outcomes><p>Ability to design and implement application software using nontrivial algorithms. </p></learning-outcomes>
  <end-product><p>Software tool to display maps and label them automatically. </p></end-product>
  <timetable><p>Month 1: Learning about map labelling; requirements and design; start of prototype. </p><p>Month 2: Prototype </p><p>Month 3: Final Software </p></timetable>
  <references></references>
</project>
<project label="36af495e7c44a9ccf7ce87f08a40ebaf">
  <title>Broadcast Scheduling Workbench</title>
  <supervisor>
    <te17 />
  </supervisor>
  <hidden>Was taken in summer 2009.</hidden>
  <prerequisites><p>Programming skills. </p></prerequisites>
  <profiles><SET/><ACM/><ADS/><ASE/></profiles>
  <aims><p>Broadcast scheduling deals with a scenario in which clients request pages of information and a server broadcasts pages in response to these requests. If a page has been requested by several clients, a single broadcast of the page satisfies all the requests. One tries to schedule the pages to be broadcast in such a way that certain criteria are optimised, e.g. the average response time. The aim of this project is to implement a tool with graphical user interface that allows the user to generate broadcast scheduling instances, run algorithms on these instances, and view and modify the resulting schedules. The purpose of the tool is to help algorithms researchers studying the broadcast scheduling problem. There is also the opportunity to develop new scheduling algorithms (e.g. heuristics) and evaluate them (using the tool). The tool can be implemented in any suitable programming language, but C++ or Java would be preferrable. </p></aims>
  <challenges><p>Understanding the broadcast scheduling problem and existing approaches to it. Designing and implementing a tool that is useful for algorithms researchers. Developing new algorithms for solving broadcast scheduling problems. </p></challenges>
  <learning-outcomes><p>Ability to implement softare tools for supporting research. Ability to understand models for scheduling problems and to design and implement algorithms for solving them. Ability to evaluate algorithms using experiments. </p></learning-outcomes>
  <end-product><p>Software tool, evaluation of algorithms. </p></end-product>
  <timetable><p>Month 1: Learning about the problem, requirements and design of the tool, design of algorithms, start of prototype. </p><p>Month 2: Prototype </p><p>Month 3: Final software tool, evaluation of algorithms. </p></timetable>
  <references></references>
</project>
<project label="f77421efebd14a316d953764e4b59814">
  <title>Computing with Uncertainty</title>
  <supervisor>
    <te17 />
  </supervisor>
  <hidden>chosen in spring 2010</hidden>
  <prerequisites><p>Knowledge about design and analysis of algorithms. Logical thinking and problem solving abilities. </p></prerequisites>
  <profiles><SFS/><ACM/><ADS/></profiles>
  <aims><p>Computing with uncertainty refers to situations where the goal is to compute a good solution but the input data is not given precisely. For example, the goal is to compute a minimum spanning tree, but the weights of the given graphs are not given, only intervals containing those weights are known. The algorithm can<strong>update</strong>an interval to obtain the exact value, and the goal is to compute a good solution with as few updates as possible. </p><p>The aim of this theoretical project is to study the literature to find out about the known results for uncertainty problems, and to study new problems under uncertainty and come up with good algorithms or proofs of the impossibility of good algorithms. </p><p>Existing work has dealt with problems such as shortest paths, minimum spanning trees, sorting, median-finding, and convex hulls. The project could explore problems such as flow problems, cut problems, scheduling problems, etc and consider them in the uncertainty model. </p></aims>
  <challenges><p>Read and understand research articles about known results for the problem. </p><p>Define, study and find research results for new problems under the uncertainty model. </p></challenges>
  <learning-outcomes><p>Understand and be able to discuss the research area of computing with uncertainty. </p><p>Be able to define and analyse optimisation problems under uncertainty. </p></learning-outcomes>
  <end-product><p>Dissertation with literature survey and research results. </p></end-product>
  <timetable><p>Month 1: Background reading, identification of problems for further study. </p><p>Month 2-3: Study research problems and obtain results. </p></timetable>
  <references><reference>
  <author>Thomas Erlebach, Michael Hoffmann, Danny Krizanc, Matus Mihalak and Rajeev Raman.</author>
  <volume>Computing Minimum Spanning Trees with Uncertainty.</volume>
  <published year="2008">Proceedings of the 25th International Symposium on Theoretical Aspects of Computer Science.</published>
  <note>Available as<a href="http://drops.dagstuhl.de/portals/STACS08/fulltext_link.php?id=1358">pdf</a></note>
  </reference></references>
</project>
<project label="3dd6b2c0cf7dab2691112406096fc0b0">
  <title>Energy-efficient routing in wireless networks</title>
  <supervisor>
    <te17 />
  </supervisor>
  <hidden>was taken in Summer 2009</hidden>
  <prerequisites><p>Interest in algorithms and networks. </p></prerequisites>
  <profiles><ACM/><ADS/><ASE/></profiles>
  <aims><p>The aim of the project is to study the problem of routing in wireless networks with the goal of minimising the energy consumption or maximising the network lifetime. The literature should be studied in order to provide a survey of the state of the art in this area. Furthermore, algorithms for computing energy-efficient routings should be studied theoretically or experimentally. </p></aims>
  <challenges><p>Read and understand current research articles on energy-efficient routing. Implement and evaluate different algorithms for energy-efficient routing. Come up with own algorithms for energy-efficient routing. </p></challenges>
  <learning-outcomes><p>Understand the main issues of energy minimisation in wireless networks. Be able to implement and evaluate existing algorithms. Be able to design, implement and evaluate own new algorithms. </p></learning-outcomes>
  <end-product><p>Written report and software product. </p></end-product>
  <timetable><p>Month 1: Literature review and initial prototype. </p><p>Month 2: Further implementation and design of own algorithm </p><p>Month 3: Experimental evaluation </p></timetable>
  <references></references>
</project>
<project label="fa32caac299a2788525022e2eb1dc4e7">
  <title>Exact Optimisation</title>
  <supervisor>
    <te17 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Interest in combinatorial optimisation. Programming skills in a suitable language (e.g. Java, C++). </p></prerequisites>
  <profiles><ACM/><ADS/><ASE/></profiles>
  <aims><p>The goal of the project is to implement a program that computes optimal solutions to a suitable NP-hard combinatorial optimisation problem (typically a problem involving graphs or networks, e.g. a multi-route cut problem). The techniques that can be used in the implementation include exhaustive search, branch-and-bound, branch-and-cut, linear programming techniques, dynamic programming, etc. If several approaches are implemented, they can be compared to each other on benchmark instances or randomly generated instances. </p></aims>
  <challenges><p>Understand and implement advanced optimisation algorithms. </p></challenges>
  <learning-outcomes><p>The student will understand and be able to implement advanced techniques for the solution of combinatorial optimisation problems, and to systematically evaluate the practical performance of algorithms. </p></learning-outcomes>
  <end-product><p>Software. Experimental evaluation. </p></end-product>
  <timetable><p>Month 1: Study optimisation methods and select suitable approaches, start implementation. </p><p>Month 2: Complete implementation </p><p>Experimental evaluation, Dissertation writing. </p></timetable>
  <references></references>
</project>
<project label="791399f31229e17e784779ce1fc19b63">
  <title>Exact Optimisation of Wireless Base Station Scheduling</title>
  <supervisor>
    <te17 />
  </supervisor>
  <hidden>taken in spring 2010</hidden>
  <prerequisites><p>Basic knowledge about algorithms and graphs. Interest in optimisation and algorithms. </p></prerequisites>
  <profiles><ACM/><ADS/><ASE/></profiles>
  <aims><p>The aim of this project is to implement an algorithm that computes optimal schedules for one-dimensional joint base station scheduling problems. In these problems, a number of base stations and mobile users are located along a line, and the goal is to compute a schedule that transmits data from base stations to users in as few rounds as possible, while satisfying all interference constraints. There is no known polynomial-time algorithm for this problem. The task of the project is to learn about integer programming techniques (branch-and-bound, branch-and-cut) and apply them to obtain an algorithm that computes optimal schedules for instances of this problem. The algorithm can be implemented in C++ or Java or any other suitable language. </p></aims>
  <challenges><p>Learning about advanced optimisation techniques and applying them to solve a difficult optimisation problem. Contributing own ideas to optimise the implementation or come up with better algorithms. </p></challenges>
  <learning-outcomes><p>Ability to tackle challenging optimisation problems using advanced algorithmic methods. </p></learning-outcomes>
  <end-product><p>Software tool (algorithm). </p></end-product>
  <timetable><p>Month 1: Background Research, Gathering of tools/libraries required. </p><p>Month 2: Prototype. </p><p>Month 3: Final software </p></timetable>
  <references><reference>
  <author>Thomas Erlebach, Riko Jacob, Matus Mihalak, Marc Nunkesser, Gabor Szabo, Peter Widmayer</author>
  <volume>Joint Base Station Scheduling</volume>
  <published year="2005">Proceedings of the Second Workshop on Approximation and Online Algorithms (WAOA 2004), LNCS 3351, Springer</published>
  <note>Full version available as<a href="ftp://ftp.inf.ethz.ch/pub/publications/tech-reports/4xx/462.pdf">pdf</a>.</note>
  </reference></references>
</project>
<project label="e6dc8173907d6d4a434c0959887a7457">
  <title>Fun with Silverlight</title>
  <supervisor>
    <te17 />
  </supervisor>
  <hidden>Was taken in summer 2009.</hidden>
  <prerequisites><p>Interest in learning about Microsoft's Silverlight technology. Ability to learn a new technology independently. Ideas for a suitable application to be implemented with Silverlight. </p></prerequisites>
  <profiles><SET/><WAS/><ADS/><ASE/></profiles>
  <aims><p>Microsoft's<a href="http://silverlight.net">Silverlight</a>is a recent web technology that promises to deliver improved multimedia experiences over the web. The aim of this project is to explore and learn Microsoft's Silverlight technology and implement an interesting web application (the choice is up to you) using that technology. In addition, a critical review of the strengths and weaknesses of that technology would be desirable. </p></aims>
  <challenges><p>Learn about a new technology independently. Implement a nontrivial application using a new technology. </p></challenges>
  <learning-outcomes><p>Familiarity with Silverlight. Ability to implement web applications using Silverlight. </p></learning-outcomes>
  <end-product><p>Implemented Silverlight application. Review of Silverlight technology. </p></end-product>
  <timetable><p>Month 1: Learning about Silverlight and installing a suitable development environment. Designing a suitable application to be implemented. </p><p>Month 2: Prototype </p><p>Month 3: Final software product, Silverlight review. </p></timetable>
  <references><reference>
  <author>Microsoft</author>
  <volume>Silverlight</volume>
  <published year="2008">Official Silverlight Website</published>
  <note><a href="http://silverlight.net/">Click here</a></note>
  </reference></references>
</project>
<project label="1c0546f43a2a9dcadd2ef670f4b62ac0">
  <title>Minimum Spanning Trees with Uncertainty</title>
  <supervisor>
    <te17 />
  </supervisor>
  <hidden>Was taken in summer 2009.</hidden>
  <prerequisites><p>Basic knowledge about (and interest in) algorithms and graphs. Programming skills. </p></prerequisites>
  <profiles><SET/><ACM/><ADS/><ASE/></profiles>
  <aims><p>The minimum spanning tree (MST) problem in graphs is a classical optimisation problem that can be solved efficiently with known algorithms. In this project we consider a variant of the problem where the weights of the edges of the given graph are not known exactly, but the exact weight of an edge can be obtained using an update operation. The goal is now to compute a minimum spanning tree using as few updates as possible. The aim of this project is to implement a tool that makes it possible to generate instances of the problem and run and evaluate different algorithms. In particular, it would be interesting to implement a randomised algorithm and compare it to known deterministic approaches. The implementation can be carried out in C++ or Java, for example, with the use of suitable libraries. </p></aims>
  <challenges><p>Understanding and implementing algorithms for a current research problem. </p></challenges>
  <learning-outcomes><p>Ability to implement algorithms for graph problems using suitable programming languages and libraries. Ability to systematically evaluate algorithms experimentally. Opportunity to design new algorithms. </p></learning-outcomes>
  <end-product><p>A software tool with suitable GUI that allows the user to run different algorithms for MSTs with uncertainty. Report about experimental evaluation of randomised and deterministic algorithms. </p></end-product>
  <timetable><p>Month 1: Requirements, Design, Initial Prototype </p><p>Month 2: Implementation of Software Tool </p><p>Month 3: Evaluation of implemented algorithms, potentially design and implementation of new algorithms. </p></timetable>
  <references><reference>
  <author>Thomas Erlebach, Michael Hoffmann, Danny Krizanc, Matus Mihalak and Rajeev Raman</author>
  <volume>Computing Minimum Spanning Trees with Uncertainty</volume>
  <published year="2008">Proceedings of the 25th International Symposium on Theoretical Aspects of Computer Science</published>
  <note>Available as<a href="http://drops.dagstuhl.de/portals/STACS08/fulltext_link.php?id=1358">pdf</a>.</note>
  </reference></references>
</project>
<project label="95495b098207cb5aa1e938595b2193a6">
  <title>Network Design Games</title>
  <supervisor>
    <te17 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Basic knowledge of game theory; programming skills.</p></prerequisites>
  <profiles><SFS/><ACM/><ADS/></profiles>
  <aims><p>The project studies game theoretic settings where players want to build a network. Each player wants to connect two nodes via a path, and the cost of a link is shared by all players using it. The project should study the literature to find out what is known about such games, and implement a software tool that makes it possible to compute the price of anarchy for such games and visualise the social optimum and the Nash equilibrium.</p></aims>
  <challenges><p>Read and understand research articles about network design games.</p>
  <p>Design and implement algorithm to compute optimal solution</p>
  <p>Design and implement algorithm to compute Nash equilibrium</p>
  <p>Design and implement appropriate visualisation</p>
  </challenges>
  <learning-outcomes><p>Understand and be able to discuss the definitions and known results about network design games</p>
  <p>Be able to design and implement advanced algorithms dealing with graphs and optimisation problems</p>
  </learning-outcomes>
  <end-product><p>Dissertation including survey of known results</p>
  <p>Software tool</p></end-product>
  <timetable><p>Month 1: Background research and draft literature survey; requirements, design and initial prototype.
  </p>
  <p>Month 2: Completion of literature survey; prototype </p>
  <p>Month 3: Final software product </p>
  </timetable>
  <references><reference>
  <author>
  Noam Nisan,
  Tim Roughgarden,
  Eva Tardos and
  Vijay V. Vazirani (eds.)
  </author>
  <volume>Algorithmic Game Theory</volume>
  <published year="2007"></published>
  <note>Section 19.3. Available
  <a href="http://www.cambridge.org/journals/nisan/downloads/nisan_non-printable.pdf">here</a>.</note>
  </reference></references>
</project>
<project label="681fc7ad56b5de6cffbb2c4eb7ae9ffe">
  <title>Network Simulation</title>
  <supervisor>
    <te17 />
  </supervisor>
  <hidden>Was taken in summer 2009.</hidden>
  <prerequisites><p>Basic knowledge about networking. Interest in network simulation. Familiarity with the programming language or scripting language used by the chosen network simulator. </p></prerequisites>
  <profiles><ACM/><ADS/></profiles>
  <aims><p>The aim of this project is to use a state-of-the-art network simulator (suggested: ns-2) to create a realistic network scenario, perform simulations, and analyse the obtained results. You can select the concrete setting to consider: For example, you could simulate routing algorithms or algorithms for life-time maximization in (mobile) wireless ad-hoc networks, or you could simulate effects of link failures in wired networks. </p></aims>
  <challenges><p>Learning and using a state-of-the-art network simulation tool such as ns-2. Deciding a suitable networking scenario and implementing the simulation. Meaningful analysis of the obtained simulation results. </p></challenges>
  <learning-outcomes><p>Ability to apply network simulators to study networking problems. Improved understanding of networking. </p></learning-outcomes>
  <end-product><p>Network simulation (scripts and configuration files) and interpretation of results (report). </p></end-product>
  <timetable><p>Month 1: Learning the chosen network simulator, installing the simulator and performing initial tests. Selecting a networking scenario for the simulations. </p><p>Month 2: Implementation of the simulation </p><p>Month 3: Running simulations and analysing and interpreting the results. </p></timetable>
  <references><reference>
  <author></author>
  <volume>The Network Simulator - ns-2</volume>
  <published></published>
  <note><a href="http://nsnam.isi.edu/nsnam/index.php/User_Information">ns-2 webpage</a></note>
  </reference></references>
</project>
<project label="7a8c9b9550fe9cec87eec63c4395dd86">
  <title>Selfish Routing</title>
  <supervisor>
    <te17 />
  </supervisor>
  <hidden>Was taken in summer 2009.</hidden>
  <prerequisites><p>Interest in game theory, programming skills. CO7212 desirable. </p></prerequisites>
  <profiles><SET/><SFS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>In recent years there has been significant interest in studying the effects of selfish behaviour in traffic networks using models from game theory. In particular, the<i>Price of Anarchy</i>measures how much worse a system behaves in a scenario with selfish actors as compared to one with global control. The aim of this project is to implement a software tool that lets the user interact with and visualize the effects of selfish routing on traffic networks (e.g. road networks, data networks). </p></aims>
  <challenges><p>Understanding the concepts of selfish routing, price of anarchy and Nash equilibria. Implementing a useful visualization tool. Implementing the required graph algorithms and optimisation algorithms. </p></challenges>
  <learning-outcomes><p>Experience in game-theoretic modelling of real-world scenarios with selfish actors. Ability to implement tools for visualising and manipulating such scenarios. </p></learning-outcomes>
  <end-product><p>Software tool. </p></end-product>
  <timetable><p>Month 1: Background research, requirements, design. </p><p>Month 2: Prototype </p><p>Month 3: Final software product </p></timetable>
  <references><reference>
  <author>Tim Roughgarden</author>
  <volume>Selfish Routing</volume>
  <published year="2002">PhD Thesis, Cornell University</published>
  <note>Available as<a href="http://www.cs.cornell.edu/timr/papers/thesis.pdf">pdf</a>.</note>
  </reference></references>
</project>
<project label="be9065726268874041aed28bf2535061">
  <title>Social Puzzle Game</title>
  <supervisor>
    <te17 />
  </supervisor>
  <hidden>taken in spring 2010</hidden>
  <prerequisites><p>None. </p></prerequisites>
  <profiles><ACM/><ADS/><ASE/></profiles>
  <aims><p>The aim of this project is to implement a web-based puzzle game where users can contribute their own puzzles. The puzzles should involve a simplified form of programming, e.g., to solve a puzzle the user needs to program a robot to collect stars. The game could be implemented using Silverlight or any other suitable technology for web applications. </p></aims>
  <challenges><p>Design puzzle game. Implement puzzle game in suitable web technology. Implement functionality for letting users contribute puzzles. </p></challenges>
  <learning-outcomes><p>Be able to implement distributed web applications. </p></learning-outcomes>
  <end-product><p>Written report and software product. </p></end-product>
  <timetable><p>Month 1: Puzzle design and initial prototype. </p><p>Month 2: Implementation. </p><p>Month 3: Testing and dissertation writing </p></timetable>
  <references></references>
</project>
<project label="639c263a9adf6136212d400b46ca7c87">
  <title>Comparing XSLT and XQuery</title>
  <supervisor>
    <tml12 />
  </supervisor>
  <hidden>This needs more work to make it "apples to apples". A big problem:  shortage of implementations.</hidden>
  <prerequisites><p>Basic knowledge of XML, Web Technologies and minimal familiarity with at least one of languages in question. </p></prerequisites>
  <profiles><SET/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>As observed by, e.g., Michael Kay, the teams designing XQuery and XSLT came from different CS cultures and had, originally, different purposes in mind. Nevertheless, there is a significant degree of overlap in functionality; most constructs present in either language have a counterpart in the other. </p><p>The aim of the project is to verify some of the claims about suitability of these languages for specific purposes, their relative merits and advantages---particularly in terms of speed. This will be achieved by choosing/designing a suitable collection of documents and queries and the use of benchmarking tools. </p></aims>
  <challenges><p>For many students, the biggest novelty will be probably the very use of benchmarking. It will be necessary to design queries and documents to experiment on adequately, so that they allow to verify the claims made by the community. That is, claims about relative advantages of one language over the other in a specific context which can be in found in sources such as "XQuery from the Experts" book or in professional discussion groups. One of the issues which has to be addressed and which always makes straightforward comparisons problematic is the difference between various implementations and benchmarking tools. </p></challenges>
  <learning-outcomes><p>Understanding both similarities and differences between XQuery and XSLT, their relative merits and disadvantages. Also, understanding the nature of benchmarking process, its rigours, benefits and limitations as the CS counterpart of an experiment. </p></learning-outcomes>
  <end-product><p>A technical report describing the question, the outcomes of benchmarking experiments and discussing possible conclusions. </p></end-product>
  <timetable></timetable>
  <references><reference>
  <author>Howard Katz</author>
  <author>Don Chamberlin</author>
  <author>Denise Draper</author>
  <author>Mary Fernandez</author>
  <author>Michael Kay</author>
  <author>Jonathan Robie</author>
  <author>Michael Rys</author>
  <author>Jerome Simeon</author>
  <author>Jim Tivy</author>
  <author>Philip Wadler</author>
  <article>XQuery from the Experts</article>
  </reference></references>
</project>
<project label="afab77e3802c5691b2bc3dbb54fb0f35">
  <title>Equivalent Expressions from the Core of XPath</title>
  <supervisor>
    <tml12 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Basic knowledge of XML and Web Technologies. </p></prerequisites>
  <profiles><SET/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>XPath is the common part of XQuery, XSLT and several other formalisms for XML processing such as XPointer. We focus on the "navigational core" of XPath 1.0, i.e., Core XPath of Gottlob, Koch and Pichler. This formalism can be thought of as a special kind of modal logic. </p><p>It is known that queries in the full language of XPath can be very sensitive to formulation. Depending on the benchmark and implementation provably equivalent ones, i.e., returning the same results for all possible documents can lead to completely different evaluation time, up to several orders of magnitude. </p><p>The goal of the project is to investigate whether similar phenomenon can be encountered in a much more restrictive class of Core XPath expressions. There are already several benchmarks which can be used for this purpose, see references below. XCheck, a platform for benchmarking XQuery processors developed at the University of Amsterdam, seems ready-made for this project. </p></aims>
  <challenges><p>For many students, one of novel aspects will be probably the very use of benchmarking. Another difficulty will be of conceptual character: the formal nature of Core XPath and papers on the subject and the idea of thinking of Core XPath queries as logical formulas of a special kind. </p></challenges>
  <learning-outcomes><p>Understanding<ul><li>the navigational nature of XPath</li><li>the need for optimization, its possible scope and the point of rewriting equivalent expressions</li><li>the nature of benchmarking process, its rigours, benefits and limitations as the CS counterpart of the notion of an experiment</li> </ul> </p></learning-outcomes>
  <end-product><p>A technical report describing the question, the outcomes of benchmarking experiments and discussing conclusions. </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author>Loredana Afanasiev</author>
  <author>Maarten Marx</author>
  <article>An Analysis of the Current XQuery Benchmarks</article>
  http://gemo.futurs.inria.fr/events/EXPDB2006/PAPERS/Afanasiev.pdf<volume>Proceedings of the First International Workshop on Performance and Evaluation of Data Management Systems, ExpDB 2006, p.9-20</volume>
  </reference><reference>
  <author>Georg Gottlob</author>
  <author>Christoph Koch</author>
  <author>Reinhard Pichler</author>
  <article>Efficient algorithms for processing XPath queries</article>
  <volume>ACM Trans. Database Syst. 2005, 30 (2), p. 444-491</volume>
  </reference><reference>
  <author>Balder ten Cate</author>
  <author>Tadeusz Litak</author>
  <author>Maarten Marx</author>
  <article>Complete axiomatizations of XPath fragments</article>
  <volume>Journal of Applied Logic 8(2):153-172</volume>
  </reference></references>
</project>
<project label="50e84b81640531b90319c5f4fbfce6ec">
  <title>Minesweeping with Mace4</title>
  <supervisor>
    <tml12 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>Some ability to think logically. Willingness to get acquainted with formal languages and deductive systems, mainly FOL (first-order logic) and equational logic </p></prerequisites>
  <profiles><SET/><ACM/><ADS/><ASE/></profiles>
  <aims><p>Minesweeper is a well-known, simple game whose variants come bundled with most operating systems and GUIs (crucially, with all versions of Windows since 3.1, but also with KDE, Gnome or Palm OS). Richard Kaye proved that it has surprisingly complex computational properties. Namely, the problem whether a given Minesweeper configuration is a valid one (i.e., whether it has a solution) is as complex as, e.g., the travelling salesman problem. In the language of complexity theory: it is NP-complete. </p><p>Mace4 is a (counter-)model finder. It is used to find models for satisfiable sets of FOL formulas. It is particularly useful in investigating axiomatically defined classes of algebras, but it has more recreational uses too. In particular, it can be used to handle games like Sudoku or logical puzzles. </p><p>The goal is to use Mace4 to find solve reasonably small valid Minesweeper configurations. Of course, due to the computational complexity issues, one of questions to answer is what "reasonably small" means, i.e, to find the largest size of the board for which Mace4 can find a solution reasonably quickly. </p><p>An additional programming task would be to provide a preprocessor translating user's description of a Minesweeper board to a valid Mace4 input. An optional challenge, depending on student's interests, would be to provide a front-end GUI. </p><p>Another optional challenge for those willing to dig deeper: Mace4 assumes the configuration is valid, i.e., has a solution. If it is not, Mace4 cannot know it without checking all possible solutions of a given size. Can we use its associated theorem prover (Prover9) to sort out possible invalid configurations more efficiently? </p></aims>
  <challenges><p><ul><li>To develop a correct, succinct and adequate description of the problem in the language of first-order/equational logic.</li><li>To learn how to use (counter-)model finders (and possibly theorem provers) for non-standard/practical/recreational purposes.</li><li>To understand and correctly analyze the output produced by such programs</li> </ul> </p></challenges>
  <learning-outcomes><ul><li>Basic understanding of FOL and equational logic</li><li>Basic experience in using first-order logic as a generic formal specification language</li><li>Basic experience in using countermodel finders, in particular Mace4</li><li>Understanding of difficulties posed by computationally complex (NP-complete) problems</li> </ul></learning-outcomes>
  <end-product><ul><li>A library of Prover9/Mace4 example inputs, similar to those available on William McCune's website</li><li>A short report describing the problem and the outcome of experiments with the program</li><li>A simple preprocessor/front-end for user-defined Minesweeper boards</li> </ul></end-product>
  <timetable></timetable>
  <references><reference>
  <author>Richard Kaye</author>
  <article><a href="http://web.mat.bham.ac.uk/R.W.Kaye/minesw/minesw.htm">Minesweeper is NP-complete</a></article>
  </reference><reference>
  <author>William McCune</author>
  <article><a href="http://www.cs.unm.edu/~mccune/mace4/">Prover9 and Mace4 website</a></article>
  </reference><reference>
  <author>William McCune</author>
  <article><a href="http://www.cs.unm.edu/~mccune/sudoku/details.html">Mace4 Sudoku example</a></article>
  </reference></references>
</project>
<project label="955b3b935a52973f1bf9407a200b05f2">
  <title>An id-mapping filesystem</title>
  <supervisor>
    <tr61 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p> good analytical and programming skills; a reasonable knowledge of the Unix filesystem
  </p></prerequisites>
  <profiles><SET/><SFS/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p> In Unix filesystems, every file has an associated owner, represented
  by a user id (uid). The uid is specific to a given system, ie my uid
  on one Unix system is typically not the same as it is on another. A
  typical use for uids is to enforce security: Unix allows files to be
  read only by the owner of the file (identified by uid).
  
  USB thumb drives are an extremely popular way to transfer files
  between systems.
  
  If you use a Unix filesystem on a USB drive, you have the problem that
  you may not be able to access files on systems other than the one on
  which you first created the file (because the uids do not match
  between systems).
  
  The aim of the project is to develop a FUSE filesystem (many
  programming language bindings are available) which maps uids to other
  uids, thereby solving the problem above.
  </p></aims>
  <challenges><p> Understanding the FUSE API. Understanding the Unix filesystem model.
  </p></challenges>
  <learning-outcomes><p> At the end of the project the student should:
  
  have a thorough understanding of the Unix filesystem model;
  
  have a good knowledge of the FUSE API;
  
  have a good knowledge of programming in a Unix environment
  </p></learning-outcomes>
  <end-product><p> The id-mapping filesystem
    </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note>fuse.sourceforge.net
  </note>
  </reference></references>
</project>
<project label="348ad4e3824982a780c9eecfd7f72844">
  <title>Formalising Linux bug hunting</title>
  <supervisor>
    <tr61 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>good analytical and programming skills; a good knowledge of C programming </p></prerequisites>
  <profiles><SET/><SFS/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>A recent article on LWN, http://lwn.net/Articles/382742/, "The case of
  the overly anonymous anon_vma", describes the fix for a Linux kernel
  bug. The bug was very difficult to find. The aim of this project is to
  investigate formal models of the (sub)system in question, to see
  whether they might have helped find this bug sooner. It is also
  possible that formal models would help find even more bugs. The formal
  model might take the form of a simple functional program and related
  datatypes, or a mathematical description of the subsystem, or a model
  suitable for exploration by a model checker.</p></aims>
  <challenges><p>understanding the Linux kernel subsystem; understanding the bug; understanding how a formal model could help; developing formal models to describe the subsystem; isolating problematic corner cases; checking the code against the model to ensure all difficult cases are handled correctly </p></challenges>
  <learning-outcomes><p>At the end of the project the student should: have a solid understanding of a small part of the Linux kernel; have a good understanding of the role formal methods can play in producing quality software; be able to construct formal models for low-level kernel code; be able to identify semantics mismatches between models and code, as fruitful sources of bugs; </p></learning-outcomes>
  <end-product><p>a formal model for the particular Linux subsystem, with a description of the bug in formal terms </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note>http://lwn.net/Articles/382742/</note>
  </reference></references>
</project>
<project label="00ce89720023bd55e2d159d64ed28414">
  <title>Formalising the correctness of implementations of distributed algorithms</title>
  <supervisor>
    <tr61 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>good analytical and programming skills; a good knowledge of distributed algorithms </p></prerequisites>
  <profiles><SET/><SFS/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p> Distributed algorithms are difficult to implement correctly. This
  project aims to apply formal methods to ensure correct implementation
  of distributed algorithms. You may choose the algorithm. The aim is
  then to implement this algorithm correctly, and to note as formally as
  possible any assumptions that are made eg about the underlying
  infrastructure used to implement the algorithm. Possible extensions
  include formalising the correctness of the algorithm (eg in set theory
  with pen and paper, as a model suitable for a model checker, or in a
  theorem prover), given the infrastructure assumptions.
  
  </p></aims>
  <challenges><p>understanding a distributed algorithm; implementing a distributed algorithm correctly; recognizing underlying implementation assumptions </p></challenges>
  <learning-outcomes><p>At the end of the project the student should: have a good knowledge of distributed algorithms and their implementation, and an excellent knowledge of their chosen algorithm; have a clear understanding of the existing infrastructure on which distributed algorithms are built; be competent in identifying assumptions that are made when providing an implementation of a distributed algorithm </p></learning-outcomes>
  <end-product><p>an implementation of a distributed algorithm; a list of assumptions that guarantee the implementation is correct </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note>@Book{lynch96distributed, author = {N. A. Lynch}, title = {Distributed Algorithms}, publisher = {Morgan Kaufmann}, year = {1996} }</note>
  </reference></references>
</project>
<project label="e15bb3b17a424103ce16b31f1a0fea84">
  <title>What are Bash translations</title>
  <supervisor>
    <tr61 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p> good analytical and programming skills; a good understanding of the
  Unix programming environment; a good understanding of functional
  programming
  </p></prerequisites>
  <profiles><SET/><SFS/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p> Bash is a popular Unix shell. Bash is extremely complicated. In
  particular, most shell programmers struggle with the various forms of
  translations that Bash can apply to the input string. The aim of this
  project is to formally describe these translations as a functional program.
  </p></aims>
  <challenges><p> understanding Bash translations; implementing Bash translations using
  a functional programming language
  </p></challenges>
  <learning-outcomes><p>At the end of this project the student should:
  
  understand the Unix programming environment and be an expert shell programmer;
  
  be able to implement non-trivial algorithms in a functional language
   </p></learning-outcomes>
  <end-product><p>Bash translation algorithms in a functional language
  
   </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note>http://www.gnu.org/software/bash/manual/bashref.html
  
  </note>
  </reference></references>
</project>
<project label="03518948311bf05e9cac57fa1b13df75">
  <title>What are POSIX filesystem guarantees</title>
  <supervisor>
    <tr61 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>good analytical and programming skills; a good understanding of Unix filesystems </p></prerequisites>
  <profiles><SET/><SFS/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>Many filesystems provide POSIX guarantees. For example, POSIX
  guarantees that renaming a file from a.txt to b.txt is an atomic
  action that either succeeds or fails. Similarly POSIX gives guarantees
  about the persistence of data when a "flush" system call
  returns. These guarantees are essentially the only guarantees software
  developers have when writing portable code that uses the
  filesystem. However, these guarantees have been gradually weakened and
  it is no longer clear what guarantees do in fact hold. A good example
  of confusion is the recent controversy surrounding the Linux ext4
  filesystem (see references). The aim of this project is to examine the
  POSIX filesystem specification, and produce a formal model clearly
  describing the guarantees provided by POSIX. A formal model may be a
  piece of precise mathematical text, or a model suitable for a model
  checker, or a simple functional program, or a sequence of
  definitions in a theorem prover.
   </p></aims>
  <challenges><p>understanding existing POSIX guarantees by close reading of the specification; running tests on various filesystems to determine how they interpret POSIX; constructing a formal model which clearly illustrates what guarantees application writers can expect from POSIX filesystems </p></challenges>
  <learning-outcomes><p>At the end of this project the student should: have a good knowledge of the POSIX filesystem specification; be an expert at programming to the POSIX filesystem specification; be competent in constructing formal models from informal specifications </p></learning-outcomes>
  <end-product><p>a formal model of the POSIX filesystem </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note>http://lwn.net/Articles/322823/ http://thunk.org/tytso/blog/2009/03/15/dont-fear-the-fsync/ http://blogs.gnome.org/alexl/2009/03/16/ext4-vs-fsync-my-take/ http://mjg59.livejournal.com/108257.html</note>
  </reference></references>
</project>
<project label="3dfa97b7017736faa23c7437d71add4d">
  <title>What is the CSV format</title>
  <supervisor>
    <tr61 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>good analytical and programming skills </p></prerequisites>
  <profiles><SET/><SFS/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>The CSV format is a popular format for storing row/column data. Unfortunately there is no specification for CSV. This has resulted in endless problems at all levels of IT. The aim of this project is to provide a post-hoc specification of CSV, together with related programs such as parsers, printers eg to XML, diff tools etc. The specification can take many forms eg it could be a BNF grammar, or a functional parser implementation, or sufficiently rigorous mathematical text, or a combination of all these things. </p></aims>
  <challenges><p>understanding the existing implementations of CSV; understanding what a formal specification is; implementing the CSV specification; implementing the supporting programs </p></challenges>
  <learning-outcomes><p>At the end of the project the student should: have a good understanding of what a formal specification is, and the need for formal specifications; be able to give a formal specification for CSV; have a good understanding of popular parsing tools such as lex and yacc, and be able to use them to implement the supporting programs for the project </p></learning-outcomes>
  <end-product><p>a formal specification of CSV; supporting programs, including at least a parser </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note>a too-simple specification is http://supercsv.sourceforge.net/csvSpecification.html</note>
  </reference></references>
</project>
<project label="341ed658c59fd789acbf2e7880c61c5d">
  <title>What is the semantics of SQL</title>
  <supervisor>
    <tr61 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>good analytical and programming skills; good knowledge of SQL; good functional programming skills </p></prerequisites>
  <profiles><SET/><SFS/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p> SQL is a very popular database query language. The basic theory of SQL
  is well understood. However, existing formal models (typically in set
  theory) are complex and often do not treat all the basic features of
  SQL. The aim of this project is to implement a core SQL interpreter in
  a functional language, thereby providing a clear semantics for core
  SQL features.
  </p></aims>
  <challenges><p>understanding the specification of SQL; understanding existing formalisations of SQL, and their drawbacks; implementing a core SQL interpreter in a functional language </p></challenges>
  <learning-outcomes><p>At the end of the project the student should: be an expert SQL programmer; understand the formal definition of the core features of SQL; be capable of constructing a formal specification in the shape of a functional program; be a good functional programmer </p></learning-outcomes>
  <end-product><p>the core SQL interpreter </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note></note>
  </reference></references>
</project>
<project label="ee163b13dc590eca4cccf27c63118697">
  <title>Who wants to be a moodle millionaire</title>
  <supervisor>
    <tr61 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>good analytical and programming skills
  
   </p></prerequisites>
  <profiles><SET/><SFS/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p> moodle is a popular course management system. moodle supports many
  different types of assessment eg computer-administered multiple choice
  questions.
  
  Laptops are widespread, and it is likely that all computer science
  students will own their own laptops soon. If every student has their
  own laptop, many innovative types of assessment are possible.
  
  "Who wants to be a millionaire?" is a popular TV quiz show. In the
  show, a nominated individual answers questions. Each correct answer
  increases the amount of money won. An incorrect answer finishes the
  game. The audience also participates by voting on the correct
  answer. The percentage of the audience selecting the right answer is
  revealed at the end of each round.
  
  The aim of this project is to develop a moodle component that can
  support assessment along the lines of "Millionaire" ie students voting
  on answers, and the results being revealed in real-time.
  </p></aims>
  <challenges><p> understanding the existing moodle codebase; designing innovative
  assessment types; implementation of the moodle component
  </p></challenges>
  <learning-outcomes><p> At the end of the project the student should:
  
  have a good understanding of the systems involved;
  
  have a good understanding of open source, component and web
  application development;
  
  be able to develop small web applications and extend existing web
  applications;
  
  be familiar with the main technologies and standards in use on the web
  today
  </p></learning-outcomes>
  <end-product><p> the moodle-millionaire component
  
  </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note>moodle.org, millionaire.itv.com</note>
  </reference></references>
</project>
<project label="0a55679f7b64d2e06172aaa29f8c2e99">
  <title>moodle doodle integration</title>
  <supervisor>
    <tr61 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>a very good understanding of Php and web technologies</p></prerequisites>
  <profiles><SET/><SFS/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>moodle is an open source course management system. doodle is a web app
  for scheduling appointments (among other things). The aim of the
  project is to add doodle-like functionality to moodle. </p></aims>
  <challenges><p> Understanding the existing systems. Developing new
  functionality. Integrating new functionality with existing
  systems. Incorporating work into an open-source project.</p></challenges>
  <learning-outcomes><p> At the end of the project the student should:
  
  have a good understanding of the systems involved;
  
  be able to develop small web applications and extend existing web
  applications;
  
  be familiar with the main technologies and standards in use on the web
  today</p></learning-outcomes>
  <end-product><p> The moodle-doodle integration component.</p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references>moodle.org, www.doodle.com
  </references>
</project>
<project label="a2fedcecd4da9fd2a0fe01e925e3ebba">
  <title>moodle iCal integration</title>
  <supervisor>
    <tr61 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p> good analytical and programming skills
  </p></prerequisites>
  <profiles><SET/><SFS/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p> moodle is an open source course management system. ical a popular
  calendar format. The most popular request for moodle is: "Calendar:
  IMPORT or Subscribe to iCal feed into Moodle calendar". The aim of the
  project is to provide this functionality.
  </p></aims>
  <challenges><p> understanding the existing systems; understanding the iCal format; web application development
  </p></challenges>
  <learning-outcomes><p> At the end of the project the student should:
  
  have a good understanding of web application development;
  
  have a good understanding of open source development;
  
  have a good understanding of system integration;
  
  have a good understanding of popular web protocols and formats
  
  </p></learning-outcomes>
  <end-product><p> the moodle-iCal integration component
  </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note>http://tracker.moodle.org/browse/MDL-16660
  </note>
  </reference></references>
</project>
<project label="909d5d632ced5710949fdc92c68305c6">
  <title>xmltvtimes</title>
  <supervisor>
    <tr61 />
  </supervisor>
  <hidden></hidden>
  <prerequisites><p>good analytical and programming skills; a good understanding of xml </p></prerequisites>
  <profiles><SET/><SFS/><WAS/><ACM/><ADS/><ASE/></profiles>
  <aims><p>There has been an explosion of television and radio channels. There
  are now too many channels for an individual to manually scan to decide
  which programmes to consume. The alternative is for a user to record
  their consumption preferences in a system that continually scans media
  schedules for relevant programmes. The system then alerts the user
  when a programme becomes scheduled that they may wish to consume. The
  aim of this project is to develop such a system.
   </p></aims>
  <challenges><p>understanding the xmltv format; deciding on a mechanism to record user preferences; implementing the proposed system </p></challenges>
  <learning-outcomes><p>At the end of the project the student should: have a good understanding of web application development; have a good understanding of popular web protocols and formats </p></learning-outcomes>
  <end-product><p>the xmltvtimes system described above </p></end-product>
  <timetable><p> </p><p> </p></timetable>
  <references><reference>
  <author></author>
  <volume></volume>
  <published year="1901"></published>
  <note>wiki.xmltv.org</note>
  </reference></references>
</project>
</projects>
